
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/blend/go-sdk/assert/assert.go (28.9%)</option>
				
				<option value="file1">github.com/blend/go-sdk/collections/autoflush_buffer.go (70.9%)</option>
				
				<option value="file2">github.com/blend/go-sdk/collections/channel_queue.go (27.7%)</option>
				
				<option value="file3">github.com/blend/go-sdk/collections/linked_list.go (43.8%)</option>
				
				<option value="file4">github.com/blend/go-sdk/collections/rate_limiter.go (100.0%)</option>
				
				<option value="file5">github.com/blend/go-sdk/collections/ring_buffer.go (70.6%)</option>
				
				<option value="file6">github.com/blend/go-sdk/collections/set.go (75.3%)</option>
				
				<option value="file7">github.com/blend/go-sdk/collections/string_array.go (100.0%)</option>
				
				<option value="file8">github.com/blend/go-sdk/collections/sync_ring_buffer.go (62.3%)</option>
				
				<option value="file9">github.com/blend/go-sdk/collections/types.go (0.0%)</option>
				
				<option value="file10">github.com/blend/go-sdk/configutil/config_util.go (37.5%)</option>
				
				<option value="file11">github.com/blend/go-sdk/configutil/types.go (100.0%)</option>
				
				<option value="file12">github.com/blend/go-sdk/cron/atomic_flag.go (77.8%)</option>
				
				<option value="file13">github.com/blend/go-sdk/cron/event.go (41.7%)</option>
				
				<option value="file14">github.com/blend/go-sdk/cron/job.go (39.3%)</option>
				
				<option value="file15">github.com/blend/go-sdk/cron/job_manager.go (66.6%)</option>
				
				<option value="file16">github.com/blend/go-sdk/cron/schedule.go (57.0%)</option>
				
				<option value="file17">github.com/blend/go-sdk/cron/task.go (81.8%)</option>
				
				<option value="file18">github.com/blend/go-sdk/cron/util.go (22.7%)</option>
				
				<option value="file19">github.com/blend/go-sdk/db/buffer_pool.go (100.0%)</option>
				
				<option value="file20">github.com/blend/go-sdk/db/column.go (85.7%)</option>
				
				<option value="file21">github.com/blend/go-sdk/db/column_collection.go (83.9%)</option>
				
				<option value="file22">github.com/blend/go-sdk/db/config.go (69.2%)</option>
				
				<option value="file23">github.com/blend/go-sdk/db/connection.go (65.6%)</option>
				
				<option value="file24">github.com/blend/go-sdk/db/db.go (58.6%)</option>
				
				<option value="file25">github.com/blend/go-sdk/db/default.go (88.9%)</option>
				
				<option value="file26">github.com/blend/go-sdk/db/invocation.go (77.1%)</option>
				
				<option value="file27">github.com/blend/go-sdk/db/migration/body.go (85.7%)</option>
				
				<option value="file28">github.com/blend/go-sdk/db/migration/data_file_reader.go (24.4%)</option>
				
				<option value="file29">github.com/blend/go-sdk/db/migration/default.go (0.0%)</option>
				
				<option value="file30">github.com/blend/go-sdk/db/migration/event.go (0.0%)</option>
				
				<option value="file31">github.com/blend/go-sdk/db/migration/group.go (0.0%)</option>
				
				<option value="file32">github.com/blend/go-sdk/db/migration/guards.go (49.3%)</option>
				
				<option value="file33">github.com/blend/go-sdk/db/migration/logger.go (10.0%)</option>
				
				<option value="file34">github.com/blend/go-sdk/db/migration/statements.go (83.3%)</option>
				
				<option value="file35">github.com/blend/go-sdk/db/migration/step.go (26.3%)</option>
				
				<option value="file36">github.com/blend/go-sdk/db/populate.go (27.7%)</option>
				
				<option value="file37">github.com/blend/go-sdk/db/query.go (55.6%)</option>
				
				<option value="file38">github.com/blend/go-sdk/db/statement_cache.go (82.9%)</option>
				
				<option value="file39">github.com/blend/go-sdk/db/util.go (70.0%)</option>
				
				<option value="file40">github.com/blend/go-sdk/env/env.go (55.6%)</option>
				
				<option value="file41">github.com/blend/go-sdk/exception/exception.go (66.7%)</option>
				
				<option value="file42">github.com/blend/go-sdk/exception/stack_trace.go (67.1%)</option>
				
				<option value="file43">github.com/blend/go-sdk/exception/util.go (33.3%)</option>
				
				<option value="file44">github.com/blend/go-sdk/logger/ansi_colors.go (100.0%)</option>
				
				<option value="file45">github.com/blend/go-sdk/logger/audit_event.go (19.8%)</option>
				
				<option value="file46">github.com/blend/go-sdk/logger/buffer_pool.go (100.0%)</option>
				
				<option value="file47">github.com/blend/go-sdk/logger/config.go (61.7%)</option>
				
				<option value="file48">github.com/blend/go-sdk/logger/default.go (0.0%)</option>
				
				<option value="file49">github.com/blend/go-sdk/logger/error_event.go (58.5%)</option>
				
				<option value="file50">github.com/blend/go-sdk/logger/event.go (60.0%)</option>
				
				<option value="file51">github.com/blend/go-sdk/logger/flag.go (50.0%)</option>
				
				<option value="file52">github.com/blend/go-sdk/logger/flag_set.go (73.8%)</option>
				
				<option value="file53">github.com/blend/go-sdk/logger/interlocked_writer.go (40.0%)</option>
				
				<option value="file54">github.com/blend/go-sdk/logger/json_writer.go (48.4%)</option>
				
				<option value="file55">github.com/blend/go-sdk/logger/logger.go (62.3%)</option>
				
				<option value="file56">github.com/blend/go-sdk/logger/message_event.go (54.5%)</option>
				
				<option value="file57">github.com/blend/go-sdk/logger/query_event.go (39.1%)</option>
				
				<option value="file58">github.com/blend/go-sdk/logger/response_writer.go (0.0%)</option>
				
				<option value="file59">github.com/blend/go-sdk/logger/text_writer.go (67.1%)</option>
				
				<option value="file60">github.com/blend/go-sdk/logger/time.go (43.8%)</option>
				
				<option value="file61">github.com/blend/go-sdk/logger/timed_event.go (50.0%)</option>
				
				<option value="file62">github.com/blend/go-sdk/logger/util.go (26.7%)</option>
				
				<option value="file63">github.com/blend/go-sdk/logger/web_request_event.go (33.3%)</option>
				
				<option value="file64">github.com/blend/go-sdk/logger/worker.go (100.0%)</option>
				
				<option value="file65">github.com/blend/go-sdk/logger/write_helpers.go (0.0%)</option>
				
				<option value="file66">github.com/blend/go-sdk/logger/writer.go (0.0%)</option>
				
				<option value="file67">github.com/blend/go-sdk/oauth/config.go (90.5%)</option>
				
				<option value="file68">github.com/blend/go-sdk/oauth/error.go (0.0%)</option>
				
				<option value="file69">github.com/blend/go-sdk/oauth/jwt.go (73.0%)</option>
				
				<option value="file70">github.com/blend/go-sdk/oauth/manager.go (53.1%)</option>
				
				<option value="file71">github.com/blend/go-sdk/oauth/oauth_state.go (78.6%)</option>
				
				<option value="file72">github.com/blend/go-sdk/oauth/profile.go (62.5%)</option>
				
				<option value="file73">github.com/blend/go-sdk/oauth/util.go (28.6%)</option>
				
				<option value="file74">github.com/blend/go-sdk/proxy/buffer_pool.go (0.0%)</option>
				
				<option value="file75">github.com/blend/go-sdk/proxy/proxy.go (47.8%)</option>
				
				<option value="file76">github.com/blend/go-sdk/proxy/redirect_http.go (100.0%)</option>
				
				<option value="file77">github.com/blend/go-sdk/proxy/resolver.go (100.0%)</option>
				
				<option value="file78">github.com/blend/go-sdk/proxy/upstream.go (52.0%)</option>
				
				<option value="file79">github.com/blend/go-sdk/proxy/util.go (0.0%)</option>
				
				<option value="file80">github.com/blend/go-sdk/request/events.go (34.8%)</option>
				
				<option value="file81">github.com/blend/go-sdk/request/meta.go (42.1%)</option>
				
				<option value="file82">github.com/blend/go-sdk/request/mock.go (48.6%)</option>
				
				<option value="file83">github.com/blend/go-sdk/request/request.go (56.2%)</option>
				
				<option value="file84">github.com/blend/go-sdk/selector/and.go (100.0%)</option>
				
				<option value="file85">github.com/blend/go-sdk/selector/equals.go (100.0%)</option>
				
				<option value="file86">github.com/blend/go-sdk/selector/has_key.go (100.0%)</option>
				
				<option value="file87">github.com/blend/go-sdk/selector/in.go (86.7%)</option>
				
				<option value="file88">github.com/blend/go-sdk/selector/not_equals.go (88.9%)</option>
				
				<option value="file89">github.com/blend/go-sdk/selector/not_has_key.go (100.0%)</option>
				
				<option value="file90">github.com/blend/go-sdk/selector/not_in.go (71.4%)</option>
				
				<option value="file91">github.com/blend/go-sdk/selector/parse.go (100.0%)</option>
				
				<option value="file92">github.com/blend/go-sdk/selector/parser.go (85.9%)</option>
				
				<option value="file93">github.com/blend/go-sdk/selector/util.go (94.3%)</option>
				
				<option value="file94">github.com/blend/go-sdk/semver/constraint.go (94.3%)</option>
				
				<option value="file95">github.com/blend/go-sdk/semver/version.go (94.7%)</option>
				
				<option value="file96">github.com/blend/go-sdk/template/helpers.go (80.0%)</option>
				
				<option value="file97">github.com/blend/go-sdk/template/semver.go (20.2%)</option>
				
				<option value="file98">github.com/blend/go-sdk/template/template.go (68.4%)</option>
				
				<option value="file99">github.com/blend/go-sdk/template/uuid.go (88.9%)</option>
				
				<option value="file100">github.com/blend/go-sdk/util/ansi_colors.go (100.0%)</option>
				
				<option value="file101">github.com/blend/go-sdk/util/base64.go (0.0%)</option>
				
				<option value="file102">github.com/blend/go-sdk/util/bitflag.go (100.0%)</option>
				
				<option value="file103">github.com/blend/go-sdk/util/boolean.go (100.0%)</option>
				
				<option value="file104">github.com/blend/go-sdk/util/coalesce.go (0.0%)</option>
				
				<option value="file105">github.com/blend/go-sdk/util/combinatorics.go (84.4%)</option>
				
				<option value="file106">github.com/blend/go-sdk/util/crypto.go (63.5%)</option>
				
				<option value="file107">github.com/blend/go-sdk/util/error.go (0.0%)</option>
				
				<option value="file108">github.com/blend/go-sdk/util/file.go (44.4%)</option>
				
				<option value="file109">github.com/blend/go-sdk/util/format.go (0.0%)</option>
				
				<option value="file110">github.com/blend/go-sdk/util/gcm.go (74.1%)</option>
				
				<option value="file111">github.com/blend/go-sdk/util/gzip.go (81.2%)</option>
				
				<option value="file112">github.com/blend/go-sdk/util/json.go (83.3%)</option>
				
				<option value="file113">github.com/blend/go-sdk/util/math.go (49.8%)</option>
				
				<option value="file114">github.com/blend/go-sdk/util/optional.go (0.0%)</option>
				
				<option value="file115">github.com/blend/go-sdk/util/parallel.go (88.6%)</option>
				
				<option value="file116">github.com/blend/go-sdk/util/parse.go (25.5%)</option>
				
				<option value="file117">github.com/blend/go-sdk/util/random.go (0.0%)</option>
				
				<option value="file118">github.com/blend/go-sdk/util/reflection.go (69.1%)</option>
				
				<option value="file119">github.com/blend/go-sdk/util/sequence.go (50.0%)</option>
				
				<option value="file120">github.com/blend/go-sdk/util/stream_crypto.go (70.8%)</option>
				
				<option value="file121">github.com/blend/go-sdk/util/string.go (85.0%)</option>
				
				<option value="file122">github.com/blend/go-sdk/util/ternary.go (0.0%)</option>
				
				<option value="file123">github.com/blend/go-sdk/util/time.go (5.1%)</option>
				
				<option value="file124">github.com/blend/go-sdk/util/vector.go (94.7%)</option>
				
				<option value="file125">github.com/blend/go-sdk/util/web.go (63.9%)</option>
				
				<option value="file126">github.com/blend/go-sdk/util/xml.go (80.0%)</option>
				
				<option value="file127">github.com/blend/go-sdk/uuid/uuid.go (80.6%)</option>
				
				<option value="file128">github.com/blend/go-sdk/web/app.go (65.7%)</option>
				
				<option value="file129">github.com/blend/go-sdk/web/app_event.go (33.3%)</option>
				
				<option value="file130">github.com/blend/go-sdk/web/auth_manager.go (74.6%)</option>
				
				<option value="file131">github.com/blend/go-sdk/web/cached_static_file.go (0.0%)</option>
				
				<option value="file132">github.com/blend/go-sdk/web/cached_static_file_server.go (76.9%)</option>
				
				<option value="file133">github.com/blend/go-sdk/web/compressed_response_writer.go (80.0%)</option>
				
				<option value="file134">github.com/blend/go-sdk/web/config.go (80.4%)</option>
				
				<option value="file135">github.com/blend/go-sdk/web/constants.go (80.0%)</option>
				
				<option value="file136">github.com/blend/go-sdk/web/ctx.go (47.3%)</option>
				
				<option value="file137">github.com/blend/go-sdk/web/error.go (100.0%)</option>
				
				<option value="file138">github.com/blend/go-sdk/web/healthz.go (30.8%)</option>
				
				<option value="file139">github.com/blend/go-sdk/web/heathz_config.go (0.0%)</option>
				
				<option value="file140">github.com/blend/go-sdk/web/https_upgrader.go (15.3%)</option>
				
				<option value="file141">github.com/blend/go-sdk/web/https_upgrader_config.go (0.0%)</option>
				
				<option value="file142">github.com/blend/go-sdk/web/json_result.go (100.0%)</option>
				
				<option value="file143">github.com/blend/go-sdk/web/json_result_provider.go (18.2%)</option>
				
				<option value="file144">github.com/blend/go-sdk/web/middleware.go (26.7%)</option>
				
				<option value="file145">github.com/blend/go-sdk/web/mock_request_builder.go (66.8%)</option>
				
				<option value="file146">github.com/blend/go-sdk/web/mock_response_writer.go (71.4%)</option>
				
				<option value="file147">github.com/blend/go-sdk/web/no_content_result.go (0.0%)</option>
				
				<option value="file148">github.com/blend/go-sdk/web/no_content_result_provider.go (0.0%)</option>
				
				<option value="file149">github.com/blend/go-sdk/web/raw_response_writer.go (90.9%)</option>
				
				<option value="file150">github.com/blend/go-sdk/web/raw_result.go (100.0%)</option>
				
				<option value="file151">github.com/blend/go-sdk/web/redirect_result.go (0.0%)</option>
				
				<option value="file152">github.com/blend/go-sdk/web/rewrite_rule.go (100.0%)</option>
				
				<option value="file153">github.com/blend/go-sdk/web/route.go (33.3%)</option>
				
				<option value="file154">github.com/blend/go-sdk/web/route_parameters.go (25.0%)</option>
				
				<option value="file155">github.com/blend/go-sdk/web/session.go (68.4%)</option>
				
				<option value="file156">github.com/blend/go-sdk/web/session_cache.go (100.0%)</option>
				
				<option value="file157">github.com/blend/go-sdk/web/session_middleware.go (60.7%)</option>
				
				<option value="file158">github.com/blend/go-sdk/web/state.go (77.3%)</option>
				
				<option value="file159">github.com/blend/go-sdk/web/static_file_server.go (81.6%)</option>
				
				<option value="file160">github.com/blend/go-sdk/web/static_result.go (68.4%)</option>
				
				<option value="file161">github.com/blend/go-sdk/web/tcp_keep_alive_listener.go (100.0%)</option>
				
				<option value="file162">github.com/blend/go-sdk/web/text_result_provider.go (41.7%)</option>
				
				<option value="file163">github.com/blend/go-sdk/web/tls_config.go (56.7%)</option>
				
				<option value="file164">github.com/blend/go-sdk/web/tree.go (85.8%)</option>
				
				<option value="file165">github.com/blend/go-sdk/web/util.go (63.2%)</option>
				
				<option value="file166">github.com/blend/go-sdk/web/view_cache.go (33.3%)</option>
				
				<option value="file167">github.com/blend/go-sdk/web/view_cache_config.go (100.0%)</option>
				
				<option value="file168">github.com/blend/go-sdk/web/view_model.go (0.0%)</option>
				
				<option value="file169">github.com/blend/go-sdk/web/view_result.go (70.6%)</option>
				
				<option value="file170">github.com/blend/go-sdk/web/view_result_provider.go (71.1%)</option>
				
				<option value="file171">github.com/blend/go-sdk/web/xml_result.go (0.0%)</option>
				
				<option value="file172">github.com/blend/go-sdk/web/xml_result_provider.go (0.0%)</option>
				
				<option value="file173">github.com/blend/go-sdk/worker/interval_worker.go (66.7%)</option>
				
				<option value="file174">github.com/blend/go-sdk/worker/latch.go (92.7%)</option>
				
				<option value="file175">github.com/blend/go-sdk/worker/queue_worker.go (69.0%)</option>
				
				<option value="file176">github.com/blend/go-sdk/workqueue/entry.go (85.7%)</option>
				
				<option value="file177">github.com/blend/go-sdk/workqueue/queue.go (53.0%)</option>
				
				<option value="file178">github.com/blend/go-sdk/workqueue/worker.go (96.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package assert

import (
        "fmt"
        "math"
        "os"
        "reflect"
        "runtime"
        "strings"
        "sync/atomic"
        "testing"
        "time"
        "unicode"
        "unicode/utf8"
)

const (
        // RED is the ansi escape code fragment for red.
        RED = "31"
        // BLUE is the ansi escape code fragment for blue.
        BLUE = "94"
        // GREEN is the ansi escape code fragment for green.
        GREEN = "32"
        // YELLOW is the ansi escape code fragment for yellow.
        YELLOW = "33"
        // WHITE is the ansi escape code fragment for white.
        WHITE = "37"
        // GRAY is the ansi escape code fragment for gray.
        GRAY = "90"

        // EMPTY is a constant for the empty (0 length) string.
        EMPTY = ""
)

var assertCount int32

func incrementAssertCount() <span class="cov8" title="1">{
        atomic.AddInt32(&amp;assertCount, int32(1))
}</span>

// Count returns the total number of assertions.
func Count() int <span class="cov0" title="0">{
        return int(assertCount)
}</span>

// Predicate is a func that returns a bool.
type Predicate func(item interface{}) bool

//PredicateOfInt is a func that takes an int and returns a bool.
type PredicateOfInt func(item int) bool

// PredicateOfFloat is a func that takes a float64 and returns a bool.
type PredicateOfFloat func(item float64) bool

// PredicateOfString is a func that takes a string and returns a bool.
type PredicateOfString func(item string) bool

// PredicateOfTime is a func that takes a time.Time and returns a bool.
type PredicateOfTime func(item time.Time) bool

// Assertions is the main entry point for using the assertions library.
type Assertions struct {
        t            *testing.T
        timerAbort   chan bool
        timerAborted chan bool
}

// Empty returns an empty assertions class; useful when you want to apply assertions w/o hooking into the testing framework.
func Empty() *Assertions <span class="cov8" title="1">{
        return &amp;Assertions{}
}</span>

// New returns a new instance of `Assertions`.
func New(t *testing.T) *Assertions <span class="cov0" title="0">{
        return &amp;Assertions{t: t, timerAbort: make(chan bool), timerAborted: make(chan bool)}
}</span>

func (a *Assertions) assertion() <span class="cov0" title="0">{
        incrementAssertCount()
}</span>

// NonFatal transitions the assertion into a `NonFatal` assertion; that is, one that will not cause the test to abort if it fails.
// NonFatal assertions are useful when you want to check many properties during a test, but only on an informational basis.
func (a *Assertions) NonFatal() *Optional <span class="cov8" title="1">{ //golint you can bite me.
        return &amp;Optional{a.t}
}</span>

// NotNil asserts that a reference is not nil.
func (a *Assertions) NotNil(object interface{}, userMessageComponents ...interface{}) <span class="cov0" title="0">{
        a.assertion()
        if didFail, message := shouldNotBeNil(object); didFail </span><span class="cov0" title="0">{
                failNow(a.t, message, userMessageComponents...)
        }</span>
}

// Nil asserts that a reference is nil.
func (a *Assertions) Nil(object interface{}, userMessageComponents ...interface{}) <span class="cov0" title="0">{
        a.assertion()
        if didFail, message := shouldBeNil(object); didFail </span><span class="cov0" title="0">{
                failNow(a.t, message, userMessageComponents...)
        }</span>
}

// Len asserts that a collection has a given length.
func (a *Assertions) Len(length int, collection interface{}, userMessageComponents ...interface{}) <span class="cov0" title="0">{
        a.assertion()
        if didFail, message := shouldHaveLength(collection, length); didFail </span><span class="cov0" title="0">{
                failNow(a.t, message, userMessageComponents...)
        }</span>
}

// Empty asserts that a collection is empty.
func (a *Assertions) Empty(collection interface{}, userMessageComponents ...interface{}) <span class="cov0" title="0">{
        a.assertion()
        if didFail, message := shouldBeEmpty(collection); didFail </span><span class="cov0" title="0">{
                failNow(a.t, message, userMessageComponents...)
        }</span>
}

// NotEmpty asserts that a collection is not empty.
func (a *Assertions) NotEmpty(collection interface{}, userMessageComponents ...interface{}) <span class="cov0" title="0">{
        a.assertion()
        if didFail, message := shouldNotBeEmpty(collection); didFail </span><span class="cov0" title="0">{
                failNow(a.t, message, userMessageComponents...)
        }</span>
}

// Equal asserts that two objects are deeply equal.
func (a *Assertions) Equal(expected interface{}, actual interface{}, userMessageComponents ...interface{}) <span class="cov0" title="0">{
        a.assertion()
        if didFail, message := shouldBeEqual(expected, actual); didFail </span><span class="cov0" title="0">{
                failNow(a.t, message, userMessageComponents...)
        }</span>
}

// NotEqual asserts that two objects are not deeply equal.
func (a *Assertions) NotEqual(expected interface{}, actual interface{}, userMessageComponents ...interface{}) <span class="cov0" title="0">{
        a.assertion()
        if didFail, message := shouldNotBeEqual(expected, actual); didFail </span><span class="cov0" title="0">{
                failNow(a.t, message, userMessageComponents...)
        }</span>
}

// Zero asserts that a value is equal to it's default value.
func (a *Assertions) Zero(value interface{}, userMessageComponents ...interface{}) <span class="cov0" title="0">{
        a.assertion()
        if didFail, message := shouldBeZero(value); didFail </span><span class="cov0" title="0">{
                failNow(a.t, message, userMessageComponents...)
        }</span>
}

// NotZero asserts that a value is not equal to it's default value.
func (a *Assertions) NotZero(value interface{}, userMessageComponents ...interface{}) <span class="cov0" title="0">{
        a.assertion()
        if didFail, message := shouldBeNonZero(value); didFail </span><span class="cov0" title="0">{
                failNow(a.t, message, userMessageComponents...)
        }</span>
}

// True asserts a boolean is true.
func (a *Assertions) True(object bool, userMessageComponents ...interface{}) <span class="cov0" title="0">{
        a.assertion()
        if didFail, message := shouldBeTrue(object); didFail </span><span class="cov0" title="0">{
                failNow(a.t, message, userMessageComponents...)
        }</span>
}

// False asserts a boolean is false.
func (a *Assertions) False(object bool, userMessageComponents ...interface{}) <span class="cov0" title="0">{
        a.assertion()
        if didFail, message := shouldBeFalse(object); didFail </span><span class="cov0" title="0">{
                failNow(a.t, message, userMessageComponents...)
        }</span>
}

// InDelta asserts that two floats are within a delta.
func (a *Assertions) InDelta(f1, f2, delta float64, userMessageComponents ...interface{}) <span class="cov0" title="0">{
        a.assertion()
        if didFail, message := shouldBeInDelta(f1, f2, delta); didFail </span><span class="cov0" title="0">{
                failNow(a.t, message, userMessageComponents...)
        }</span>
}

// InTimeDelta asserts that times t1 and t2 are within a delta.
func (a *Assertions) InTimeDelta(t1, t2 time.Time, delta time.Duration, userMessageComponents ...interface{}) <span class="cov0" title="0">{
        a.assertion()
        if didFail, message := shouldBeInTimeDelta(t1, t2, delta); didFail </span><span class="cov0" title="0">{
                failNow(a.t, message, userMessageComponents...)
        }</span>
}

// FileExists asserts that a file exists at a given filepath on disk.
func (a *Assertions) FileExists(filepath string, userMessageComponents ...interface{}) <span class="cov0" title="0">{
        a.assertion()
        if didFail, message := fileShouldExist(filepath); didFail </span><span class="cov0" title="0">{
                failNow(a.t, message, userMessageComponents...)
        }</span>
}

// Contains asserts that a substring is present in a corpus.
func (a *Assertions) Contains(substring, corpus string, userMessageComponents ...interface{}) <span class="cov0" title="0">{
        a.assertion()
        if didFail, message := shouldContain(substring, corpus); didFail </span><span class="cov0" title="0">{
                failNow(a.t, message, userMessageComponents...)
        }</span>
}

// Any applies a predicate.
func (a *Assertions) Any(target interface{}, predicate Predicate, userMessageComponents ...interface{}) <span class="cov0" title="0">{
        a.assertion()
        if didFail, message := shouldAny(target, predicate); didFail </span><span class="cov0" title="0">{
                failNow(a.t, message, userMessageComponents...)
        }</span>
}

// AnyOfInt applies a predicate.
func (a *Assertions) AnyOfInt(target []int, predicate PredicateOfInt, userMessageComponents ...interface{}) <span class="cov0" title="0">{
        a.assertion()
        if didFail, message := shouldAnyOfInt(target, predicate); didFail </span><span class="cov0" title="0">{
                failNow(a.t, message, userMessageComponents...)
        }</span>
}

// AnyOfFloat applies a predicate.
func (a *Assertions) AnyOfFloat(target []float64, predicate PredicateOfFloat, userMessageComponents ...interface{}) <span class="cov0" title="0">{
        a.assertion()
        if didFail, message := shouldAnyOfFloat(target, predicate); didFail </span><span class="cov0" title="0">{
                failNow(a.t, message, userMessageComponents...)
        }</span>
}

// AnyOfString applies a predicate.
func (a *Assertions) AnyOfString(target []string, predicate PredicateOfString, userMessageComponents ...interface{}) <span class="cov0" title="0">{
        a.assertion()
        if didFail, message := shouldAnyOfString(target, predicate); didFail </span><span class="cov0" title="0">{
                failNow(a.t, message, userMessageComponents...)
        }</span>
}

// All applies a predicate.
func (a *Assertions) All(target interface{}, predicate Predicate, userMessageComponents ...interface{}) <span class="cov0" title="0">{
        a.assertion()
        if didFail, message := shouldAll(target, predicate); didFail </span><span class="cov0" title="0">{
                failNow(a.t, message, userMessageComponents...)
        }</span>
}

// AllOfInt applies a predicate.
func (a *Assertions) AllOfInt(target []int, predicate PredicateOfInt, userMessageComponents ...interface{}) <span class="cov0" title="0">{
        a.assertion()
        if didFail, message := shouldAllOfInt(target, predicate); didFail </span><span class="cov0" title="0">{
                failNow(a.t, message, userMessageComponents...)
        }</span>
}

// AllOfFloat applies a predicate.
func (a *Assertions) AllOfFloat(target []float64, predicate PredicateOfFloat, userMessageComponents ...interface{}) <span class="cov0" title="0">{
        a.assertion()
        if didFail, message := shouldAllOfFloat(target, predicate); didFail </span><span class="cov0" title="0">{
                failNow(a.t, message, userMessageComponents...)
        }</span>
}

// AllOfString applies a predicate.
func (a *Assertions) AllOfString(target []string, predicate PredicateOfString, userMessageComponents ...interface{}) <span class="cov0" title="0">{
        a.assertion()
        if didFail, message := shouldAllOfString(target, predicate); didFail </span><span class="cov0" title="0">{
                failNow(a.t, message, userMessageComponents...)
        }</span>
}

// None applies a predicate.
func (a *Assertions) None(target interface{}, predicate Predicate, userMessageComponents ...interface{}) <span class="cov0" title="0">{
        a.assertion()
        if didFail, message := shouldNone(target, predicate); didFail </span><span class="cov0" title="0">{
                failNow(a.t, message, userMessageComponents...)
        }</span>
}

// NoneOfInt applies a predicate.
func (a *Assertions) NoneOfInt(target []int, predicate PredicateOfInt, userMessageComponents ...interface{}) <span class="cov0" title="0">{
        a.assertion()
        if didFail, message := shouldNoneOfInt(target, predicate); didFail </span><span class="cov0" title="0">{
                failNow(a.t, message, userMessageComponents...)
        }</span>
}

// NoneOfFloat applies a predicate.
func (a *Assertions) NoneOfFloat(target []float64, predicate PredicateOfFloat, userMessageComponents ...interface{}) <span class="cov0" title="0">{
        a.assertion()
        if didFail, message := shouldNoneOfFloat(target, predicate); didFail </span><span class="cov0" title="0">{
                failNow(a.t, message, userMessageComponents...)
        }</span>
}

// NoneOfString applies a predicate.
func (a *Assertions) NoneOfString(target []string, predicate PredicateOfString, userMessageComponents ...interface{}) <span class="cov0" title="0">{
        a.assertion()
        if didFail, message := shouldNoneOfString(target, predicate); didFail </span><span class="cov0" title="0">{
                failNow(a.t, message, userMessageComponents...)
        }</span>
}

// FailNow forces a test failure (useful for debugging).
func (a *Assertions) FailNow(userMessageComponents ...interface{}) <span class="cov0" title="0">{
        failNow(a.t, "Fatal Assertion Failed", userMessageComponents...)
}</span>

// StartTimeout starts a timed block.
func (a *Assertions) StartTimeout(timeout time.Duration, userMessageComponents ...interface{}) <span class="cov0" title="0">{
        ticker := time.NewTimer(timeout)
        go func() </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        panic("Timeout Reached")</span>
                case &lt;-a.timerAbort:<span class="cov0" title="0">
                        a.timerAborted &lt;- true
                        return</span>
                }
        }()
}

// EndTimeout marks a timed block as complete.
func (a *Assertions) EndTimeout() <span class="cov0" title="0">{
        a.timerAbort &lt;- true
        &lt;-a.timerAborted
}</span>

// Optional is an assertion type that does not stop a test if an assertion fails, simply outputs the error.
type Optional struct {
        t *testing.T
}

func (o *Optional) assertion() <span class="cov8" title="1">{
        incrementAssertCount()
}</span>

// Nil asserts the object is nil.
func (o *Optional) Nil(object interface{}, userMessageComponents ...interface{}) bool <span class="cov0" title="0">{
        o.assertion()
        if didFail, message := shouldBeNil(object); didFail </span><span class="cov0" title="0">{
                fail(o.t, prefixOptional(message), userMessageComponents...)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// NotNil asserts the object is not nil.
func (o *Optional) NotNil(object interface{}, userMessageComponents ...interface{}) bool <span class="cov0" title="0">{
        o.assertion()
        if didFail, message := shouldNotBeNil(object); didFail </span><span class="cov0" title="0">{
                fail(o.t, prefixOptional(message), userMessageComponents...)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// Len asserts that the collection has a specified length.
func (o *Optional) Len(length int, collection interface{}, userMessageComponents ...interface{}) bool <span class="cov0" title="0">{
        o.assertion()
        if didFail, message := shouldHaveLength(collection, length); didFail </span><span class="cov0" title="0">{
                fail(o.t, prefixOptional(message), userMessageComponents...)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// Empty asserts that a collection is empty.
func (o *Optional) Empty(collection interface{}, userMessageComponents ...interface{}) bool <span class="cov0" title="0">{
        o.assertion()
        if didFail, message := shouldBeEmpty(collection); didFail </span><span class="cov0" title="0">{
                fail(o.t, prefixOptional(message), userMessageComponents...)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// NotEmpty asserts that a collection is not empty.
func (o *Optional) NotEmpty(collection interface{}, userMessageComponents ...interface{}) bool <span class="cov0" title="0">{
        o.assertion()
        if didFail, message := shouldNotBeEmpty(collection); didFail </span><span class="cov0" title="0">{
                fail(o.t, prefixOptional(message), userMessageComponents...)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// Equal asserts that two objects are equal.
func (o *Optional) Equal(expected interface{}, actual interface{}, userMessageComponents ...interface{}) bool <span class="cov0" title="0">{
        o.assertion()
        if didFail, message := shouldBeEqual(expected, actual); didFail </span><span class="cov0" title="0">{
                fail(o.t, prefixOptional(message), userMessageComponents...)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// NotEqual asserts that two objects are not equal.
func (o *Optional) NotEqual(expected interface{}, actual interface{}, userMessageComponents ...interface{}) bool <span class="cov0" title="0">{
        o.assertion()
        if didFail, message := shouldNotBeEqual(expected, actual); didFail </span><span class="cov0" title="0">{
                fail(o.t, prefixOptional(message), userMessageComponents...)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// Zero asserts that a value is the default value.
func (o *Optional) Zero(value interface{}, userMessageComponents ...interface{}) bool <span class="cov0" title="0">{
        o.assertion()
        if didFail, message := shouldBeZero(value); didFail </span><span class="cov0" title="0">{
                fail(o.t, prefixOptional(message), userMessageComponents...)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// NotZero asserts that a value is not the default value.
func (o *Optional) NotZero(value interface{}, userMessageComponents ...interface{}) bool <span class="cov0" title="0">{
        o.assertion()
        if didFail, message := shouldBeNonZero(value); didFail </span><span class="cov0" title="0">{
                fail(o.t, prefixOptional(message), userMessageComponents...)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// True asserts that a bool is false.
func (o *Optional) True(object bool, userMessageComponents ...interface{}) bool <span class="cov8" title="1">{
        o.assertion()
        if didFail, message := shouldBeTrue(object); didFail </span><span class="cov8" title="1">{
                fail(o.t, prefixOptional(message), userMessageComponents...)
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

// False asserts that a bool is false.
func (o *Optional) False(object bool, userMessageComponents ...interface{}) bool <span class="cov0" title="0">{
        o.assertion()
        if didFail, message := shouldBeFalse(object); didFail </span><span class="cov0" title="0">{
                fail(o.t, prefixOptional(message), userMessageComponents...)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// InDelta returns if two float64s are separated by a given delta.
func (o *Optional) InDelta(a, b, delta float64, userMessageComponents ...interface{}) bool <span class="cov0" title="0">{
        o.assertion()
        if didFail, message := shouldBeInDelta(a, b, delta); didFail </span><span class="cov0" title="0">{
                fail(o.t, prefixOptional(message), userMessageComponents...)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// InTimeDelta returns if two times are separated by a given delta.
func (o *Optional) InTimeDelta(a, b time.Time, delta time.Duration, userMessageComponents ...interface{}) bool <span class="cov0" title="0">{
        o.assertion()
        if didFail, message := shouldBeInTimeDelta(a, b, delta); didFail </span><span class="cov0" title="0">{
                fail(o.t, prefixOptional(message), userMessageComponents...)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// FileExists asserts that a file exists on disk at a given filepath.
func (o *Optional) FileExists(filepath string, userMessageComponents ...interface{}) bool <span class="cov0" title="0">{
        o.assertion()
        if didFail, message := fileShouldExist(filepath); didFail </span><span class="cov0" title="0">{
                fail(o.t, prefixOptional(message), userMessageComponents...)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// Contains checks if a substring is present in a corpus.
func (o *Optional) Contains(substring, corpus string, userMessageComponents ...interface{}) bool <span class="cov0" title="0">{
        o.assertion()
        if didFail, message := shouldContain(substring, corpus); didFail </span><span class="cov0" title="0">{
                fail(o.t, prefixOptional(message), userMessageComponents...)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// Any applies a predicate.
func (o *Optional) Any(target interface{}, predicate Predicate, userMessageComponents ...interface{}) bool <span class="cov0" title="0">{
        o.assertion()
        if didFail, message := shouldAny(target, predicate); didFail </span><span class="cov0" title="0">{
                fail(o.t, prefixOptional(message), userMessageComponents...)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// AnyOfInt applies a predicate.
func (o *Optional) AnyOfInt(target []int, predicate PredicateOfInt, userMessageComponents ...interface{}) bool <span class="cov0" title="0">{
        o.assertion()
        if didFail, message := shouldAnyOfInt(target, predicate); didFail </span><span class="cov0" title="0">{
                failNow(o.t, message, userMessageComponents...)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// AnyOfFloat applies a predicate.
func (o *Optional) AnyOfFloat(target []float64, predicate PredicateOfFloat, userMessageComponents ...interface{}) bool <span class="cov0" title="0">{
        o.assertion()
        if didFail, message := shouldAnyOfFloat(target, predicate); didFail </span><span class="cov0" title="0">{
                failNow(o.t, message, userMessageComponents...)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// AnyOfString applies a predicate.
func (o *Optional) AnyOfString(target []string, predicate PredicateOfString, userMessageComponents ...interface{}) bool <span class="cov0" title="0">{
        o.assertion()
        if didFail, message := shouldAnyOfString(target, predicate); didFail </span><span class="cov0" title="0">{
                failNow(o.t, message, userMessageComponents...)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// All applies a predicate.
func (o *Optional) All(target interface{}, predicate Predicate, userMessageComponents ...interface{}) bool <span class="cov0" title="0">{
        o.assertion()
        if didFail, message := shouldAll(target, predicate); didFail </span><span class="cov0" title="0">{
                failNow(o.t, message, userMessageComponents...)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// AllOfInt applies a predicate.
func (o *Optional) AllOfInt(target []int, predicate PredicateOfInt, userMessageComponents ...interface{}) bool <span class="cov0" title="0">{
        o.assertion()
        if didFail, message := shouldAllOfInt(target, predicate); didFail </span><span class="cov0" title="0">{
                failNow(o.t, message, userMessageComponents...)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// AllOfFloat applies a predicate.
func (o *Optional) AllOfFloat(target []float64, predicate PredicateOfFloat, userMessageComponents ...interface{}) bool <span class="cov0" title="0">{
        o.assertion()
        if didFail, message := shouldAllOfFloat(target, predicate); didFail </span><span class="cov0" title="0">{
                failNow(o.t, message, userMessageComponents...)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// AllOfString applies a predicate.
func (o *Optional) AllOfString(target []string, predicate PredicateOfString, userMessageComponents ...interface{}) bool <span class="cov0" title="0">{
        o.assertion()
        if didFail, message := shouldAllOfString(target, predicate); didFail </span><span class="cov0" title="0">{
                failNow(o.t, message, userMessageComponents...)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// None applies a predicate.
func (o *Optional) None(target interface{}, predicate Predicate, userMessageComponents ...interface{}) bool <span class="cov0" title="0">{
        o.assertion()
        if didFail, message := shouldNone(target, predicate); didFail </span><span class="cov0" title="0">{
                failNow(o.t, message, userMessageComponents...)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// NoneOfInt applies a predicate.
func (o *Optional) NoneOfInt(target []int, predicate PredicateOfInt, userMessageComponents ...interface{}) bool <span class="cov0" title="0">{
        o.assertion()
        if didFail, message := shouldNoneOfInt(target, predicate); didFail </span><span class="cov0" title="0">{
                failNow(o.t, message, userMessageComponents...)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// NoneOfFloat applies a predicate.
func (o *Optional) NoneOfFloat(target []float64, predicate PredicateOfFloat, userMessageComponents ...interface{}) bool <span class="cov0" title="0">{
        o.assertion()
        if didFail, message := shouldNoneOfFloat(target, predicate); didFail </span><span class="cov0" title="0">{
                failNow(o.t, message, userMessageComponents...)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// NoneOfString applies a predicate.
func (o *Optional) NoneOfString(target []string, predicate PredicateOfString, userMessageComponents ...interface{}) bool <span class="cov0" title="0">{
        o.assertion()
        if didFail, message := shouldNoneOfString(target, predicate); didFail </span><span class="cov0" title="0">{
                failNow(o.t, message, userMessageComponents...)
                return false
        }</span>
        <span class="cov0" title="0">return true</span>
}

// Fail manually injects a failure.
func (o *Optional) Fail(userMessageComponents ...interface{}) <span class="cov0" title="0">{
        fail(o.t, prefixOptional("Assertion Failed"), userMessageComponents...)
}</span>

// --------------------------------------------------------------------------------
// OUTPUT
// --------------------------------------------------------------------------------

func failNow(t *testing.T, message string, userMessageComponents ...interface{}) <span class="cov0" title="0">{
        fail(t, message, userMessageComponents...)
        if t != nil </span><span class="cov0" title="0">{
                t.FailNow()
        }</span> else<span class="cov0" title="0"> {
                os.Exit(1)
        }</span>
}

func fail(t *testing.T, message string, userMessageComponents ...interface{}) <span class="cov8" title="1">{
        errorTrace := strings.Join(callerInfo(), "\n\t")

        if len(errorTrace) == 0 </span><span class="cov8" title="1">{
                errorTrace = "Unknown"
        }</span>

        <span class="cov8" title="1">assertionFailedLabel := color("Assertion Failed!", RED)
        locationLabel := color("Assert Location", GRAY)
        assertionLabel := color("Assertion", GRAY)
        messageLabel := color("Message", GRAY)

        erasure := fmt.Sprintf("\r%s", getClearString())

        if len(userMessageComponents) != 0 </span><span class="cov8" title="1">{
                userMessage := fmt.Sprint(userMessageComponents...)

                errorFormat := `%s
%s
%s:
        %s
%s: 
        %s
%s: 
        %s

`
                if t != nil </span><span class="cov0" title="0">{
                        t.Errorf(errorFormat, erasure, assertionFailedLabel, locationLabel, errorTrace, assertionLabel, message, messageLabel, userMessage)
                }</span> else<span class="cov8" title="1"> {
                        fmt.Fprintf(os.Stderr, errorFormat, "", assertionFailedLabel, locationLabel, errorTrace, assertionLabel, message, messageLabel, userMessage)
                }</span>

        } else<span class="cov0" title="0"> {
                errorFormat := `%s
%s
%s: 
        %s
%s: 
        %s

`
                if t != nil </span><span class="cov0" title="0">{
                        t.Errorf(errorFormat, erasure, assertionFailedLabel, locationLabel, errorTrace, assertionLabel, message)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Fprintf(os.Stderr, errorFormat, "", assertionFailedLabel, locationLabel, errorTrace, assertionLabel, message)
                }</span>
        }
}

// --------------------------------------------------------------------------------
// ASSERTION LOGIC
// --------------------------------------------------------------------------------

func shouldHaveLength(collection interface{}, length int) (bool, string) <span class="cov0" title="0">{
        if l := getLength(collection); l != length </span><span class="cov0" title="0">{
                message := shouldBeMultipleMessage(length, l, "Collection should have length")
                return true, message
        }</span>
        <span class="cov0" title="0">return false, EMPTY</span>
}

func shouldNotBeEmpty(collection interface{}) (bool, string) <span class="cov0" title="0">{
        if l := getLength(collection); l == 0 </span><span class="cov0" title="0">{
                message := "Should not be empty"
                return true, message
        }</span>
        <span class="cov0" title="0">return false, EMPTY</span>
}

func shouldBeEmpty(collection interface{}) (bool, string) <span class="cov0" title="0">{
        if l := getLength(collection); l != 0 </span><span class="cov0" title="0">{
                message := shouldBeMessage(collection, "Should be empty")
                return true, message
        }</span>
        <span class="cov0" title="0">return false, EMPTY</span>
}

func shouldBeEqual(expected, actual interface{}) (bool, string) <span class="cov8" title="1">{
        if !areEqual(expected, actual) </span><span class="cov8" title="1">{
                return true, equalMessage(actual, expected)
        }</span>
        <span class="cov8" title="1">return false, EMPTY</span>
}

func shouldNotBeEqual(expected, actual interface{}) (bool, string) <span class="cov0" title="0">{
        if areEqual(expected, actual) </span><span class="cov0" title="0">{
                return true, notEqualMessage(actual, expected)
        }</span>
        <span class="cov0" title="0">return false, EMPTY</span>
}

func shouldNotBeNil(object interface{}) (bool, string) <span class="cov8" title="1">{
        if isNil(object) </span><span class="cov8" title="1">{
                return true, "Should not be nil"
        }</span>
        <span class="cov8" title="1">return false, EMPTY</span>
}

func shouldBeNil(object interface{}) (bool, string) <span class="cov8" title="1">{
        if !isNil(object) </span><span class="cov8" title="1">{
                return true, shouldBeMessage(object, "Should be nil")
        }</span>
        <span class="cov8" title="1">return false, EMPTY</span>
}

func shouldBeTrue(value bool) (bool, string) <span class="cov8" title="1">{
        if !value </span><span class="cov8" title="1">{
                return true, "Should be true"
        }</span>
        <span class="cov8" title="1">return false, EMPTY</span>
}

func shouldBeFalse(value bool) (bool, string) <span class="cov0" title="0">{
        if value </span><span class="cov0" title="0">{
                return true, "Should be false"
        }</span>
        <span class="cov0" title="0">return false, EMPTY</span>
}

func shouldBeZero(value interface{}) (bool, string) <span class="cov0" title="0">{
        if !isZero(value) </span><span class="cov0" title="0">{
                return true, shouldBeMessage(value, "Should be zero")
        }</span>
        <span class="cov0" title="0">return false, EMPTY</span>
}

func shouldBeNonZero(value interface{}) (bool, string) <span class="cov0" title="0">{
        if isZero(value) </span><span class="cov0" title="0">{
                return true, "Should be non-zero"
        }</span>
        <span class="cov0" title="0">return false, EMPTY</span>
}

func fileShouldExist(filePath string) (bool, string) <span class="cov0" title="0">{
        _, err := os.Stat(filePath)
        if err != nil </span><span class="cov0" title="0">{
                pwd, _ := os.Getwd()
                message := fmt.Sprintf("File doesnt exist: %s, `pwd`: %s", filePath, pwd)
                return true, message
        }</span>
        <span class="cov0" title="0">return false, EMPTY</span>
}

func shouldBeInDelta(from, to, delta float64) (bool, string) <span class="cov0" title="0">{
        diff := math.Abs(from - to)
        if diff &gt; delta </span><span class="cov0" title="0">{
                message := fmt.Sprintf("Difference of %0.5f and %0.5f should be less than %0.5f", from, to, delta)
                return true, message
        }</span>
        <span class="cov0" title="0">return false, EMPTY</span>
}

func shouldBeInTimeDelta(from, to time.Time, delta time.Duration) (bool, string) <span class="cov8" title="1">{
        var diff time.Duration
        if from.After(to) </span><span class="cov8" title="1">{
                diff = from.Sub(to)
        }</span> else<span class="cov8" title="1"> {
                diff = to.Sub(from)
        }</span>
        <span class="cov8" title="1">if diff &gt; delta </span><span class="cov8" title="1">{
                message := fmt.Sprintf("Delta of %s and %s should be less than %v", from.Format(time.RFC3339), to.Format(time.RFC3339), delta)
                return true, message
        }</span>
        <span class="cov8" title="1">return false, EMPTY</span>
}

func shouldContain(subString, corpus string) (bool, string) <span class="cov8" title="1">{
        if !strings.Contains(corpus, subString) </span><span class="cov8" title="1">{
                message := fmt.Sprintf("`%s` should contain `%s`", corpus, subString)
                return true, message
        }</span>
        <span class="cov8" title="1">return false, EMPTY</span>
}

func shouldAny(target interface{}, predicate Predicate) (bool, string) <span class="cov8" title="1">{
        t := reflect.TypeOf(target)
        for t.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                t = t.Elem()
        }</span>

        <span class="cov8" title="1">v := reflect.ValueOf(target)
        for v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                v = v.Elem()
        }</span>

        <span class="cov8" title="1">if t.Kind() != reflect.Slice </span><span class="cov8" title="1">{
                return true, "`target` is not a slice"
        }</span>

        <span class="cov8" title="1">for x := 0; x &lt; v.Len(); x++ </span><span class="cov8" title="1">{
                obj := v.Index(x).Interface()
                if predicate(obj) </span><span class="cov8" title="1">{
                        return false, EMPTY
                }</span>
        }
        <span class="cov8" title="1">return true, "Predicate did not fire for any element in target"</span>
}

func shouldAnyOfInt(target []int, predicate PredicateOfInt) (bool, string) <span class="cov0" title="0">{
        v := reflect.ValueOf(target)

        for x := 0; x &lt; v.Len(); x++ </span><span class="cov0" title="0">{
                obj := v.Index(x).Interface().(int)
                if predicate(obj) </span><span class="cov0" title="0">{
                        return false, EMPTY
                }</span>
        }
        <span class="cov0" title="0">return true, "Predicate did not fire for any element in target"</span>
}

func shouldAnyOfFloat(target []float64, predicate PredicateOfFloat) (bool, string) <span class="cov0" title="0">{
        v := reflect.ValueOf(target)

        for x := 0; x &lt; v.Len(); x++ </span><span class="cov0" title="0">{
                obj := v.Index(x).Interface().(float64)
                if predicate(obj) </span><span class="cov0" title="0">{
                        return false, EMPTY
                }</span>
        }
        <span class="cov0" title="0">return true, "Predicate did not fire for any element in target"</span>
}

func shouldAnyOfString(target []string, predicate PredicateOfString) (bool, string) <span class="cov0" title="0">{
        v := reflect.ValueOf(target)

        for x := 0; x &lt; v.Len(); x++ </span><span class="cov0" title="0">{
                obj := v.Index(x).Interface().(string)
                if predicate(obj) </span><span class="cov0" title="0">{
                        return false, EMPTY
                }</span>
        }
        <span class="cov0" title="0">return true, "Predicate did not fire for any element in target"</span>
}

func shouldAll(target interface{}, predicate Predicate) (bool, string) <span class="cov8" title="1">{
        t := reflect.TypeOf(target)
        for t.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                t = t.Elem()
        }</span>

        <span class="cov8" title="1">v := reflect.ValueOf(target)
        for v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                v = v.Elem()
        }</span>

        <span class="cov8" title="1">if t.Kind() != reflect.Slice </span><span class="cov8" title="1">{
                return true, "`target` is not a slice"
        }</span>

        <span class="cov8" title="1">for x := 0; x &lt; v.Len(); x++ </span><span class="cov8" title="1">{
                obj := v.Index(x).Interface()
                if !predicate(obj) </span><span class="cov8" title="1">{
                        return true, fmt.Sprintf("Predicate failed for element in target: %#v", obj)
                }</span>
        }
        <span class="cov8" title="1">return false, EMPTY</span>
}

func shouldAllOfInt(target []int, predicate PredicateOfInt) (bool, string) <span class="cov0" title="0">{
        v := reflect.ValueOf(target)

        for x := 0; x &lt; v.Len(); x++ </span><span class="cov0" title="0">{
                obj := v.Index(x).Interface().(int)
                if !predicate(obj) </span><span class="cov0" title="0">{
                        return true, fmt.Sprintf("Predicate failed for element in target: %#v", obj)
                }</span>
        }
        <span class="cov0" title="0">return false, EMPTY</span>
}

func shouldAllOfFloat(target []float64, predicate PredicateOfFloat) (bool, string) <span class="cov0" title="0">{
        v := reflect.ValueOf(target)

        for x := 0; x &lt; v.Len(); x++ </span><span class="cov0" title="0">{
                obj := v.Index(x).Interface().(float64)
                if !predicate(obj) </span><span class="cov0" title="0">{
                        return true, fmt.Sprintf("Predicate failed for element in target: %#v", obj)
                }</span>
        }
        <span class="cov0" title="0">return false, EMPTY</span>
}

func shouldAllOfString(target []string, predicate PredicateOfString) (bool, string) <span class="cov0" title="0">{
        v := reflect.ValueOf(target)

        for x := 0; x &lt; v.Len(); x++ </span><span class="cov0" title="0">{
                obj := v.Index(x).Interface().(string)
                if !predicate(obj) </span><span class="cov0" title="0">{
                        return true, fmt.Sprintf("Predicate failed for element in target: %#v", obj)
                }</span>
        }
        <span class="cov0" title="0">return false, EMPTY</span>
}

func shouldNone(target interface{}, predicate Predicate) (bool, string) <span class="cov8" title="1">{
        t := reflect.TypeOf(target)
        for t.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                t = t.Elem()
        }</span>

        <span class="cov8" title="1">v := reflect.ValueOf(target)
        for v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                v = v.Elem()
        }</span>

        <span class="cov8" title="1">if t.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                return true, "`target` is not a slice"
        }</span>

        <span class="cov8" title="1">for x := 0; x &lt; v.Len(); x++ </span><span class="cov8" title="1">{
                obj := v.Index(x).Interface()
                if predicate(obj) </span><span class="cov8" title="1">{
                        return true, fmt.Sprintf("Predicate passed for element in target: %#v", obj)
                }</span>
        }
        <span class="cov8" title="1">return false, EMPTY</span>
}

func shouldNoneOfInt(target []int, predicate PredicateOfInt) (bool, string) <span class="cov0" title="0">{
        v := reflect.ValueOf(target)

        for x := 0; x &lt; v.Len(); x++ </span><span class="cov0" title="0">{
                obj := v.Index(x).Interface().(int)
                if predicate(obj) </span><span class="cov0" title="0">{
                        return true, fmt.Sprintf("Predicate passed for element in target: %#v", obj)
                }</span>
        }
        <span class="cov0" title="0">return false, EMPTY</span>
}

func shouldNoneOfFloat(target []float64, predicate PredicateOfFloat) (bool, string) <span class="cov0" title="0">{
        v := reflect.ValueOf(target)

        for x := 0; x &lt; v.Len(); x++ </span><span class="cov0" title="0">{
                obj := v.Index(x).Interface().(float64)
                if predicate(obj) </span><span class="cov0" title="0">{
                        return true, fmt.Sprintf("Predicate passed for element in target: %#v", obj)
                }</span>
        }
        <span class="cov0" title="0">return false, EMPTY</span>
}

func shouldNoneOfString(target []string, predicate PredicateOfString) (bool, string) <span class="cov0" title="0">{
        v := reflect.ValueOf(target)

        for x := 0; x &lt; v.Len(); x++ </span><span class="cov0" title="0">{
                obj := v.Index(x).Interface().(string)
                if predicate(obj) </span><span class="cov0" title="0">{
                        return true, fmt.Sprintf("Predicate passed for element in target: %#v", obj)
                }</span>
        }
        <span class="cov0" title="0">return false, EMPTY</span>
}

// --------------------------------------------------------------------------------
// UTILITY
// --------------------------------------------------------------------------------

func prefixOptional(message string) string <span class="cov8" title="1">{
        return "(Non-Fatal) " + message
}</span>

func shouldBeMultipleMessage(expected, actual interface{}, message string) string <span class="cov8" title="1">{
        expectedLabel := color("Expected", WHITE)
        actualLabel := color("Actual", WHITE)

        return fmt.Sprintf(`%s
        %s:         %#v
        %s:         %#v`, message, expectedLabel, expected, actualLabel, actual)
}</span>

func shouldBeMessage(object interface{}, message string) string <span class="cov8" title="1">{
        actualLabel := color("Actual", WHITE)
        return fmt.Sprintf(`%s
        %s:         %#v`, message, actualLabel, object)
}</span>

func notEqualMessage(actual, expected interface{}) string <span class="cov0" title="0">{
        return shouldBeMultipleMessage(expected, actual, "Objects should not be equal")
}</span>

func equalMessage(actual, expected interface{}) string <span class="cov8" title="1">{
        return shouldBeMultipleMessage(expected, actual, "Objects should be equal")
}</span>

func getLength(object interface{}) int <span class="cov8" title="1">{
        if object == nil </span><span class="cov0" title="0">{
                return 0
        }</span> else<span class="cov8" title="1"> if object == "" </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">objValue := reflect.ValueOf(object)

        switch objValue.Kind() </span>{
        case reflect.Map:<span class="cov8" title="1">
                fallthrough</span>
        case reflect.Slice, reflect.Chan, reflect.String:<span class="cov8" title="1">
                </span><span class="cov8" title="1">{
                        return objValue.Len()
                }</span>
        }
        <span class="cov0" title="0">return 0</span>
}

func isNil(object interface{}) bool <span class="cov8" title="1">{
        if object == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">value := reflect.ValueOf(object)
        kind := value.Kind()
        if kind &gt;= reflect.Chan &amp;&amp; kind &lt;= reflect.Slice &amp;&amp; value.IsNil() </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

func isZero(value interface{}) bool <span class="cov8" title="1">{
        return areEqual(0, value)
}</span>

func areEqual(expected, actual interface{}) bool <span class="cov8" title="1">{
        if expected == nil &amp;&amp; actual == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">if (expected == nil &amp;&amp; actual != nil) || (expected != nil &amp;&amp; actual == nil) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">actualType := reflect.TypeOf(actual)
        if actualType == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">expectedValue := reflect.ValueOf(expected)
        if expectedValue.IsValid() &amp;&amp; expectedValue.Type().ConvertibleTo(actualType) </span><span class="cov8" title="1">{
                return reflect.DeepEqual(expectedValue.Convert(actualType).Interface(), actual)
        }</span>

        <span class="cov0" title="0">return reflect.DeepEqual(expected, actual)</span>
}

func callerInfo() []string <span class="cov8" title="1">{
        pc := uintptr(0)
        file := ""
        line := 0
        ok := false
        name := ""

        callers := []string{}
        for i := 0; ; i++ </span><span class="cov8" title="1">{
                pc, file, line, ok = runtime.Caller(i)
                if !ok </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">if file == "&lt;autogenerated&gt;" </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">parts := strings.Split(file, "/")
                dir := parts[len(parts)-2]
                file = parts[len(parts)-1]
                if dir != "assert" &amp;&amp; dir != "go-assert" &amp;&amp; dir != "mock" &amp;&amp; dir != "require" </span><span class="cov0" title="0">{
                        callers = append(callers, fmt.Sprintf("%s:%d", file, line))
                }</span>

                <span class="cov8" title="1">f := runtime.FuncForPC(pc)
                if f == nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">name = f.Name()

                // Drop the package
                segments := strings.Split(name, ".")
                name = segments[len(segments)-1]
                if isTest(name, "Test") ||
                        isTest(name, "Benchmark") ||
                        isTest(name, "Example") </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">return callers</span>
}

func color(input string, colorCode string) string <span class="cov8" title="1">{
        return fmt.Sprintf("\033[%s;01m%s\033[0m", colorCode, input)
}</span>

func reflectTypeName(object interface{}) string <span class="cov0" title="0">{
        return reflect.TypeOf(object).Name()
}</span>

func isTest(name, prefix string) bool <span class="cov8" title="1">{
        if !strings.HasPrefix(name, prefix) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if len(name) == len(prefix) </span><span class="cov0" title="0">{ // "Test" is ok
                return true
        }</span>
        <span class="cov8" title="1">rune, _ := utf8.DecodeRuneInString(name[len(prefix):])
        return !unicode.IsLower(rune)</span>
}

func getClearString() string <span class="cov8" title="1">{
        _, file, line, ok := runtime.Caller(1)
        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">parts := strings.Split(file, "/")
        file = parts[len(parts)-1]

        return strings.Repeat(" ", len(fmt.Sprintf("%s:%d:      ", file, line))+2)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package collections

import (
        "sync"
        "time"
)

// NewAutoflushBuffer creates a new autoflush buffer.
func NewAutoflushBuffer(maxLen int, interval time.Duration) *AutoflushBuffer <span class="cov8" title="1">{
        return &amp;AutoflushBuffer{
                maxLen:       maxLen,
                interval:     interval,
                flushOnAbort: true,
                contents:     NewRingBufferWithCapacity(maxLen),
                ticker:       time.Tick(interval),
                abort:        make(chan bool),
                aborted:      make(chan bool),
        }
}</span>

// AutoflushBuffer is a backing store that operates either on a fixed length flush or a fixed interval flush.
// A handler should be provided but without one the buffer will just clear.
// Adds that would cause fixed length flushes do not block on the flush handler.
type AutoflushBuffer struct {
        maxLen   int
        interval time.Duration

        contents     *RingBuffer
        contentsLock sync.Mutex

        ticker &lt;-chan time.Time

        flushOnAbort bool
        handler      func(obj []Any)

        runningLock sync.Mutex
        running     bool
        abort       chan bool
        aborted     chan bool
}

// WithFlushOnAbort sets if we should flush on aborts or not.
// This defaults to true.
func (ab *AutoflushBuffer) WithFlushOnAbort(should bool) *AutoflushBuffer <span class="cov0" title="0">{
        ab.flushOnAbort = should
        return ab
}</span>

// ShouldFlushOnAbort returns if the buffer will do one final flush on abort.
func (ab *AutoflushBuffer) ShouldFlushOnAbort() bool <span class="cov0" title="0">{
        return ab.flushOnAbort
}</span>

// Interval returns the flush interval.
func (ab *AutoflushBuffer) Interval() time.Duration <span class="cov0" title="0">{
        return ab.interval
}</span>

// MaxLen returns the maximum buffer length before a flush is triggered.
func (ab *AutoflushBuffer) MaxLen() int <span class="cov0" title="0">{
        return ab.maxLen
}</span>

// WithFlushHandler sets the buffer flush handler and returns a reference to the buffer.
func (ab *AutoflushBuffer) WithFlushHandler(handler func(objs []Any)) *AutoflushBuffer <span class="cov8" title="1">{
        ab.handler = handler
        return ab
}</span>

// Start starts the buffer flusher.
func (ab *AutoflushBuffer) Start() <span class="cov8" title="1">{
        ab.runningLock.Lock()
        defer ab.runningLock.Unlock()

        if ab.running </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">go ab.runLoop()</span>
}

// Stop stops the buffer flusher.
func (ab *AutoflushBuffer) Stop() <span class="cov8" title="1">{
        ab.runningLock.Lock()
        defer ab.runningLock.Unlock()

        if !ab.running </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">ab.abort &lt;- true
        &lt;-ab.aborted</span>
}

// Add adds a new object to the buffer, blocking if it triggers a flush.
// If the buffer is full, it will call the flush handler on a separate goroutine.
func (ab *AutoflushBuffer) Add(obj Any) <span class="cov8" title="1">{
        ab.contentsLock.Lock()
        defer ab.contentsLock.Unlock()

        ab.contents.Enqueue(obj)
        if ab.contents.Len() &gt;= ab.maxLen </span><span class="cov8" title="1">{
                ab.flushUnsafeAsync()
        }</span>
}

// AddMany adds many objects to the buffer at once.
func (ab *AutoflushBuffer) AddMany(objs ...Any) <span class="cov0" title="0">{
        ab.contentsLock.Lock()
        defer ab.contentsLock.Unlock()

        for _, obj := range objs </span><span class="cov0" title="0">{
                ab.contents.Enqueue(obj)
                if ab.contents.Len() &gt;= ab.maxLen </span><span class="cov0" title="0">{
                        ab.flushUnsafeAsync()
                }</span>
        }
}

// Flush clears the buffer, if a handler is provided it is passed the contents of the buffer.
// This call is synchronous, in that it will call the flush handler on the same goroutine.
func (ab *AutoflushBuffer) Flush() <span class="cov8" title="1">{
        ab.contentsLock.Lock()
        defer ab.contentsLock.Unlock()
        ab.flushUnsafe()
}</span>

// FlushAsync clears the buffer, if a handler is provided it is passed the contents of the buffer.
// This call is asynchronous, in that it will call the flush handler on its own goroutine.
func (ab *AutoflushBuffer) FlushAsync() <span class="cov8" title="1">{
        ab.contentsLock.Lock()
        defer ab.contentsLock.Unlock()
        ab.flushUnsafeAsync()
}</span>

// flushUnsafeAsync flushes the buffer without acquiring any locks.
func (ab *AutoflushBuffer) flushUnsafeAsync() <span class="cov8" title="1">{
        if ab.handler != nil </span><span class="cov8" title="1">{
                if ab.contents.Len() &gt; 0 </span><span class="cov8" title="1">{
                        contents := ab.contents.Drain()
                        go ab.handler(contents)
                }</span>
        } else<span class="cov0" title="0"> {
                ab.contents.Clear()
        }</span>
}

// flushUnsafeAsync flushes the buffer without acquiring any locks.
func (ab *AutoflushBuffer) flushUnsafe() <span class="cov8" title="1">{
        if ab.handler != nil </span><span class="cov8" title="1">{
                if ab.contents.Len() &gt; 0 </span><span class="cov0" title="0">{
                        ab.handler(ab.contents.Drain())
                }</span>
        } else<span class="cov0" title="0"> {
                ab.contents.Clear()
        }</span>
}

func (ab *AutoflushBuffer) runLoop() <span class="cov8" title="1">{
        ab.runningLock.Lock()
        ab.running = true
        ab.runningLock.Unlock()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ab.ticker:<span class="cov8" title="1">
                        ab.FlushAsync()</span>
                case &lt;-ab.abort:<span class="cov8" title="1">
                        if ab.flushOnAbort </span><span class="cov8" title="1">{
                                ab.Flush()
                        }</span>
                        <span class="cov8" title="1">ab.aborted &lt;- true
                        return</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package collections

import "sync"

// NewChannelQueueWithCapacity returns a new ConcurrentQueue instance.
func NewChannelQueueWithCapacity(capacity int) *ChannelQueue <span class="cov8" title="1">{
        return &amp;ChannelQueue{Capacity: capacity, storage: make(chan interface{}, capacity), latch: sync.Mutex{}}
}</span>

// ChannelQueue is a threadsafe queue.
type ChannelQueue struct {
        Capacity int
        storage  chan interface{}
        latch    sync.Mutex
}

// Len returns the number of items in the queue.
func (cq *ChannelQueue) Len() int <span class="cov8" title="1">{
        return len(cq.storage)
}</span>

// Enqueue adds an item to the queue.
func (cq *ChannelQueue) Enqueue(item interface{}) <span class="cov8" title="1">{
        cq.storage &lt;- item
}</span>

// Dequeue returns the next element in the queue.
func (cq *ChannelQueue) Dequeue() interface{} <span class="cov8" title="1">{
        if len(cq.storage) != 0 </span><span class="cov8" title="1">{
                return &lt;-cq.storage
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Peek returns (but does not remove) the first element of the queue.
func (cq *ChannelQueue) Peek() interface{} <span class="cov0" title="0">{
        if len(cq.storage) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return cq.Contents()[0]</span>
}

// PeekBack returns (but does not remove) the last element of the queue.
func (cq *ChannelQueue) PeekBack() interface{} <span class="cov0" title="0">{
        if len(cq.storage) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return cq.Contents()[len(cq.storage)-1]</span>
}

// Clear clears the queue.
func (cq *ChannelQueue) Clear() <span class="cov0" title="0">{
        cq.storage = make(chan interface{}, cq.Capacity)
}</span>

// Each pulls every value out of the channel, calls consumer on it, and puts it back.
func (cq *ChannelQueue) Each(consumer func(value interface{})) <span class="cov0" title="0">{
        if len(cq.storage) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">values := []interface{}{}
        for len(cq.storage) != 0 </span><span class="cov0" title="0">{
                v := &lt;-cq.storage
                consumer(v)
                values = append(values, v)
        }</span>
        <span class="cov0" title="0">for _, v := range values </span><span class="cov0" title="0">{
                cq.storage &lt;- v
        }</span>
}

// Consume pulls every value out of the channel, calls consumer on it, effectively clearing the queue.
func (cq *ChannelQueue) Consume(consumer func(value interface{})) <span class="cov0" title="0">{
        if len(cq.storage) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">for len(cq.storage) != 0 </span><span class="cov0" title="0">{
                v := &lt;-cq.storage
                consumer(v)
        }</span>
}

// EachUntil pulls every value out of the channel, calls consumer on it, and puts it back and can abort mid process.
func (cq *ChannelQueue) EachUntil(consumer func(value interface{}) bool) <span class="cov0" title="0">{
        contents := cq.Contents()
        for x := 0; x &lt; len(contents); x++ </span><span class="cov0" title="0">{
                if consumer(contents[x]) </span><span class="cov0" title="0">{
                        return
                }</span>
        }
}

// ReverseEachUntil pulls every value out of the channel, calls consumer on it, and puts it back and can abort mid process.
func (cq *ChannelQueue) ReverseEachUntil(consumer func(value interface{}) bool) <span class="cov0" title="0">{
        contents := cq.Contents()
        for x := len(contents) - 1; x &gt;= 0; x-- </span><span class="cov0" title="0">{
                if consumer(contents[x]) </span><span class="cov0" title="0">{
                        return
                }</span>
        }
}

// Contents iterates over the queue and returns an array of its contents.
func (cq *ChannelQueue) Contents() []interface{} <span class="cov8" title="1">{
        values := []interface{}{}
        for len(cq.storage) != 0 </span><span class="cov8" title="1">{
                v := &lt;-cq.storage
                values = append(values, v)
        }</span>
        <span class="cov8" title="1">for _, v := range values </span><span class="cov8" title="1">{
                cq.storage &lt;- v
        }</span>
        <span class="cov8" title="1">return values</span>
}

// Drain iterates over the queue and returns an array of its contents, leaving it empty.
func (cq *ChannelQueue) Drain() []interface{} <span class="cov0" title="0">{
        values := []interface{}{}
        for len(cq.storage) != 0 </span><span class="cov0" title="0">{
                v := &lt;-cq.storage
                values = append(values, v)
        }</span>
        <span class="cov0" title="0">return values</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package collections

type listNode struct {
        Next     *listNode
        Previous *listNode
        Value    interface{}
}

// NewLinkedList returns a new Queue instance.
func NewLinkedList() *LinkedList <span class="cov8" title="1">{
        return &amp;LinkedList{}
}</span>

// LinkedList is an implementation of a fifo buffer using nodes and poitners.
// Remarks; it is not threadsafe. It is constant(ish) time in all ops.
type LinkedList struct {
        head   *listNode
        tail   *listNode
        length int
}

// Len returns the length of the queue in constant time.
func (q *LinkedList) Len() int <span class="cov8" title="1">{
        return q.length
}</span>

// Enqueue adds a new value to the queue.
func (q *LinkedList) Enqueue(value interface{}) <span class="cov8" title="1">{
        node := &amp;listNode{Value: value}

        if q.head == nil </span><span class="cov8" title="1">{ //the queue is empty, that is to say head is nil
                q.head = node
                q.tail = node
        }</span> else<span class="cov8" title="1"> { //the queue is not empty, we have a (valid) tail pointer
                q.tail.Previous = node
                node.Next = q.tail
                q.tail = node
        }</span>

        <span class="cov8" title="1">q.length = q.length + 1</span>
}

// Dequeue removes an item from the front of the queue and returns it.
func (q *LinkedList) Dequeue() interface{} <span class="cov8" title="1">{
        if q.head == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">headValue := q.head.Value

        if q.length == 1 &amp;&amp; q.head == q.tail </span><span class="cov8" title="1">{
                q.head = nil
                q.tail = nil
        }</span> else<span class="cov8" title="1"> {
                q.head = q.head.Previous
                if q.head != nil </span><span class="cov8" title="1">{
                        q.head.Next = nil
                }</span>
        }

        <span class="cov8" title="1">q.length = q.length - 1
        return headValue</span>
}

// Peek returns the first element of the queue but does not remove it.
func (q *LinkedList) Peek() interface{} <span class="cov8" title="1">{
        if q.head == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return q.head.Value</span>
}

// PeekBack returns the last element of the queue.
func (q *LinkedList) PeekBack() interface{} <span class="cov8" title="1">{
        if q.tail == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return q.tail.Value</span>
}

// Clear clears the linked list.
func (q *LinkedList) Clear() <span class="cov0" title="0">{
        q.tail = nil
        q.head = nil
        q.length = 0
}</span>

// Drain calls the consumer for each element of the linked list.
func (q *LinkedList) Drain() []interface{} <span class="cov0" title="0">{
        if q.head == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">contents := make([]interface{}, q.length)
        nodePtr := q.head
        var index int
        for nodePtr != nil </span><span class="cov0" title="0">{
                contents[index] = nodePtr.Value
                nodePtr = nodePtr.Previous
                index++
        }</span>
        <span class="cov0" title="0">q.tail = nil
        q.head = nil
        q.length = 0
        return contents</span>
}

// Each calls the consumer for each element of the linked list.
func (q *LinkedList) Each(consumer func(value interface{})) <span class="cov0" title="0">{
        if q.head == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">nodePtr := q.head
        for nodePtr != nil </span><span class="cov0" title="0">{
                consumer(nodePtr.Value)
                nodePtr = nodePtr.Previous
        }</span>
}

// Consume calls the consumer for each element of the linked list, removing it.
func (q *LinkedList) Consume(consumer func(value interface{})) <span class="cov0" title="0">{
        if q.head == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">nodePtr := q.head
        for nodePtr != nil </span><span class="cov0" title="0">{
                consumer(nodePtr.Value)
                nodePtr = nodePtr.Previous
        }</span>
        <span class="cov0" title="0">q.tail = nil
        q.head = nil
        q.length = 0</span>
}

// EachUntil calls the consumer for each element of the linked list, but can abort.
func (q *LinkedList) EachUntil(consumer func(value interface{}) bool) <span class="cov0" title="0">{
        if q.head == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">nodePtr := q.head
        for nodePtr != nil </span><span class="cov0" title="0">{
                if !consumer(nodePtr.Value) </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">nodePtr = nodePtr.Previous</span>
        }
}

// ReverseEachUntil calls the consumer for each element of the linked list, but can abort.
func (q *LinkedList) ReverseEachUntil(consumer func(value interface{}) bool) <span class="cov0" title="0">{
        if q.head == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">nodePtr := q.tail
        for nodePtr != nil </span><span class="cov0" title="0">{
                if !consumer(nodePtr.Value) </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">nodePtr = nodePtr.Next</span>
        }
}

// Contents returns the full contents of the queue as a slice.
func (q *LinkedList) Contents() []interface{} <span class="cov8" title="1">{
        if q.head == nil </span><span class="cov8" title="1">{
                return []interface{}{}
        }</span>

        <span class="cov8" title="1">values := []interface{}{}
        nodePtr := q.head
        for nodePtr != nil </span><span class="cov8" title="1">{
                values = append(values, nodePtr.Value)
                nodePtr = nodePtr.Previous
        }</span>
        <span class="cov8" title="1">return values</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package collections

import (
        "time"
)

// NewRateLimiter returns a new RateLimiter instance.
func NewRateLimiter(numberOfActions int, quantum time.Duration) *RateLimiter <span class="cov8" title="1">{
        return &amp;RateLimiter{
                NumberOfActions: numberOfActions,
                Quantum:         quantum,
                Limits:          map[string]Queue{},
        }
}</span>

// RateLimiter is a simple implementation of a rate checker.
type RateLimiter struct {
        NumberOfActions int
        Quantum         time.Duration
        Limits          map[string]Queue
}

// Check returns true if it has been called NumberOfActions times or more in Quantum or smaller duration.
func (rl *RateLimiter) Check(id string) bool <span class="cov8" title="1">{
        queue, hasQueue := rl.Limits[id]
        if !hasQueue </span><span class="cov8" title="1">{
                queue = NewRingBufferWithCapacity(rl.NumberOfActions)
                rl.Limits[id] = queue
        }</span>

        <span class="cov8" title="1">currentTime := time.Now().UTC()
        queue.Enqueue(currentTime)
        if queue.Len() &lt; rl.NumberOfActions </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">oldest := queue.Dequeue().(time.Time)
        return currentTime.Sub(oldest) &lt; rl.Quantum</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package collections

import (
        "fmt"
        "strings"
)

const (
        ringBufferMinimumGrow     = 4
        ringBufferShrinkThreshold = 32
        ringBufferGrowFactor      = 200
        ringBufferDefaultCapacity = 4
)

var (
        emptyArray = make([]interface{}, 0)
)

// NewRingBuffer creates a new, empty, RingBuffer.
func NewRingBuffer() *RingBuffer <span class="cov8" title="1">{
        return &amp;RingBuffer{
                array: make([]interface{}, ringBufferDefaultCapacity),
                head:  0,
                tail:  0,
                size:  0,
        }
}</span>

// NewRingBufferWithCapacity creates a new ringbuffer with a given capacity.
func NewRingBufferWithCapacity(capacity int) *RingBuffer <span class="cov8" title="1">{
        return &amp;RingBuffer{
                array: make([]interface{}, capacity),
                head:  0,
                tail:  0,
                size:  0,
        }
}</span>

// NewRingBufferFromValues creates a  ring buffer out of a slice.
func NewRingBufferFromValues(values []interface{}) *RingBuffer <span class="cov0" title="0">{
        return &amp;RingBuffer{
                array: values,
                head:  0,
                tail:  len(values) - 1,
                size:  len(values),
        }
}</span>

// RingBuffer is a fifo buffer that is backed by a pre-allocated array, instead of allocating
// a whole new node object for each element (which saves GC churn).
// Enqueue can be O(n), Dequeue can be O(1).
type RingBuffer struct {
        array []interface{}
        head  int
        tail  int
        size  int
}

// Len returns the length of the ring buffer (as it is currently populated).
// Actual memory footprint may be different.
func (rb *RingBuffer) Len() (len int) <span class="cov8" title="1">{
        return rb.size
}</span>

// Capacity returns the total size of the ring bufffer, including empty elements.
func (rb *RingBuffer) Capacity() int <span class="cov0" title="0">{
        return len(rb.array)
}</span>

// Clear removes all objects from the RingBuffer.
func (rb *RingBuffer) Clear() <span class="cov8" title="1">{
        if rb.head &lt; rb.tail </span><span class="cov0" title="0">{
                arrayClear(rb.array, rb.head, rb.size)
        }</span> else<span class="cov8" title="1"> {
                arrayClear(rb.array, rb.head, len(rb.array)-rb.head)
                arrayClear(rb.array, 0, rb.tail)
        }</span>

        <span class="cov8" title="1">rb.head = 0
        rb.tail = 0
        rb.size = 0</span>
}

// Enqueue adds an element to the "back" of the RingBuffer.
func (rb *RingBuffer) Enqueue(object interface{}) <span class="cov8" title="1">{
        if rb.size == len(rb.array) </span><span class="cov8" title="1">{
                newCapacity := int(len(rb.array) * int(ringBufferGrowFactor/100))
                if newCapacity &lt; (len(rb.array) + ringBufferMinimumGrow) </span><span class="cov0" title="0">{
                        newCapacity = len(rb.array) + ringBufferMinimumGrow
                }</span>
                <span class="cov8" title="1">rb.setCapacity(newCapacity)</span>
        }

        <span class="cov8" title="1">rb.array[rb.tail] = object
        rb.tail = (rb.tail + 1) % len(rb.array)
        rb.size++</span>
}

// Dequeue removes the first (oldest) element from the RingBuffer.
func (rb *RingBuffer) Dequeue() interface{} <span class="cov8" title="1">{
        if rb.size == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">removed := rb.array[rb.head]
        rb.head = (rb.head + 1) % len(rb.array)
        rb.size--

        return removed</span>
}

// Peek returns but does not remove the first element.
func (rb *RingBuffer) Peek() interface{} <span class="cov8" title="1">{
        if rb.size == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return rb.array[rb.head]</span>
}

// PeekBack returns but does not remove the last element.
func (rb *RingBuffer) PeekBack() interface{} <span class="cov8" title="1">{
        if rb.size == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if rb.tail == 0 </span><span class="cov8" title="1">{
                return rb.array[len(rb.array)-1]
        }</span>
        <span class="cov8" title="1">return rb.array[rb.tail-1]</span>
}

func (rb *RingBuffer) setCapacity(capacity int) <span class="cov8" title="1">{
        newArray := make([]interface{}, capacity)
        if rb.size &gt; 0 </span><span class="cov8" title="1">{
                if rb.head &lt; rb.tail </span><span class="cov0" title="0">{
                        arrayCopy(rb.array, rb.head, newArray, 0, rb.size)
                }</span> else<span class="cov8" title="1"> {
                        arrayCopy(rb.array, rb.head, newArray, 0, len(rb.array)-rb.head)
                        arrayCopy(rb.array, 0, newArray, len(rb.array)-rb.head, rb.tail)
                }</span>
        }
        <span class="cov8" title="1">rb.array = newArray
        rb.head = 0
        if rb.size == capacity </span><span class="cov0" title="0">{
                rb.tail = 0
        }</span> else<span class="cov8" title="1"> {
                rb.tail = rb.size
        }</span>
}

// trimExcess resizes the buffer to better fit the contents.
func (rb *RingBuffer) trimExcess() <span class="cov0" title="0">{
        threshold := float64(len(rb.array)) * 0.9
        if rb.size &lt; int(threshold) </span><span class="cov0" title="0">{
                rb.setCapacity(rb.size)
        }</span>
}

// Contents returns the ring buffer, in order, as a slice.
func (rb *RingBuffer) Contents() []interface{} <span class="cov8" title="1">{
        newArray := make([]interface{}, rb.size)

        if rb.size == 0 </span><span class="cov0" title="0">{
                return newArray
        }</span>

        <span class="cov8" title="1">if rb.head &lt; rb.tail </span><span class="cov8" title="1">{
                arrayCopy(rb.array, rb.head, newArray, 0, rb.size)
                arrayClear(rb.array, rb.head, rb.size)
        }</span> else<span class="cov0" title="0"> {
                arrayCopy(rb.array, rb.head, newArray, 0, len(rb.array)-rb.head)
                arrayClear(rb.array, rb.head, len(rb.array)-rb.head)
                arrayCopy(rb.array, 0, newArray, len(rb.array)-rb.head, rb.tail)
                arrayClear(rb.array, 0, rb.tail)
        }</span>

        <span class="cov8" title="1">return newArray</span>
}

// Drain clears the buffer and removes the contents.
func (rb *RingBuffer) Drain() []interface{} <span class="cov8" title="1">{
        newArray := make([]interface{}, rb.size)

        if rb.size == 0 </span><span class="cov0" title="0">{
                return newArray
        }</span>

        <span class="cov8" title="1">if rb.head &lt; rb.tail </span><span class="cov8" title="1">{
                arrayCopy(rb.array, rb.head, newArray, 0, rb.size)
        }</span> else<span class="cov8" title="1"> {
                arrayCopy(rb.array, rb.head, newArray, 0, len(rb.array)-rb.head)
                arrayCopy(rb.array, 0, newArray, len(rb.array)-rb.head, rb.tail)
        }</span>

        <span class="cov8" title="1">rb.head = 0
        rb.tail = 0
        rb.size = 0

        return newArray</span>
}

// Each calls the consumer for each element in the buffer.
func (rb *RingBuffer) Each(consumer func(value interface{})) <span class="cov8" title="1">{
        if rb.size == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if rb.head &lt; rb.tail </span><span class="cov0" title="0">{
                for cursor := rb.head; cursor &lt; rb.tail; cursor++ </span><span class="cov0" title="0">{
                        consumer(rb.array[cursor])
                }</span>
        } else<span class="cov8" title="1"> {
                for cursor := rb.head; cursor &lt; len(rb.array); cursor++ </span><span class="cov8" title="1">{
                        consumer(rb.array[cursor])
                }</span>
                <span class="cov8" title="1">for cursor := 0; cursor &lt; rb.tail; cursor++ </span><span class="cov0" title="0">{
                        consumer(rb.array[cursor])
                }</span>
        }
}

// Consume calls the consumer for each element in the buffer, while also dequeueing that entry.
func (rb *RingBuffer) Consume(consumer func(value interface{})) <span class="cov8" title="1">{
        if rb.size == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">len := rb.Len()
        for i := 0; i &lt; len; i++ </span><span class="cov8" title="1">{
                consumer(rb.Dequeue())
        }</span>
}

// EachUntil calls the consumer for each element in the buffer with a stopping condition in head=&gt;tail order.
func (rb *RingBuffer) EachUntil(consumer func(value interface{}) bool) <span class="cov8" title="1">{
        if rb.size == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if rb.head &lt; rb.tail </span><span class="cov0" title="0">{
                for cursor := rb.head; cursor &lt; rb.tail; cursor++ </span><span class="cov0" title="0">{
                        if !consumer(rb.array[cursor]) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                for cursor := rb.head; cursor &lt; len(rb.array); cursor++ </span><span class="cov8" title="1">{
                        if !consumer(rb.array[cursor]) </span><span class="cov8" title="1">{
                                return
                        }</span>
                }
                <span class="cov0" title="0">for cursor := 0; cursor &lt; rb.tail; cursor++ </span><span class="cov0" title="0">{
                        if !consumer(rb.array[cursor]) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
}

// ReverseEachUntil calls the consumer for each element in the buffer with a stopping condition in tail=&gt;head order.
func (rb *RingBuffer) ReverseEachUntil(consumer func(value interface{}) bool) <span class="cov8" title="1">{
        if rb.size == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if rb.head &lt; rb.tail </span><span class="cov8" title="1">{
                for cursor := rb.tail - 1; cursor &gt;= rb.head; cursor-- </span><span class="cov8" title="1">{
                        if !consumer(rb.array[cursor]) </span><span class="cov8" title="1">{
                                return
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                for cursor := rb.tail; cursor &gt; 0; cursor-- </span><span class="cov0" title="0">{
                        if !consumer(rb.array[cursor]) </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
                <span class="cov8" title="1">for cursor := len(rb.array) - 1; cursor &gt;= rb.head; cursor-- </span><span class="cov8" title="1">{
                        if !consumer(rb.array[cursor]) </span><span class="cov8" title="1">{
                                return
                        }</span>
                }

        }
}

func (rb *RingBuffer) String() string <span class="cov0" title="0">{
        var values []string
        for _, elem := range rb.Contents() </span><span class="cov0" title="0">{
                values = append(values, fmt.Sprintf("%v", elem))
        }</span>
        <span class="cov0" title="0">return strings.Join(values, " &lt;= ")</span>
}

func arrayClear(source []interface{}, index, length int) <span class="cov8" title="1">{
        for x := 0; x &lt; length; x++ </span><span class="cov8" title="1">{
                absoluteIndex := x + index
                source[absoluteIndex] = nil
        }</span>
}

func arrayCopy(source []interface{}, sourceIndex int, destination []interface{}, destinationIndex, length int) <span class="cov8" title="1">{
        for x := 0; x &lt; length; x++ </span><span class="cov8" title="1">{
                from := sourceIndex + x
                to := destinationIndex + x

                destination[to] = source[from]
        }</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package collections

import (
        "strconv"
        "strings"
)

// NewSetOfInt creates a new SetOfInt.
func NewSetOfInt(values ...int) SetOfInt <span class="cov8" title="1">{
        set := SetOfInt{}
        for _, v := range values </span><span class="cov8" title="1">{
                set.Add(v)
        }</span>
        <span class="cov8" title="1">return set</span>
}

// SetOfInt is a type alias for map[int]int
type SetOfInt map[int]bool

// Add adds an element to the set, replaceing a previous value.
func (si SetOfInt) Add(i int) <span class="cov8" title="1">{
        si[i] = true
}</span>

// Remove removes an element from the set.
func (si SetOfInt) Remove(i int) <span class="cov8" title="1">{
        delete(si, i)
}</span>

// Contains returns if the element is in the set.
func (si SetOfInt) Contains(i int) bool <span class="cov8" title="1">{
        _, ok := si[i]
        return ok
}</span>

// Len returns the number of elements in the set.
func (si SetOfInt) Len() int <span class="cov8" title="1">{
        return len(si)
}</span>

// Copy returns a new copy of the set.
func (si SetOfInt) Copy() SetOfInt <span class="cov0" title="0">{
        newSet := NewSetOfInt()
        for key := range si </span><span class="cov0" title="0">{
                newSet.Add(key)
        }</span>
        <span class="cov0" title="0">return newSet</span>
}

// Union joins two sets together without dupes.
func (si SetOfInt) Union(other SetOfInt) SetOfInt <span class="cov8" title="1">{
        union := NewSetOfInt()
        for k := range si </span><span class="cov8" title="1">{
                union.Add(k)
        }</span>

        <span class="cov8" title="1">for k := range other </span><span class="cov8" title="1">{
                union.Add(k)
        }</span>
        <span class="cov8" title="1">return union</span>
}

// Intersect returns shared elements between two sets.
func (si SetOfInt) Intersect(other SetOfInt) SetOfInt <span class="cov8" title="1">{
        intersection := NewSetOfInt()
        for k := range si </span><span class="cov8" title="1">{
                if other.Contains(k) </span><span class="cov8" title="1">{
                        intersection.Add(k)
                }</span>
        }
        <span class="cov8" title="1">return intersection</span>
}

// Difference returns non-shared elements between two sets.
func (si SetOfInt) Difference(other SetOfInt) SetOfInt <span class="cov8" title="1">{
        difference := NewSetOfInt()
        for k := range si </span><span class="cov8" title="1">{
                if !other.Contains(k) </span><span class="cov8" title="1">{
                        difference.Add(k)
                }</span>
        }
        <span class="cov8" title="1">for k := range other </span><span class="cov8" title="1">{
                if !si.Contains(k) </span><span class="cov8" title="1">{
                        difference.Add(k)
                }</span>
        }
        <span class="cov8" title="1">return difference</span>
}

// IsSubsetOf returns if a given set is a complete subset of another set,
// i.e. all elements in target set are in other set.
func (si SetOfInt) IsSubsetOf(other SetOfInt) bool <span class="cov8" title="1">{
        for k := range si </span><span class="cov8" title="1">{
                if !other.Contains(k) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// AsSlice returns the set as a slice.
func (si SetOfInt) AsSlice() []int <span class="cov0" title="0">{
        output := []int{}
        for key := range si </span><span class="cov0" title="0">{
                output = append(output, key)
        }</span>
        <span class="cov0" title="0">return output</span>
}

// String returns the set as a csv string.
func (si SetOfInt) String() string <span class="cov0" title="0">{
        var values []string
        for _, i := range si.AsSlice() </span><span class="cov0" title="0">{
                values = append(values, strconv.Itoa(i))
        }</span>

        <span class="cov0" title="0">return strings.Join(values, ", ")</span>
}

// NewSetOfString creates a new SetOfString.
func NewSetOfString(values ...string) SetOfString <span class="cov8" title="1">{
        set := SetOfString{}
        for _, v := range values </span><span class="cov8" title="1">{
                set.Add(v)
        }</span>
        <span class="cov8" title="1">return set</span>
}

// SetOfString is a set of strings
type SetOfString map[string]bool

// Add adds an element.
func (ss SetOfString) Add(entry string) <span class="cov8" title="1">{
        if _, hasEntry := ss[entry]; !hasEntry </span><span class="cov8" title="1">{
                ss[entry] = true
        }</span>
}

// Remove deletes an element, returns if the element was in the set.
func (ss SetOfString) Remove(entry string) bool <span class="cov8" title="1">{
        if _, hasEntry := ss[entry]; hasEntry </span><span class="cov8" title="1">{
                delete(ss, entry)
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

// Contains returns if an element is in the set.
func (ss SetOfString) Contains(entry string) bool <span class="cov8" title="1">{
        _, hasEntry := ss[entry]
        return hasEntry
}</span>

// Len returns the length of the set.
func (ss SetOfString) Len() int <span class="cov8" title="1">{
        return len(ss)
}</span>

// Copy returns a new copy of the set.
func (ss SetOfString) Copy() SetOfString <span class="cov0" title="0">{
        newSet := SetOfString{}
        for key := range ss </span><span class="cov0" title="0">{
                newSet.Add(key)
        }</span>
        <span class="cov0" title="0">return newSet</span>
}

// Union joins two sets together without dupes.
func (ss SetOfString) Union(other SetOfString) SetOfString <span class="cov8" title="1">{
        union := NewSetOfString()
        for k := range ss </span><span class="cov8" title="1">{
                union.Add(k)
        }</span>

        <span class="cov8" title="1">for k := range other </span><span class="cov8" title="1">{
                union.Add(k)
        }</span>
        <span class="cov8" title="1">return union</span>
}

// Intersect returns shared elements between two sets.
func (ss SetOfString) Intersect(other SetOfString) SetOfString <span class="cov8" title="1">{
        intersection := NewSetOfString()
        for k := range ss </span><span class="cov8" title="1">{
                if other.Contains(k) </span><span class="cov8" title="1">{
                        intersection.Add(k)
                }</span>
        }
        <span class="cov8" title="1">return intersection</span>
}

// Difference returns non-shared elements between two sets.
func (ss SetOfString) Difference(other SetOfString) SetOfString <span class="cov8" title="1">{
        difference := NewSetOfString()
        for k := range ss </span><span class="cov8" title="1">{
                if !other.Contains(k) </span><span class="cov8" title="1">{
                        difference.Add(k)
                }</span>
        }
        <span class="cov8" title="1">for k := range other </span><span class="cov8" title="1">{
                if !ss.Contains(k) </span><span class="cov8" title="1">{
                        difference.Add(k)
                }</span>
        }
        <span class="cov8" title="1">return difference</span>
}

// IsSubsetOf returns if a given set is a complete subset of another set,
// i.e. all elements in target set are in other set.
func (ss SetOfString) IsSubsetOf(other SetOfString) bool <span class="cov8" title="1">{
        for k := range ss </span><span class="cov8" title="1">{
                if !other.Contains(k) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// AsSlice returns the set as a slice.
func (ss SetOfString) AsSlice() []string <span class="cov0" title="0">{
        output := []string{}
        for key := range ss </span><span class="cov0" title="0">{
                output = append(output, key)
        }</span>
        <span class="cov0" title="0">return output</span>
}

// String returns the set as a csv string.
func (ss SetOfString) String() string <span class="cov0" title="0">{
        return strings.Join(ss.AsSlice(), ", ")
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package collections

import (
        "strings"

        "github.com/blend/go-sdk/util"
)

// StringArray is a type alias for []string with some helper methods.
type StringArray []string

// Contains returns if the given string is in the array.
func (sa StringArray) Contains(elem string) bool <span class="cov8" title="1">{
        for _, arrayElem := range sa </span><span class="cov8" title="1">{
                if arrayElem == elem </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// ContainsLower returns true if the `elem` is in the StringArray, false otherwise.
func (sa StringArray) ContainsLower(elem string) bool <span class="cov8" title="1">{
        for _, arrayElem := range sa </span><span class="cov8" title="1">{
                if strings.ToLower(arrayElem) == elem </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// GetByLower returns an element from the array that matches the input.
func (sa StringArray) GetByLower(elem string) string <span class="cov8" title="1">{
        for _, arrayElem := range sa </span><span class="cov8" title="1">{
                if strings.ToLower(arrayElem) == elem </span><span class="cov8" title="1">{
                        return arrayElem
                }</span>
        }
        <span class="cov8" title="1">return util.StringEmpty</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package collections

import (
        "sync"
)

// NewSyncRingBuffer returns a new synchronized ring buffer.
func NewSyncRingBuffer() *SyncRingBuffer <span class="cov8" title="1">{
        return &amp;SyncRingBuffer{
                innerBuffer: NewRingBuffer(),
                syncRoot:    &amp;sync.Mutex{},
        }
}</span>

// NewSyncRingBufferWithCapacity returns a new synchronized ring buffer.
func NewSyncRingBufferWithCapacity(capacity int) *SyncRingBuffer <span class="cov0" title="0">{
        return &amp;SyncRingBuffer{
                innerBuffer: NewRingBufferWithCapacity(capacity),
                syncRoot:    &amp;sync.Mutex{},
        }
}</span>

// SyncRingBuffer is a ring buffer wrapper that adds synchronization.
type SyncRingBuffer struct {
        innerBuffer *RingBuffer
        syncRoot    *sync.Mutex
}

// SyncRoot returns the mutex used to synchronize the collection.
func (srb *SyncRingBuffer) SyncRoot() *sync.Mutex <span class="cov0" title="0">{
        return srb.syncRoot
}</span>

// RingBuffer returns the inner ringbuffer.
func (srb *SyncRingBuffer) RingBuffer() *RingBuffer <span class="cov0" title="0">{
        return srb.innerBuffer
}</span>

// Len returns the length of the ring buffer (as it is currently populated).
// Actual memory footprint may be different.
func (srb SyncRingBuffer) Len() (val int) <span class="cov8" title="1">{
        srb.syncRoot.Lock()
        val = srb.innerBuffer.Len()
        srb.syncRoot.Unlock()
        return
}</span>

// Capacity returns the total size of the ring bufffer, including empty elements.
func (srb *SyncRingBuffer) Capacity() (val int) <span class="cov0" title="0">{
        srb.syncRoot.Lock()
        val = srb.innerBuffer.Capacity()
        srb.syncRoot.Unlock()
        return
}</span>

// Enqueue adds an element to the "back" of the RingBuffer.
func (srb *SyncRingBuffer) Enqueue(value interface{}) <span class="cov8" title="1">{
        srb.syncRoot.Lock()
        srb.innerBuffer.Enqueue(value)
        srb.syncRoot.Unlock()
}</span>

// Dequeue removes the first (oldest) element from the RingBuffer.
func (srb *SyncRingBuffer) Dequeue() (val interface{}) <span class="cov8" title="1">{
        srb.syncRoot.Lock()
        val = srb.innerBuffer.Dequeue()
        srb.syncRoot.Unlock()
        return
}</span>

// Peek returns but does not remove the first element.
func (srb *SyncRingBuffer) Peek() (val interface{}) <span class="cov8" title="1">{
        srb.syncRoot.Lock()
        val = srb.innerBuffer.Peek()
        srb.syncRoot.Unlock()
        return
}</span>

// PeekBack returns but does not remove the last element.
func (srb *SyncRingBuffer) PeekBack() (val interface{}) <span class="cov8" title="1">{
        srb.syncRoot.Lock()
        val = srb.innerBuffer.PeekBack()
        srb.syncRoot.Unlock()
        return
}</span>

// TrimExcess resizes the buffer to better fit the contents.
func (srb *SyncRingBuffer) TrimExcess() <span class="cov0" title="0">{
        srb.syncRoot.Lock()
        srb.innerBuffer.trimExcess()
        srb.syncRoot.Unlock()
}</span>

// Contents returns the ring buffer, in order, as a slice.
func (srb *SyncRingBuffer) Contents() (val []interface{}) <span class="cov8" title="1">{
        srb.syncRoot.Lock()
        val = srb.innerBuffer.Contents()
        srb.syncRoot.Unlock()
        return
}</span>

// Clear removes all objects from the RingBuffer.
func (srb *SyncRingBuffer) Clear() <span class="cov8" title="1">{
        srb.syncRoot.Lock()
        srb.innerBuffer.Clear()
        srb.syncRoot.Unlock()
}</span>

// Drain returns the ring buffer, in order, as a slice and empties it.
func (srb *SyncRingBuffer) Drain() (val []interface{}) <span class="cov0" title="0">{
        srb.syncRoot.Lock()
        val = srb.innerBuffer.Drain()
        srb.syncRoot.Unlock()
        return
}</span>

// Each calls the consumer for each element in the buffer.
func (srb *SyncRingBuffer) Each(consumer func(value interface{})) <span class="cov8" title="1">{
        srb.syncRoot.Lock()
        srb.innerBuffer.Each(consumer)
        srb.syncRoot.Unlock()
}</span>

// Consume calls the consumer for each element in the buffer, while also dequeueing that entry.
func (srb *SyncRingBuffer) Consume(consumer func(value interface{})) <span class="cov8" title="1">{
        srb.syncRoot.Lock()
        srb.innerBuffer.Consume(consumer)
        srb.syncRoot.Unlock()
}</span>

// EachUntil calls the consumer for each element in the buffer with a stopping condition in head=&gt;tail order.
func (srb *SyncRingBuffer) EachUntil(consumer func(value interface{}) bool) <span class="cov0" title="0">{
        srb.syncRoot.Lock()
        srb.innerBuffer.EachUntil(consumer)
        srb.syncRoot.Unlock()
}</span>

// ReverseEachUntil calls the consumer for each element in the buffer with a stopping condition in tail=&gt;head order.
func (srb *SyncRingBuffer) ReverseEachUntil(consumer func(value interface{}) bool) <span class="cov0" title="0">{
        srb.syncRoot.Lock()
        srb.innerBuffer.ReverseEachUntil(consumer)
        srb.syncRoot.Unlock()
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package collections

// Error is an error string.
type Error string

// Error implements error.
func (e Error) Error() string <span class="cov0" title="0">{ return string(e) }</span>

// Labels is a loose type alias to map[string]string
type Labels = map[string]string

// Vars is a loose type alias to map[string]string
type Vars = map[string]interface{}

// Any is a loose type alias to interface{}.
type Any = interface{}
</pre>
		
		<pre class="file" id="file10" style="display: none">package configutil

import (
        "encoding/json"
        "io"
        "io/ioutil"
        "os"
        "path/filepath"
        "strings"

        "github.com/blend/go-sdk/env"
        "github.com/blend/go-sdk/exception"
        "github.com/blend/go-sdk/yaml"
)

const (
        // EnvVarConfigPath is the env var for configs.
        EnvVarConfigPath = "CONFIG_PATH"

        // ExtensionJSON is a file extension.
        ExtensionJSON = ".json"
        // ExtensionYAML is a file extension.
        ExtensionYAML = ".yaml"
        // ExtensionYML is a file extension.
        ExtensionYML = ".yml"

        // ErrPathUnset is a common error.
        ErrPathUnset Error = "config path unset"
)

// Path returns the config path.
func Path(defaults ...string) string <span class="cov0" title="0">{
        if env.Env().Has(EnvVarConfigPath) </span><span class="cov0" title="0">{
                return env.Env().String(EnvVarConfigPath)
        }</span>
        <span class="cov0" title="0">if len(defaults) &gt; 0 </span><span class="cov0" title="0">{
                return defaults[0]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Deserialize deserializes a config.
func Deserialize(ext string, r io.Reader, ref Any) error <span class="cov8" title="1">{
        switch strings.ToLower(ext) </span>{
        case ExtensionJSON:<span class="cov0" title="0">
                return exception.Wrap(json.NewDecoder(r).Decode(ref))</span>
        case ExtensionYAML, ExtensionYML:<span class="cov8" title="1">
                contents, err := ioutil.ReadAll(r)
                if err != nil </span><span class="cov0" title="0">{
                        return exception.Wrap(err)
                }</span>
                <span class="cov8" title="1">return exception.Wrap(yaml.Unmarshal(contents, ref))</span>
        default:<span class="cov0" title="0">
                return exception.Wrap(json.NewDecoder(r).Decode(ref))</span>
        }
}

// Read reads a config from a default path (or inferred path from the environment).
func Read(ref Any, defaultPath ...string) error <span class="cov0" title="0">{
        return ReadFromPath(ref, Path(defaultPath...))
}</span>

// ReadFromPath reads a config from a given path.
func ReadFromPath(ref Any, path string) error <span class="cov8" title="1">{
        defer env.Env().ReadInto(ref)

        if len(path) == 0 </span><span class="cov8" title="1">{
                return exception.Wrap(ErrPathUnset)
        }</span>

        <span class="cov0" title="0">f, err := os.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return exception.Wrap(err)
        }</span>
        <span class="cov0" title="0">defer f.Close()

        return Deserialize(filepath.Ext(path), f, ref)</span>
}

// ReadFromReader reads a config from a given reader.
func ReadFromReader(ref Any, r io.Reader, ext string) error <span class="cov8" title="1">{
        defer env.Env().ReadInto(ref)
        return Deserialize(ext, r, ref)
}</span>

// IsNotExist returns if an error is an os.ErrNotExist.
func IsNotExist(err error) bool <span class="cov0" title="0">{
        if typed, isTyped := err.(exception.Exception); isTyped </span><span class="cov0" title="0">{
                err = typed.Inner()
        }</span>
        <span class="cov0" title="0">return os.IsNotExist(err)</span>
}

// IsPathUnset returns if an error is ErrPathUnset.
func IsPathUnset(err error) bool <span class="cov8" title="1">{
        if typed, isTyped := err.(exception.Exception); isTyped </span><span class="cov8" title="1">{
                err = typed.Inner()
        }</span>
        <span class="cov8" title="1">return err == ErrPathUnset</span>
}

// IsIgnored returns if we should ignore the config read error.
func IsIgnored(err error) bool <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return !IsNotExist(err) &amp;&amp; !IsPathUnset(err)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package configutil

// Error is an error string.
type Error string

// Error implements error.
func (e Error) Error() string <span class="cov8" title="1">{ return string(e) }</span>

// Labels is a loose type alias to map[string]string
type Labels = map[string]string

// Vars is a loose type alias to map[string]string
type Vars = map[string]interface{}

// Any is a loose type alias to interface{}.
type Any = interface{}
</pre>
		
		<pre class="file" id="file12" style="display: none">package cron

import (
        "sync/atomic"
)

// AtomicFlag is a boolean value that is syncronized.
type AtomicFlag struct {
        value int32
}

// Set the flag value.
func (af *AtomicFlag) Set(value bool) <span class="cov8" title="1">{
        if value </span><span class="cov8" title="1">{
                atomic.StoreInt32(&amp;af.value, 1)
        }</span> else<span class="cov0" title="0"> {
                atomic.StoreInt32(&amp;af.value, 0)
        }</span>
}

// Get the flag value.
func (af *AtomicFlag) Get() (value bool) <span class="cov8" title="1">{
        value = atomic.LoadInt32(&amp;af.value) == 1
        return
}</span>

// AtomicCounter is a counter to help with atomic operations.
type AtomicCounter struct {
        value int32
}

// Increment the value.
func (ac *AtomicCounter) Increment() <span class="cov8" title="1">{
        atomic.AddInt32(&amp;ac.value, 1)
}</span>

// Decrement the value.
func (ac *AtomicCounter) Decrement() <span class="cov0" title="0">{
        atomic.AddInt32(&amp;ac.value, -1)
}</span>

// Get returns the counter value.
func (ac *AtomicCounter) Get() (value int32) <span class="cov8" title="1">{
        value = atomic.LoadInt32(&amp;ac.value)
        return
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package cron

import (
        "bytes"
        "fmt"
        "time"

        logger "github.com/blend/go-sdk/logger"
)

const (
        // FlagStarted is a logger flag for task start.
        FlagStarted logger.Flag = "chronometer.task"
        // FlagComplete is a logger flag for task completions.
        FlagComplete logger.Flag = "chronometer.task.complete"
)

// NewEventStartedListener returns a new event started listener.
func NewEventStartedListener(listener func(e EventStarted)) logger.Listener <span class="cov0" title="0">{
        return func(e logger.Event) </span><span class="cov0" title="0">{
                if typed, isTyped := e.(EventStarted); isTyped </span><span class="cov0" title="0">{
                        listener(typed)
                }</span>
        }
}

// EventStarted is a started event.
type EventStarted struct {
        ts         time.Time
        isEnabled  bool
        isWritable bool
        taskName   string
}

// Flag returns the event flag.
func (e EventStarted) Flag() logger.Flag <span class="cov8" title="1">{
        return FlagStarted
}</span>

// Timestamp returns an event timestamp.
func (e EventStarted) Timestamp() time.Time <span class="cov0" title="0">{
        return e.ts
}</span>

// IsEnabled determines if the event triggers listeners.
func (e EventStarted) IsEnabled() bool <span class="cov8" title="1">{
        return e.isEnabled
}</span>

// IsWritable determines if the event is written to the logger output.
func (e EventStarted) IsWritable() bool <span class="cov0" title="0">{
        return e.isWritable
}</span>

// TaskName returns the event task name.
func (e EventStarted) TaskName() string <span class="cov0" title="0">{
        return e.taskName
}</span>

// WriteText implements logger.TextWritable.
func (e EventStarted) WriteText(tf logger.TextFormatter, buf *bytes.Buffer) <span class="cov0" title="0">{
        buf.WriteString(fmt.Sprintf("`%s` starting", e.taskName))
}</span>

// WriteJSON implements logger.JSONWritable.
func (e EventStarted) WriteJSON() logger.JSONObj <span class="cov0" title="0">{
        return logger.JSONObj{
                "taskName": e.taskName,
        }
}</span>

// NewEventCompleteListener returns a new event complete listener.
func NewEventCompleteListener(listener func(e EventComplete)) logger.Listener <span class="cov0" title="0">{
        return func(e logger.Event) </span><span class="cov0" title="0">{
                if typed, isTyped := e.(EventComplete); isTyped </span><span class="cov0" title="0">{
                        listener(typed)
                }</span>
        }
}

// EventComplete is an event emitted to the logger.
type EventComplete struct {
        ts         time.Time
        isEnabled  bool
        isWritable bool
        taskName   string
        err        error
        elapsed    time.Duration
}

// Flag returns the event flag.
func (e EventComplete) Flag() logger.Flag <span class="cov8" title="1">{
        return FlagComplete
}</span>

// Timestamp returns an event timestamp.
func (e EventComplete) Timestamp() time.Time <span class="cov0" title="0">{
        return e.ts
}</span>

// IsEnabled determines if the event triggers listeners.
func (e EventComplete) IsEnabled() bool <span class="cov8" title="1">{
        return e.isEnabled
}</span>

// IsWritable determines if the event is written to the logger output.
func (e EventComplete) IsWritable() bool <span class="cov8" title="1">{
        return e.isWritable
}</span>

// TaskName returns the event task name.
func (e EventComplete) TaskName() string <span class="cov8" title="1">{
        return e.taskName
}</span>

// Elapsed returns the elapsed time for the task.
func (e EventComplete) Elapsed() time.Duration <span class="cov8" title="1">{
        return e.elapsed
}</span>

// Err returns the event err (if any).
func (e EventComplete) Err() error <span class="cov8" title="1">{
        return e.err
}</span>

// WriteText implements logger.TextWritable.
func (e EventComplete) WriteText(tf logger.TextFormatter, buf *bytes.Buffer) <span class="cov8" title="1">{
        if e.err != nil </span><span class="cov8" title="1">{
                buf.WriteString(fmt.Sprintf("`%s` failed (%v)", e.taskName, e.elapsed))
        }</span> else<span class="cov0" title="0"> {
                buf.WriteString(fmt.Sprintf("`%s` completed (%v)", e.taskName, e.elapsed))
        }</span>
}

// WriteJSON implements logger.JSONWritable.
func (e EventComplete) WriteJSON() logger.JSONObj <span class="cov0" title="0">{
        return logger.JSONObj{
                "taskName":              e.taskName,
                logger.JSONFieldElapsed: logger.Milliseconds(e.elapsed),
                logger.JSONFieldErr:     e.err,
        }
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package cron

import (
        "context"
        "time"
)

// Job is an interface structs can satisfy to be loaded into the JobManager.
type Job interface {
        Name() string
        Schedule() Schedule
        Execute(ctx context.Context) error
}

// IsJobCancelled check if a job is cancelled
func IsJobCancelled(ctx context.Context) bool <span class="cov0" title="0">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// EventTriggerListenersProvider is a type that enables or disables logger listeners.
type EventTriggerListenersProvider interface {
        ShouldTriggerListeners() bool
}

// EventShouldWriteOutputProvider is a type that enables or disables logger output for events.
type EventShouldWriteOutputProvider interface {
        ShouldWriteOutput() bool
}

// EnabledProvider is an optional interface that will allow jobs to control if they're enabled.
type EnabledProvider interface {
        Enabled() bool
}

// NewJob returns a new job factory.
func NewJob() *JobFactory <span class="cov8" title="1">{
        return &amp;JobFactory{
                schedule: OnDemand(),
        }
}</span>

// JobFactory allows for job creation w/o a fully formed struct.
type JobFactory struct {
        name                 string
        schedule             Schedule
        timeout              time.Duration
        action               TaskAction
        enabledProvider      func() bool
        showMessagesProvider func() bool
}

// Name returns the job name.
func (jf *JobFactory) Name() string <span class="cov8" title="1">{
        return jf.name
}</span>

// WithName sets the job name.
func (jf *JobFactory) WithName(name string) *JobFactory <span class="cov8" title="1">{
        jf.name = name
        return jf
}</span>

// Schedule returns the job schedule.
func (jf *JobFactory) Schedule() Schedule <span class="cov8" title="1">{
        return jf.schedule
}</span>

// WithSchedule sets the schedule for the job.
func (jf *JobFactory) WithSchedule(schedule Schedule) *JobFactory <span class="cov0" title="0">{
        jf.schedule = schedule
        return jf
}</span>

// Timeout returns the job timeout.
func (jf *JobFactory) Timeout() time.Duration <span class="cov0" title="0">{
        return jf.timeout
}</span>

// WithTimeout sets the timeout.
func (jf *JobFactory) WithTimeout(timeout time.Duration) *JobFactory <span class="cov0" title="0">{
        jf.timeout = timeout
        return jf
}</span>

// Execute runs the job action if it's set.
func (jf *JobFactory) Execute(ctx context.Context) error <span class="cov8" title="1">{
        if jf.action != nil </span><span class="cov8" title="1">{
                return jf.action(ctx)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// WithAction sets the job action.
func (jf *JobFactory) WithAction(action TaskAction) *JobFactory <span class="cov8" title="1">{
        jf.action = action
        return jf
}</span>

// Enabled returns if the job is enabled.
func (jf *JobFactory) Enabled() bool <span class="cov8" title="1">{
        if jf.enabledProvider != nil </span><span class="cov0" title="0">{
                return jf.enabledProvider()
        }</span>
        <span class="cov8" title="1">return true</span>
}

// WithEnabledProvider sets the enabled provider for the job.
func (jf *JobFactory) WithEnabledProvider(provider func() bool) *JobFactory <span class="cov0" title="0">{
        jf.enabledProvider = provider
        return jf
}</span>

// ShowMessages returns if the job should trigger logging events.
func (jf *JobFactory) ShowMessages() bool <span class="cov0" title="0">{
        if jf.showMessagesProvider != nil </span><span class="cov0" title="0">{
                return jf.showMessagesProvider()
        }</span>
        <span class="cov0" title="0">return true</span>
}

// WithShowMessagesProvider sets the enabled provider for the job.
func (jf *JobFactory) WithShowMessagesProvider(provider func() bool) *JobFactory <span class="cov0" title="0">{
        jf.showMessagesProvider = provider
        return jf
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package cron

// NOTE: ALL TIMES ARE IN UTC. JUST USE UTC.

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/blend/go-sdk/collections"
        "github.com/blend/go-sdk/exception"
        "github.com/blend/go-sdk/logger"
)

// State is a job state.
type State string

const (
        // DefaultHeartbeatInterval is the interval between schedule next run checks.
        DefaultHeartbeatInterval = 50 * time.Millisecond

        // HighPrecisionHeartbeatInterval is the high precision interval between schedule next run checks.
        HighPrecisionHeartbeatInterval = 5 * time.Millisecond

        //StateRunning is the running state.
        StateRunning State = "running"

        // StateEnabled is the enabled state.
        StateEnabled State = "enabled"

        // StateDisabled is the disabled state.
        StateDisabled State = "disabled"
)

// New returns a new job manager.
func New() *JobManager <span class="cov8" title="1">{
        jm := JobManager{
                heartbeatInterval:     DefaultHeartbeatInterval,
                loadedJobs:            map[string]Job{},
                runningTasks:          map[string]Task{},
                schedules:             map[string]Schedule{},
                contexts:              map[string]context.Context{},
                cancels:               map[string]context.CancelFunc{},
                runningTaskStartTimes: map[string]time.Time{},
                lastRunTimes:          map[string]time.Time{},
                nextRunTimes:          map[string]*time.Time{},
                disabledJobs:          collections.SetOfString{},
                enabledProviders:      map[string]func() bool{},
        }

        return &amp;jm
}</span>

var _default *JobManager
var _defaultLock = &amp;sync.Mutex{}

// Default returns a shared instance of a JobManager.
func Default() *JobManager <span class="cov0" title="0">{
        if _default == nil </span><span class="cov0" title="0">{
                _defaultLock.Lock()
                defer _defaultLock.Unlock()

                if _default == nil </span><span class="cov0" title="0">{
                        _default = New()
                }</span>
        }
        <span class="cov0" title="0">return _default</span>
}

// JobManager is the main orchestration and job management object.
type JobManager struct {
        heartbeatInterval time.Duration

        loadedJobsLock sync.Mutex
        loadedJobs     map[string]Job

        disabledJobsLock sync.Mutex
        disabledJobs     collections.SetOfString

        enabledProvidersLock sync.Mutex
        enabledProviders     map[string]func() bool

        runningTasksLock sync.Mutex
        runningTasks     map[string]Task

        schedulesLock sync.Mutex
        schedules     map[string]Schedule

        runningTaskStartTimesLock sync.Mutex
        runningTaskStartTimes     map[string]time.Time

        contextsLock sync.Mutex
        contexts     map[string]context.Context

        cancelsLock sync.Mutex
        cancels     map[string]context.CancelFunc

        lastRunTimesLock sync.Mutex
        lastRunTimes     map[string]time.Time

        nextRunTimesLock sync.Mutex
        nextRunTimes     map[string]*time.Time

        schedulerCancel context.CancelFunc
        isRunning       bool

        log *logger.Logger
}

// Logger returns the diagnostics agent.
func (jm *JobManager) Logger() *logger.Logger <span class="cov8" title="1">{
        return jm.log
}</span>

// SetLogger sets the diagnostics agent.
func (jm *JobManager) SetLogger(log *logger.Logger) <span class="cov8" title="1">{
        jm.log = log
}</span>

// HeartbeatInterval returns the current heartbeat interval.
func (jm *JobManager) HeartbeatInterval() time.Duration <span class="cov8" title="1">{
        return jm.heartbeatInterval
}</span>

// WithHighPrecisionHeartbeat sets the heartbeat interval to the high precision interval and returns a reference.
func (jm *JobManager) WithHighPrecisionHeartbeat() *JobManager <span class="cov8" title="1">{
        jm.heartbeatInterval = HighPrecisionHeartbeatInterval
        return jm
}</span>

// WithDefaultPrecisionHeartbeat sets the heartbeat interval to the high precision interval and returns a reference.
func (jm *JobManager) WithDefaultPrecisionHeartbeat() *JobManager <span class="cov0" title="0">{
        jm.heartbeatInterval = DefaultHeartbeatInterval
        return jm
}</span>

// SetHeartbeatInterval sets the heartbeat interval explicitly.
func (jm *JobManager) SetHeartbeatInterval(interval time.Duration) <span class="cov0" title="0">{
        jm.heartbeatInterval = interval
}</span>

// ShouldTriggerListeners is a helper function to determine if we should trigger listeners for a given task.
func (jm *JobManager) ShouldTriggerListeners(taskName string) bool <span class="cov8" title="1">{
        jm.loadedJobsLock.Lock()
        defer jm.loadedJobsLock.Unlock()

        if job, hasJob := jm.loadedJobs[taskName]; hasJob </span><span class="cov8" title="1">{
                if typed, isTyped := job.(EventTriggerListenersProvider); isTyped </span><span class="cov0" title="0">{
                        return typed.ShouldTriggerListeners()
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// ShouldWriteOutput is a helper function to determine if we should write logging output for a task.
func (jm *JobManager) ShouldWriteOutput(taskName string) bool <span class="cov8" title="1">{
        jm.loadedJobsLock.Lock()
        defer jm.loadedJobsLock.Unlock()

        if job, hasJob := jm.loadedJobs[taskName]; hasJob </span><span class="cov8" title="1">{
                if typed, isTyped := job.(EventShouldWriteOutputProvider); isTyped </span><span class="cov0" title="0">{
                        return typed.ShouldWriteOutput()
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// fireTaskListeners fires the currently configured task listeners.
func (jm *JobManager) fireTaskListeners(taskName string) <span class="cov8" title="1">{
        if jm.log == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">jm.log.Trigger(EventStarted{
                ts:         time.Now().UTC(),
                isEnabled:  jm.ShouldTriggerListeners(taskName),
                isWritable: jm.ShouldWriteOutput(taskName),
                taskName:   taskName,
        })</span>
}

// fireTaskListeners fires the currently configured task listeners.
func (jm *JobManager) fireTaskCompleteListeners(taskName string, elapsed time.Duration, err error) <span class="cov8" title="1">{
        if jm.log == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">jm.log.Trigger(EventComplete{
                ts:         time.Now().UTC(),
                taskName:   taskName,
                isEnabled:  jm.ShouldTriggerListeners(taskName),
                isWritable: jm.ShouldWriteOutput(taskName),
                elapsed:    elapsed,
                err:        err,
        })
        if err != nil </span><span class="cov8" title="1">{
                jm.log.Error(err)
        }</span>
}

// shouldRunJob returns whether it is legal to run a job based off of a job's attributes and status.
// Use this function to set logic for whether a job should run
func (jm *JobManager) shouldRunJob(job Job) bool <span class="cov8" title="1">{
        return !jm.IsDisabled(job.Name())
}</span>

// ----------------------------------------------------------------------------
// Informational Methods
// ----------------------------------------------------------------------------

// HasJob returns if a jobName is loaded or not.
func (jm *JobManager) HasJob(jobName string) bool <span class="cov8" title="1">{
        jm.loadedJobsLock.Lock()
        _, hasJob := jm.loadedJobs[jobName]
        jm.loadedJobsLock.Unlock()
        return hasJob
}</span>

// Job returns a job instance by name.
func (jm *JobManager) Job(jobName string) (job Job) <span class="cov0" title="0">{
        jm.loadedJobsLock.Lock()
        job = jm.loadedJobs[jobName]
        jm.loadedJobsLock.Unlock()
        return
}</span>

// IsDisabled returns if a job is disabled.
func (jm *JobManager) IsDisabled(jobName string) (value bool) <span class="cov8" title="1">{
        jm.disabledJobsLock.Lock()
        value = jm.disabledJobs.Contains(jobName)
        jm.disabledJobsLock.Unlock()

        jm.enabledProvidersLock.Lock()
        if provider, hasProvider := jm.enabledProviders[jobName]; hasProvider </span><span class="cov8" title="1">{
                value = value || !provider()
        }</span>
        <span class="cov8" title="1">jm.enabledProvidersLock.Unlock()
        return</span>
}

// IsRunning returns if a task is currently running.
func (jm *JobManager) IsRunning(taskName string) bool <span class="cov8" title="1">{
        jm.runningTasksLock.Lock()
        _, isRunning := jm.runningTasks[taskName]
        jm.runningTasksLock.Unlock()
        return isRunning
}</span>

// ReadAllJobs allows the consumer to do something with the full job list, using a read lock.
func (jm *JobManager) ReadAllJobs(action func(jobs map[string]Job)) <span class="cov0" title="0">{
        jm.loadedJobsLock.Lock()
        defer jm.loadedJobsLock.Unlock()
        action(jm.loadedJobs)
}</span>

// --------------------------------------------------------------------------------
// Core Methods
// --------------------------------------------------------------------------------

// LoadJob adds a job to the manager.
func (jm *JobManager) LoadJob(j Job) error <span class="cov8" title="1">{
        jobName := j.Name()

        if jm.HasJob(jobName) </span><span class="cov0" title="0">{
                return exception.Newf("Job name `%s` already loaded.", j.Name())
        }</span>

        <span class="cov8" title="1">jm.setLoadedJob(jobName, j)
        jobSchedule := j.Schedule()
        jm.setSchedule(jobName, jobSchedule)
        jm.setNextRunTime(jobName, jobSchedule.GetNextRunTime(nil))
        jm.setEnabledProvider(jobName, j)
        return nil</span>
}

// DisableJob stops a job from running but does not unload it.
func (jm *JobManager) DisableJob(jobName string) error <span class="cov8" title="1">{
        if !jm.HasJob(jobName) </span><span class="cov0" title="0">{
                return exception.Newf("Job name `%s` isn't loaded.", jobName)
        }</span>

        <span class="cov8" title="1">jm.setDisabledJob(jobName)
        jm.deleteNextRunTime(jobName)
        return nil</span>
}

// EnableJob enables a job that has been disabled.
func (jm *JobManager) EnableJob(jobName string) error <span class="cov8" title="1">{
        if !jm.HasJob(jobName) </span><span class="cov0" title="0">{
                return exception.Newf("Job name `%s` isn't loaded.", jobName)
        }</span>

        <span class="cov8" title="1">jm.deleteDisabledJob(jobName)
        job := jm.getLoadedJob(jobName)
        jobSchedule := job.Schedule()
        jm.setNextRunTime(jobName, jobSchedule.GetNextRunTime(nil))

        return nil</span>
}

// RunJob runs a job by jobName on demand.
func (jm *JobManager) RunJob(jobName string) error <span class="cov8" title="1">{
        jm.loadedJobsLock.Lock()
        defer jm.loadedJobsLock.Unlock()

        if job, hasJob := jm.loadedJobs[jobName]; hasJob </span><span class="cov8" title="1">{
                if jm.shouldRunJob(job) </span><span class="cov8" title="1">{
                        now := time.Now().UTC()
                        jm.setLastRunTime(jobName, now)
                        err := jm.RunTask(job)
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">return exception.Newf("Job name `%s` not found.", jobName)</span>
}

// RunAllJobs runs every job that has been loaded in the JobManager at once.
func (jm *JobManager) RunAllJobs() error <span class="cov0" title="0">{
        jm.loadedJobsLock.Lock()
        defer jm.loadedJobsLock.Unlock()

        for jobName, job := range jm.loadedJobs </span><span class="cov0" title="0">{
                if !jm.IsDisabled(jobName) </span><span class="cov0" title="0">{
                        jobErr := jm.RunTask(job)
                        if jobErr != nil </span><span class="cov0" title="0">{
                                return jobErr
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (jm *JobManager) createContext() (context.Context, context.CancelFunc) <span class="cov8" title="1">{
        return context.WithCancel(context.Background())
}</span>

// shouldRunTask returns whether a task should be executed based on its status
func (jm *JobManager) shouldRunTask(t Task) bool <span class="cov8" title="1">{
        _, serial := t.(SerialProvider)
        if serial </span><span class="cov8" title="1">{
                return !jm.IsRunning(t.Name())
        }</span>
        <span class="cov8" title="1">return true</span>
}

// RunTask runs a task on demand.
func (jm *JobManager) RunTask(t Task) error <span class="cov8" title="1">{
        if !jm.shouldRunTask(t) </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">taskName := t.Name()
        start := Now()
        ctx, cancel := jm.createContext()

        jm.setRunningTask(taskName, t)
        jm.setContext(ctx, taskName)
        jm.setCancelFunc(taskName, cancel)
        jm.setRunningTaskStartTime(taskName, start)
        jm.setLastRunTime(taskName, start)

        // this is the main goroutine that runs the task
        go func() </span><span class="cov8" title="1">{
                var err error

                defer func() </span><span class="cov8" title="1">{
                        jm.cleanupTask(taskName)
                        jm.fireTaskCompleteListeners(taskName, Since(start), err)
                }</span>()

                // panic recovery
                <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                        if r := recover(); r != nil </span><span class="cov8" title="1">{
                                err = exception.Newf("%v", r)
                        }</span>
                }()

                <span class="cov8" title="1">jm.onTaskStart(t)
                jm.fireTaskListeners(taskName)
                err = t.Execute(ctx)
                jm.onTaskComplete(t, err)</span>
        }()

        <span class="cov8" title="1">return nil</span>
}

func (jm *JobManager) onTaskStart(t Task) <span class="cov8" title="1">{
        if receiver, isReceiver := t.(OnStartReceiver); isReceiver </span><span class="cov8" title="1">{
                receiver.OnStart()
        }</span>
}

func (jm *JobManager) onTaskComplete(t Task, result error) <span class="cov8" title="1">{
        if receiver, isReceiver := t.(OnCompleteReceiver); isReceiver </span><span class="cov8" title="1">{
                receiver.OnComplete(result)
        }</span>
}

func (jm *JobManager) onTaskCancellation(t Task) <span class="cov8" title="1">{
        if receiver, isReceiver := t.(OnCancellationReceiver); isReceiver </span><span class="cov8" title="1">{
                receiver.OnCancellation()
        }</span>
}

func (jm *JobManager) cleanupTask(taskName string) <span class="cov8" title="1">{
        jm.deleteRunningTaskStartTime(taskName)
        jm.deleteRunningTask(taskName)
        jm.deleteContext(taskName)
        jm.deleteCancelFunc(taskName)
}</span>

// CancelTask cancels (sends the cancellation signal) to a running task.
func (jm *JobManager) CancelTask(taskName string) error <span class="cov8" title="1">{
        jm.runningTasksLock.Lock()
        defer jm.runningTasksLock.Unlock()

        if task, hasTask := jm.runningTasks[taskName]; hasTask </span><span class="cov8" title="1">{
                cancel := jm.getCancelFunc(taskName)
                jm.onTaskCancellation(task)
                cancel()
        }</span>
        <span class="cov8" title="1">return exception.Newf("Task name `%s` not found.", taskName)</span>
}

// Start begins the schedule runner for a JobManager.
func (jm *JobManager) Start() <span class="cov8" title="1">{
        ctx, cancel := jm.createContext()
        jm.schedulerCancel = cancel

        go jm.runDueJobs(ctx)
        go jm.killHangingJobs(ctx)

        jm.isRunning = true
}</span>

// Stop stops the schedule runner for a JobManager.
func (jm *JobManager) Stop() <span class="cov8" title="1">{
        if !jm.isRunning </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">jm.schedulerCancel()
        jm.isRunning = false</span>
}

// --------------------------------------------------------------------------------
// Utility Methods
// --------------------------------------------------------------------------------

func (jm *JobManager) runDueJobs(ctx context.Context) <span class="cov8" title="1">{
        heartbeat := time.Tick(jm.heartbeatInterval)
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-heartbeat:<span class="cov8" title="1">
                        jm.runDueJobsInner()</span>
                }
        }
}

func (jm *JobManager) runDueJobsInner() <span class="cov8" title="1">{
        now := Now()
        var err error
        for jobName, job := range jm.loadedJobs </span><span class="cov8" title="1">{
                nextRunTime := jm.getNextRunTime(jobName)
                if nextRunTime != nil </span><span class="cov8" title="1">{
                        if jm.shouldRunJob(job) </span><span class="cov8" title="1">{
                                if nextRunTime.Before(now) </span><span class="cov8" title="1">{
                                        jm.setNextRunTime(jobName, jm.getSchedule(jobName).GetNextRunTime(&amp;now))
                                        jm.setLastRunTime(jobName, now)
                                        err = jm.RunTask(job)
                                        if err != nil </span><span class="cov0" title="0">{
                                                jm.log.Error(err)
                                        }</span>
                                }
                        }
                }
        }
}

func (jm *JobManager) killHangingJobs(ctx context.Context) <span class="cov8" title="1">{
        heartbeat := time.Tick(jm.heartbeatInterval)
        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return</span>
                case &lt;-heartbeat:<span class="cov8" title="1">
                        jm.killHangingJobsInner()</span>
                }
        }
}

func (jm *JobManager) killHangingJobsInner() error <span class="cov8" title="1">{
        jm.runningTasksLock.Lock()
        defer jm.runningTasksLock.Unlock()

        jm.runningTaskStartTimesLock.Lock()
        defer jm.runningTaskStartTimesLock.Unlock()

        jm.cancelsLock.Lock()
        defer jm.cancelsLock.Unlock()

        jm.nextRunTimesLock.Lock()
        defer jm.nextRunTimesLock.Unlock()

        var err error
        for taskName, startedTime := range jm.runningTaskStartTimes </span><span class="cov8" title="1">{
                task, hasTask := jm.runningTasks[taskName]
                if !hasTask </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">timeoutProvider, isTimeoutProvder := task.(TimeoutProvider)
                if !isTimeoutProvder </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">timeout := timeoutProvider.Timeout()
                currentTime := Now()
                if nextRunTime, hasNextRuntime := jm.nextRunTimes[taskName]; hasNextRuntime </span><span class="cov8" title="1">{
                        // we need to calculate the effective timeout
                        // either startedTime+timeout or the next runtime, whichever is closer.

                        // t1 represents the absolute timeout time.
                        t1 := startedTime.Add(timeout)
                        // t2 represents the next runtime, or an effective time we need to stop by.
                        t2 := *nextRunTime

                        // the effective timeout is whichever is more soon.
                        effectiveTimeout := Min(t1, t2)

                        // if the effective timeout is in the past, or it's within the next heartbeat.
                        if currentTime.After(effectiveTimeout) || effectiveTimeout.Sub(currentTime) &lt; jm.heartbeatInterval </span><span class="cov8" title="1">{
                                err = jm.killHangingJob(taskName)
                                if err != nil </span><span class="cov0" title="0">{
                                        jm.log.Error(err)
                                }</span>
                        }
                } else<span class="cov0" title="0"> if currentTime.Sub(startedTime) &gt;= timeout </span><span class="cov0" title="0">{
                        err = jm.killHangingJob(taskName)
                        if err != nil </span><span class="cov0" title="0">{
                                jm.log.Error(err)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// killHangingJob cancels (sends the cancellation signal) to a running task that has exceeded its timeout.
// it assumes that the following locks are held:
// - runningTasksLock
// - runningTaskStartTimesLock
// - contextsLock
// otherwise, chaos, mayhem, deadlocks. You should *rarely* need to call this explicitly.
func (jm *JobManager) killHangingJob(taskName string) error <span class="cov8" title="1">{
        _, hasTask := jm.runningTasks[taskName]
        if !hasTask </span><span class="cov0" title="0">{
                return exception.Newf("task not found").WithMessagef("Task: %s", taskName)
        }</span>

        <span class="cov8" title="1">cancel, hasCancel := jm.cancels[taskName]
        if !hasCancel </span><span class="cov0" title="0">{
                return exception.Newf("task has no cancellation handle").WithMessagef("Task: %s", taskName)
        }</span>

        <span class="cov8" title="1">cancel()

        delete(jm.runningTasks, taskName)
        delete(jm.runningTaskStartTimes, taskName)
        delete(jm.contexts, taskName)
        delete(jm.cancels, taskName)

        return nil</span>
}

// --------------------------------------------------------------------------------
// Status Methods
// --------------------------------------------------------------------------------

// Status returns the status metadata for a JobManager
func (jm *JobManager) Status() []TaskStatus <span class="cov0" title="0">{

        jm.loadedJobsLock.Lock()
        defer jm.loadedJobsLock.Unlock()

        jm.runningTaskStartTimesLock.Lock()
        defer jm.runningTaskStartTimesLock.Unlock()

        jm.disabledJobsLock.Lock()
        defer jm.disabledJobsLock.Unlock()

        jm.runningTasksLock.Lock()
        defer jm.runningTasksLock.Unlock()

        jm.nextRunTimesLock.Lock()
        defer func() </span><span class="cov0" title="0">{
                jm.nextRunTimesLock.Unlock()
        }</span>()

        <span class="cov0" title="0">jm.lastRunTimesLock.Lock()
        defer jm.lastRunTimesLock.Unlock()

        var statuses []TaskStatus
        now := Now()
        for jobName, job := range jm.loadedJobs </span><span class="cov0" title="0">{
                status := TaskStatus{}
                status.Name = jobName

                if runningSince, isRunning := jm.runningTaskStartTimes[jobName]; isRunning </span><span class="cov0" title="0">{
                        status.State = StateRunning
                        status.RunningFor = fmt.Sprintf("%v", now.Sub(runningSince))
                }</span> else<span class="cov0" title="0"> if jm.disabledJobs.Contains(jobName) </span><span class="cov0" title="0">{
                        status.State = StateDisabled
                }</span> else<span class="cov0" title="0"> {
                        status.State = StateEnabled
                }</span>

                <span class="cov0" title="0">if lastRunTime, hasLastRunTime := jm.lastRunTimes[jobName]; hasLastRunTime </span><span class="cov0" title="0">{
                        status.LastRunTime = FormatTime(lastRunTime)
                }</span>

                <span class="cov0" title="0">if nextRunTime, hasNextRunTime := jm.nextRunTimes[jobName]; hasNextRunTime </span><span class="cov0" title="0">{
                        if nextRunTime != nil </span><span class="cov0" title="0">{
                                status.NextRunTime = FormatTime(*nextRunTime)
                        }</span>
                }

                <span class="cov0" title="0">if statusProvider, isStatusProvider := job.(StatusProvider); isStatusProvider </span><span class="cov0" title="0">{
                        providedStatus := statusProvider.Status()
                        if len(providedStatus) &gt; 0 </span><span class="cov0" title="0">{
                                status.Status = providedStatus
                        }</span>
                }

                <span class="cov0" title="0">statuses = append(statuses, status)</span>
        }

        <span class="cov0" title="0">for taskName, task := range jm.runningTasks </span><span class="cov0" title="0">{
                if _, isJob := jm.loadedJobs[taskName]; !isJob </span><span class="cov0" title="0">{
                        status := TaskStatus{
                                Name:  taskName,
                                State: StateRunning,
                        }
                        if runningSince, isRunning := jm.runningTaskStartTimes[taskName]; isRunning </span><span class="cov0" title="0">{
                                status.RunningFor = fmt.Sprintf("%v", now.Sub(runningSince))
                        }</span>
                        <span class="cov0" title="0">if statusProvider, isStatusProvider := task.(StatusProvider); isStatusProvider </span><span class="cov0" title="0">{
                                status.Status = statusProvider.Status()
                        }</span>
                        <span class="cov0" title="0">statuses = append(statuses, status)</span>
                }
        }
        <span class="cov0" title="0">return statuses</span>
}

// TaskStatus returns the status metadata for a given task.
func (jm *JobManager) TaskStatus(taskName string) *TaskStatus <span class="cov0" title="0">{
        jm.runningTaskStartTimesLock.Lock()
        defer jm.runningTaskStartTimesLock.Unlock()

        jm.runningTasksLock.Lock()
        defer jm.runningTasksLock.Unlock()

        if task, isRunning := jm.runningTasks[taskName]; isRunning </span><span class="cov0" title="0">{
                now := Now()
                status := TaskStatus{
                        Name:  taskName,
                        State: StateRunning,
                }
                if runningSince, isRunning := jm.runningTaskStartTimes[taskName]; isRunning </span><span class="cov0" title="0">{
                        status.RunningFor = fmt.Sprintf("%v", now.Sub(runningSince))
                }</span>
                <span class="cov0" title="0">if statusProvider, isStatusProvider := task.(StatusProvider); isStatusProvider </span><span class="cov0" title="0">{
                        status.Status = statusProvider.Status()
                }</span>
                <span class="cov0" title="0">return &amp;status</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// --------------------------------------------------------------------------------
// Atomic Access/Mutating Methods
// --------------------------------------------------------------------------------

func (jm *JobManager) getContext(taskName string) (ctx context.Context) <span class="cov0" title="0">{
        jm.contextsLock.Lock()
        ctx = jm.contexts[taskName]
        jm.contextsLock.Unlock()
        return
}</span>

// note; this setter is out of order because of the linter.
func (jm *JobManager) setContext(ctx context.Context, taskName string) <span class="cov8" title="1">{
        jm.contextsLock.Lock()
        jm.contexts[taskName] = ctx
        jm.contextsLock.Unlock()
}</span>

func (jm *JobManager) deleteContext(taskName string) <span class="cov8" title="1">{
        jm.contextsLock.Lock()
        delete(jm.contexts, taskName)
        jm.contextsLock.Unlock()
}</span>

func (jm *JobManager) getCancelFunc(taskName string) (cancel context.CancelFunc) <span class="cov8" title="1">{
        jm.cancelsLock.Lock()
        cancel = jm.cancels[taskName]
        jm.cancelsLock.Unlock()
        return
}</span>

func (jm *JobManager) setCancelFunc(taskName string, cancel context.CancelFunc) <span class="cov8" title="1">{
        jm.cancelsLock.Lock()
        jm.cancels[taskName] = cancel
        jm.cancelsLock.Unlock()
}</span>

func (jm *JobManager) deleteCancelFunc(taskName string) <span class="cov8" title="1">{
        jm.cancelsLock.Lock()
        delete(jm.cancels, taskName)
        jm.cancelsLock.Unlock()
}</span>

func (jm *JobManager) setDisabledJob(jobName string) <span class="cov8" title="1">{
        jm.disabledJobsLock.Lock()
        jm.disabledJobs.Add(jobName)
        jm.disabledJobsLock.Unlock()
}</span>

func (jm *JobManager) deleteDisabledJob(jobName string) <span class="cov8" title="1">{
        jm.disabledJobsLock.Lock()
        jm.disabledJobs.Remove(jobName)
        jm.disabledJobsLock.Unlock()
}</span>

func (jm *JobManager) getNextRunTime(jobName string) (nextRunTime *time.Time) <span class="cov8" title="1">{
        jm.nextRunTimesLock.Lock()
        nextRunTime = jm.nextRunTimes[jobName]
        jm.nextRunTimesLock.Unlock()
        return
}</span>

func (jm *JobManager) setNextRunTime(jobName string, t *time.Time) <span class="cov8" title="1">{
        jm.nextRunTimesLock.Lock()
        jm.nextRunTimes[jobName] = t
        jm.nextRunTimesLock.Unlock()
}</span>

func (jm *JobManager) setEnabledProvider(jobName string, j Job) <span class="cov8" title="1">{

        if typed, isTyped := j.(EnabledProvider); isTyped </span><span class="cov8" title="1">{
                jm.enabledProvidersLock.Lock()
                jm.enabledProviders[jobName] = func() bool </span><span class="cov8" title="1">{ return typed.Enabled() }</span>
                <span class="cov8" title="1">jm.enabledProvidersLock.Unlock()</span>
        }
}

func (jm *JobManager) deleteNextRunTime(jobName string) <span class="cov8" title="1">{
        jm.nextRunTimesLock.Lock()
        delete(jm.nextRunTimes, jobName)
        jm.nextRunTimesLock.Unlock()
}</span>

func (jm *JobManager) getLastRunTime(taskName string) (lastRunTime time.Time) <span class="cov0" title="0">{
        jm.lastRunTimesLock.Lock()
        lastRunTime = jm.lastRunTimes[taskName]
        jm.lastRunTimesLock.Unlock()
        return
}</span>

func (jm *JobManager) setLastRunTime(taskName string, t time.Time) <span class="cov8" title="1">{
        jm.lastRunTimesLock.Lock()
        jm.lastRunTimes[taskName] = t
        jm.lastRunTimesLock.Unlock()
}</span>

func (jm *JobManager) deleteLastRunTime(taskName string) <span class="cov0" title="0">{
        jm.lastRunTimesLock.Lock()
        delete(jm.lastRunTimes, taskName)
        jm.lastRunTimesLock.Unlock()
}</span>

func (jm *JobManager) getLoadedJob(jobName string) (job Job) <span class="cov8" title="1">{
        jm.loadedJobsLock.Lock()
        job = jm.loadedJobs[jobName]
        jm.loadedJobsLock.Unlock()
        return
}</span>

func (jm *JobManager) setLoadedJob(jobName string, j Job) <span class="cov8" title="1">{
        jm.loadedJobsLock.Lock()
        jm.loadedJobs[jobName] = j
        jm.loadedJobsLock.Unlock()
}</span>

func (jm *JobManager) deleteLoadedJob(jobName string) <span class="cov0" title="0">{
        jm.loadedJobsLock.Lock()
        delete(jm.loadedJobs, jobName)
        jm.loadedJobsLock.Unlock()
}</span>

func (jm *JobManager) getRunningTask(taskName string) (task Task) <span class="cov0" title="0">{
        jm.runningTasksLock.Lock()
        task = jm.runningTasks[taskName]
        jm.runningTasksLock.Unlock()
        return
}</span>

func (jm *JobManager) setRunningTask(taskName string, t Task) <span class="cov8" title="1">{
        jm.runningTasksLock.Lock()
        jm.runningTasks[taskName] = t
        jm.runningTasksLock.Unlock()
}</span>

func (jm *JobManager) deleteRunningTask(taskName string) <span class="cov8" title="1">{
        jm.runningTasksLock.Lock()
        delete(jm.runningTasks, taskName)
        jm.runningTasksLock.Unlock()
}</span>

func (jm *JobManager) getRunningTaskStartTime(taskName string) (startTime time.Time) <span class="cov0" title="0">{
        jm.runningTaskStartTimesLock.Lock()

        startTime = jm.runningTaskStartTimes[taskName]
        jm.runningTaskStartTimesLock.Unlock()
        return
}</span>

func (jm *JobManager) setRunningTaskStartTime(taskName string, t time.Time) <span class="cov8" title="1">{
        jm.runningTaskStartTimesLock.Lock()
        jm.runningTaskStartTimes[taskName] = t
        jm.runningTaskStartTimesLock.Unlock()
}</span>

func (jm *JobManager) deleteRunningTaskStartTime(taskName string) <span class="cov8" title="1">{
        jm.runningTaskStartTimesLock.Lock()
        delete(jm.runningTaskStartTimes, taskName)
        jm.runningTaskStartTimesLock.Unlock()
}</span>

func (jm *JobManager) getSchedule(jobName string) (schedule Schedule) <span class="cov8" title="1">{
        jm.schedulesLock.Lock()
        schedule = jm.schedules[jobName]
        jm.schedulesLock.Unlock()
        return
}</span>

func (jm *JobManager) setSchedule(jobName string, schedule Schedule) <span class="cov8" title="1">{
        jm.schedulesLock.Lock()
        jm.schedules[jobName] = schedule
        jm.schedulesLock.Unlock()
}</span>

func (jm *JobManager) deleteSchedule(jobName string) <span class="cov0" title="0">{
        jm.schedulesLock.Lock()
        defer jm.schedulesLock.Unlock()

        delete(jm.schedules, jobName)
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package cron

import "time"

// NOTE: time.Zero()? what's that?
var (
        // DaysOfWeek are all the time.Weekday in an array for utility purposes.
        DaysOfWeek = []time.Weekday{
                time.Sunday,
                time.Monday,
                time.Tuesday,
                time.Wednesday,
                time.Thursday,
                time.Friday,
                time.Saturday,
        }

        // WeekDays are the business time.Weekday in an array.
        WeekDays = []time.Weekday{
                time.Monday,
                time.Tuesday,
                time.Wednesday,
                time.Thursday,
                time.Friday,
        }

        // WeekWeekEndDaysDays are the weekend time.Weekday in an array.
        WeekendDays = []time.Weekday{
                time.Sunday,
                time.Saturday,
        }

        // Epoch is unix epoch saved for utility purposes.
        Epoch = time.Unix(0, 0)
)

// NOTE: we have to use shifts here because in their infinite wisdom google didn't make these values powers of two for masking

const (
        // AllDaysMask is a bitmask of all the days of the week.
        AllDaysMask = 1&lt;&lt;uint(time.Sunday) | 1&lt;&lt;uint(time.Monday) | 1&lt;&lt;uint(time.Tuesday) | 1&lt;&lt;uint(time.Wednesday) | 1&lt;&lt;uint(time.Thursday) | 1&lt;&lt;uint(time.Friday) | 1&lt;&lt;uint(time.Saturday)
        // WeekDaysMask is a bitmask of all the weekdays of the week.
        WeekDaysMask = 1&lt;&lt;uint(time.Monday) | 1&lt;&lt;uint(time.Tuesday) | 1&lt;&lt;uint(time.Wednesday) | 1&lt;&lt;uint(time.Thursday) | 1&lt;&lt;uint(time.Friday)
        //WeekendDaysMask is a bitmask of the weekend days of the week.
        WeekendDaysMask = 1&lt;&lt;uint(time.Sunday) | 1&lt;&lt;uint(time.Saturday)
)

// IsWeekDay returns if the day is a monday-&gt;friday.
func IsWeekDay(day time.Weekday) bool <span class="cov8" title="1">{
        return !IsWeekendDay(day)
}</span>

// IsWeekendDay returns if the day is a monday-&gt;friday.
func IsWeekendDay(day time.Weekday) bool <span class="cov8" title="1">{
        return day == time.Saturday || day == time.Sunday
}</span>

// Schedule is a type that provides a next runtime after a given previous runtime.
type Schedule interface {
        // GetNextRuntime should return the next runtime after a given previous runtime. If `after` is &lt;nil&gt; it should be assumed
        // the job hasn't run yet. If &lt;nil&gt; is returned by the schedule it is inferred that the job should not run again.
        GetNextRunTime(after *time.Time) *time.Time
}

// EverySecond returns a schedule that fires every second.
func EverySecond() Schedule <span class="cov0" title="0">{
        return IntervalSchedule{Every: 1 * time.Second}
}</span>

// EveryMinute returns a schedule that fires every minute.
func EveryMinute() Schedule <span class="cov0" title="0">{
        return IntervalSchedule{Every: 1 * time.Minute}
}</span>

// EveryHour returns a schedule that fire every hour.
func EveryHour() Schedule <span class="cov8" title="1">{
        return IntervalSchedule{Every: 1 * time.Hour}
}</span>

// Every returns a schedule that fires every given interval.
func Every(interval time.Duration) Schedule <span class="cov8" title="1">{
        return IntervalSchedule{Every: interval}
}</span>

// EveryQuarterHour returns a schedule that fires every 15 minutes, on the quarter hours (0, 15, 30, 45)
func EveryQuarterHour() Schedule <span class="cov0" title="0">{
        return OnTheQuarterHour{}
}</span>

// EveryHourOnTheHour returns a schedule that fires every 60 minutes on the 00th minute.
func EveryHourOnTheHour() Schedule <span class="cov0" title="0">{
        return OnTheHour{}
}</span>

// EveryHourAt returns a schedule that fires every hour at a given minute.
func EveryHourAt(minute int) Schedule <span class="cov8" title="1">{
        return OnTheHourAt{minute}
}</span>

// WeeklyAt returns a schedule that fires on every of the given days at the given time by hour, minute and second.
func WeeklyAt(hour, minute, second int, days ...time.Weekday) Schedule <span class="cov8" title="1">{
        dayOfWeekMask := uint(0)
        for _, day := range days </span><span class="cov8" title="1">{
                dayOfWeekMask = dayOfWeekMask | 1&lt;&lt;uint(day)
        }</span>

        <span class="cov8" title="1">return &amp;DailySchedule{DayOfWeekMask: dayOfWeekMask, TimeOfDayUTC: time.Date(0, 0, 0, hour, minute, second, 0, time.UTC)}</span>
}

// DailyAt returns a schedule that fires every day at the given hour, minut and second.
func DailyAt(hour, minute, second int) Schedule <span class="cov8" title="1">{
        return &amp;DailySchedule{DayOfWeekMask: AllDaysMask, TimeOfDayUTC: time.Date(0, 0, 0, hour, minute, second, 0, time.UTC)}
}</span>

// WeekdaysAt returns a schedule that fires every week day at the given hour, minut and second.
func WeekdaysAt(hour, minute, second int) Schedule <span class="cov0" title="0">{
        return &amp;DailySchedule{DayOfWeekMask: WeekDaysMask, TimeOfDayUTC: time.Date(0, 0, 0, hour, minute, second, 0, time.UTC)}
}</span>

// WeekendsAt returns a schedule that fires every weekend day at the given hour, minut and second.
func WeekendsAt(hour, minute, second int) Schedule <span class="cov0" title="0">{
        return &amp;DailySchedule{DayOfWeekMask: WeekendDaysMask, TimeOfDayUTC: time.Date(0, 0, 0, hour, minute, second, 0, time.UTC)}
}</span>

// --------------------------------------------------------------------------------
// Schedule Implementations
// --------------------------------------------------------------------------------

// OnDemand returns an on demand schedule, or a schedule that only allows the job to be run
// explicitly by calling `RunJob` on the `JobManager`.
func OnDemand() Schedule <span class="cov8" title="1">{
        return OnDemandSchedule{}
}</span>

// OnDemandSchedule is a schedule that runs on demand.
type OnDemandSchedule struct{}

// GetNextRunTime gets the next run time.
func (ods OnDemandSchedule) GetNextRunTime(after *time.Time) *time.Time <span class="cov8" title="1">{
        return nil
}</span>

// Immediately Returns a schedule that casues a job to run immediately on start,
// with an optional subsequent schedule.
func Immediately() *ImmediateSchedule <span class="cov8" title="1">{
        return &amp;ImmediateSchedule{}
}</span>

// ImmediateSchedule fires immediately with an optional subsequent schedule..
type ImmediateSchedule struct {
        didRun bool
        then   Schedule
}

// Then allows you to specify a subsequent schedule after the first run.
func (i *ImmediateSchedule) Then(then Schedule) Schedule <span class="cov8" title="1">{
        i.then = then
        return i
}</span>

// GetNextRunTime implements Schedule.
func (i *ImmediateSchedule) GetNextRunTime(after *time.Time) *time.Time <span class="cov8" title="1">{
        if !i.didRun </span><span class="cov8" title="1">{
                i.didRun = true
                return optional(Now())
        }</span>
        <span class="cov8" title="1">if i.then != nil </span><span class="cov8" title="1">{
                return i.then.GetNextRunTime(after)
        }</span>
        <span class="cov8" title="1">return optional(Now())</span>
}

// IntervalSchedule is as chedule that fires every given interval with an optional start delay.
type IntervalSchedule struct {
        Every      time.Duration
        StartDelay *time.Duration
}

// GetNextRunTime implements Schedule.
func (i IntervalSchedule) GetNextRunTime(after *time.Time) *time.Time <span class="cov8" title="1">{
        if after == nil </span><span class="cov8" title="1">{
                if i.StartDelay == nil </span><span class="cov8" title="1">{
                        next := Now().Add(i.Every)
                        return &amp;next
                }</span>
                <span class="cov0" title="0">next := Now().Add(*i.StartDelay).Add(i.Every)
                return &amp;next</span>
        }
        <span class="cov8" title="1">last := *after
        last = last.Add(i.Every)
        return &amp;last</span>
}

// DailySchedule is a schedule that fires every day that satisfies the DayOfWeekMask at the given TimeOfDayUTC.
type DailySchedule struct {
        DayOfWeekMask uint
        TimeOfDayUTC  time.Time
}

func (ds DailySchedule) checkDayOfWeekMask(day time.Weekday) bool <span class="cov8" title="1">{
        trialDayMask := uint(1 &lt;&lt; uint(day))
        bitwiseResult := (ds.DayOfWeekMask &amp; trialDayMask)
        return bitwiseResult &gt; uint(0)
}</span>

// GetNextRunTime implements Schedule.
func (ds DailySchedule) GetNextRunTime(after *time.Time) *time.Time <span class="cov8" title="1">{
        if after == nil </span><span class="cov0" title="0">{
                after = optional(Now())
        }</span>

        <span class="cov8" title="1">todayInstance := time.Date(after.Year(), after.Month(), after.Day(), ds.TimeOfDayUTC.Hour(), ds.TimeOfDayUTC.Minute(), ds.TimeOfDayUTC.Second(), 0, time.UTC)
        for day := 0; day &lt; 8; day++ </span><span class="cov8" title="1">{
                next := todayInstance.AddDate(0, 0, day) //the first run here it should be adding nothing, i.e. returning todayInstance ...

                if ds.checkDayOfWeekMask(next.Weekday()) &amp;&amp; next.After(*after) </span><span class="cov8" title="1">{ //we're on a day ...
                        return &amp;next
                }</span>
        }

        <span class="cov0" title="0">return &amp;Epoch</span>
}

// OnTheQuarterHour is a schedule that fires every 15 minutes, on the quarter hours.
type OnTheQuarterHour struct{}

// GetNextRunTime implements the chronometer Schedule api.
func (o OnTheQuarterHour) GetNextRunTime(after *time.Time) *time.Time <span class="cov0" title="0">{
        var returnValue time.Time
        if after == nil </span><span class="cov0" title="0">{
                now := Now()
                if now.Minute() &gt;= 45 </span><span class="cov0" title="0">{
                        returnValue = time.Date(now.Year(), now.Month(), now.Day(), now.Hour(), 45, 0, 0, time.UTC).Add(15 * time.Minute)
                }</span> else<span class="cov0" title="0"> if now.Minute() &gt;= 30 </span><span class="cov0" title="0">{
                        returnValue = time.Date(now.Year(), now.Month(), now.Day(), now.Hour(), 30, 0, 0, time.UTC).Add(15 * time.Minute)
                }</span> else<span class="cov0" title="0"> if now.Minute() &gt;= 15 </span><span class="cov0" title="0">{
                        returnValue = time.Date(now.Year(), now.Month(), now.Day(), now.Hour(), 15, 0, 0, time.UTC).Add(15 * time.Minute)
                }</span> else<span class="cov0" title="0"> {
                        returnValue = time.Date(now.Year(), now.Month(), now.Day(), now.Hour(), 0, 0, 0, time.UTC).Add(15 * time.Minute)
                }</span>
        } else<span class="cov0" title="0"> {
                if after.Minute() &gt;= 45 </span><span class="cov0" title="0">{
                        returnValue = time.Date(after.Year(), after.Month(), after.Day(), after.Hour(), 45, 0, 0, time.UTC).Add(15 * time.Minute)
                }</span> else<span class="cov0" title="0"> if after.Minute() &gt;= 30 </span><span class="cov0" title="0">{
                        returnValue = time.Date(after.Year(), after.Month(), after.Day(), after.Hour(), 30, 0, 0, time.UTC).Add(15 * time.Minute)
                }</span> else<span class="cov0" title="0"> if after.Minute() &gt;= 15 </span><span class="cov0" title="0">{
                        returnValue = time.Date(after.Year(), after.Month(), after.Day(), after.Hour(), 15, 0, 0, time.UTC).Add(15 * time.Minute)
                }</span> else<span class="cov0" title="0"> {
                        returnValue = time.Date(after.Year(), after.Month(), after.Day(), after.Hour(), 0, 0, 0, time.UTC).Add(15 * time.Minute)
                }</span>
        }
        <span class="cov0" title="0">return &amp;returnValue</span>
}

// OnTheHour is a schedule that fires every hour on the 00th minute.
type OnTheHour struct{}

// GetNextRunTime implements the chronometer Schedule api.
func (o OnTheHour) GetNextRunTime(after *time.Time) *time.Time <span class="cov0" title="0">{
        var returnValue time.Time
        now := Now()
        if after == nil </span><span class="cov0" title="0">{
                returnValue = time.Date(now.Year(), now.Month(), now.Day(), now.Hour(), 0, 0, 0, time.UTC).Add(1 * time.Hour)
                if returnValue.Before(now) </span><span class="cov0" title="0">{
                        returnValue = returnValue.Add(time.Hour)
                }</span>
        } else<span class="cov0" title="0"> {
                returnValue = time.Date(after.Year(), after.Month(), after.Day(), after.Hour(), 0, 0, 0, time.UTC).Add(1 * time.Hour)
        }</span>
        <span class="cov0" title="0">return &amp;returnValue</span>
}

// OnTheHourAt is a schedule that fires every hour on the given minute.
type OnTheHourAt struct {
        Minute int
}

// GetNextRunTime implements the chronometer Schedule api.
func (o OnTheHourAt) GetNextRunTime(after *time.Time) *time.Time <span class="cov8" title="1">{
        var returnValue time.Time
        now := Now()
        if after == nil </span><span class="cov8" title="1">{
                returnValue = time.Date(now.Year(), now.Month(), now.Day(), now.Hour(), o.Minute, 0, 0, time.UTC)
                if returnValue.Before(now) </span><span class="cov8" title="1">{
                        returnValue = returnValue.Add(time.Hour)
                }</span>
        } else<span class="cov8" title="1"> {
                returnValue = time.Date(after.Year(), after.Month(), after.Day(), after.Hour(), o.Minute, 0, 0, time.UTC)
                if returnValue.Before(*after) </span><span class="cov8" title="1">{
                        returnValue = returnValue.Add(time.Hour)
                }</span>
        }
        <span class="cov8" title="1">return &amp;returnValue</span>
}

// --------------------------------------------------------------------------------
// Helpers
// --------------------------------------------------------------------------------

func optional(t time.Time) *time.Time <span class="cov8" title="1">{
        if t.IsZero() </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;t</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package cron

import (
        "context"
        "fmt"
        "time"

        "github.com/blend/go-sdk/uuid"
)

// --------------------------------------------------------------------------------
// interfaces
// --------------------------------------------------------------------------------

// CancellationSignalReciever is a function that can be used as a receiver for cancellation signals.
type CancellationSignalReciever func()

// TaskAction is an function that can be run as a task
type TaskAction func(ctx context.Context) error

// ResumeProvider is an interface that allows a task to be resumed.
type ResumeProvider interface {
        State() interface{}
        Resume(state interface{}) error
}

// TimeoutProvider is an interface that allows a task to be timed out.
type TimeoutProvider interface {
        Timeout() time.Duration
}

// StatusProvider is an interface that allows a task to report its status.
type StatusProvider interface {
        Status() string
}

// OnStartReceiver is an interface that allows a task to be signaled when it has started.
type OnStartReceiver interface {
        OnStart()
}

// OnCancellationReceiver is an interface that allows a task to be signaled when it has been canceled.
type OnCancellationReceiver interface {
        OnCancellation()
}

// OnCompleteReceiver is an interface that allows a task to be signaled when it has been completed.
type OnCompleteReceiver interface {
        OnComplete(err error)
}

// SerialProvider is an optional interface that prohibits a task from running
// multiple times in parallel.
type SerialProvider interface {
        Serial()
}

// Task is an interface that structs can satisfy to allow them to be run as tasks.
type Task interface {
        Name() string
        Execute(ctx context.Context) error
}

// --------------------------------------------------------------------------------
// quick task creation
// --------------------------------------------------------------------------------

type basicTask struct {
        name   string
        action TaskAction
}

func (bt basicTask) Name() string <span class="cov8" title="1">{
        return bt.name
}</span>
func (bt basicTask) Execute(ctx context.Context) error <span class="cov8" title="1">{
        return bt.action(ctx)
}</span>
func (bt basicTask) OnStart()             {<span class="cov8" title="1">}</span>
func (bt basicTask) OnCancellation()      {<span class="cov8" title="1">}</span>
func (bt basicTask) OnComplete(err error) {<span class="cov8" title="1">}</span>

// generateTaskName returns a unique identifier that can be used to name/tag tasks
func generateTaskName() string <span class="cov8" title="1">{
        return fmt.Sprintf("task_%s", uuid.V4().ToShortString())
}</span>

// NewTask returns a new task wrapper for a given TaskAction.
func NewTask(action TaskAction) Task <span class="cov8" title="1">{
        name := generateTaskName()
        return &amp;basicTask{name: name, action: action}
}</span>

// NewTaskWithName returns a new task wrapper with a given name for a given TaskAction.
func NewTaskWithName(name string, action TaskAction) Task <span class="cov8" title="1">{
        return &amp;basicTask{name: name, action: action}
}</span>

// -------------------------------------------------------------------------------
// serial basic task
// -------------------------------------------------------------------------------

type basicSerialTask struct {
        name   string
        action TaskAction
}

// Name returns the name of a basic serial task
func (bst basicSerialTask) Name() string <span class="cov8" title="1">{
        return bst.name
}</span>

// Execute runs the action that was assigned for the task
func (bst basicSerialTask) Execute(ctx context.Context) error <span class="cov8" title="1">{
        return bst.action(ctx)
}</span>

func (bst basicSerialTask) OnStart()             {<span class="cov8" title="1">}</span>
func (bst basicSerialTask) OnCancellation()      {<span class="cov0" title="0">}</span>
func (bst basicSerialTask) OnComplete(err error) {<span class="cov8" title="1">}</span>
func (bst basicSerialTask) Serial()              {<span class="cov0" title="0">}</span>

// NewSerialTask creates a task that run only serially, provided an
// action and a policy
func NewSerialTask(action TaskAction) Task <span class="cov0" title="0">{
        name := generateTaskName()
        return &amp;basicSerialTask{name: name, action: action}
}</span>

// NewSerialTaskWithName creates a task that can only be run serially given an
// action, name, and policy
func NewSerialTaskWithName(name string, action TaskAction) Task <span class="cov8" title="1">{
        return &amp;basicSerialTask{name: name, action: action}
}</span>

// --------------------------------------------------------------------------------
// task status
// --------------------------------------------------------------------------------

// TaskStatus is the basic format of a status of a task.
type TaskStatus struct {
        Name        string `json:"name"`
        State       State  `json:"state"`
        Status      string `json:"status,omitempty"`
        LastRunTime string `json:"last_run_time,omitempty"`
        NextRunTime string `json:"next_run_time,omitempy"`
        RunningFor  string `json:"running_for,omitempty"`
        Serial      bool   `json:"serial_execution,omitempty"`
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package cron

import "time"

// Now returns a new timestamp.
func Now() time.Time <span class="cov8" title="1">{
        return time.Now().UTC()
}</span>

// Since returns the duration since another timestamp.
func Since(t time.Time) time.Duration <span class="cov8" title="1">{
        return Now().Sub(t)
}</span>

// Min returns the minimum of two times.
func Min(t1, t2 time.Time) time.Time <span class="cov8" title="1">{
        if t1.Before(t2) </span><span class="cov0" title="0">{
                return t1
        }</span>
        <span class="cov8" title="1">return t2</span>
}

// Max returns the maximum of two times.
func Max(t1, t2 time.Time) time.Time <span class="cov0" title="0">{
        if t1.Before(t2) </span><span class="cov0" title="0">{
                return t2
        }</span>
        <span class="cov0" title="0">return t1</span>
}

// FormatTime returns a string for a time.
func FormatTime(t time.Time) string <span class="cov0" title="0">{
        return t.Format(time.RFC3339)
}</span>

// OptionalUInt8 Returns a pointer to a value
func OptionalUInt8(value uint8) *uint8 <span class="cov0" title="0">{
        return &amp;value
}</span>

// OptionalUInt16 Returns a pointer to a value
func OptionalUInt16(value uint16) *uint16 <span class="cov0" title="0">{
        return &amp;value
}</span>

// OptionalUInt Returns a pointer to a value
func OptionalUInt(value uint) *uint <span class="cov0" title="0">{
        return &amp;value
}</span>

// OptionalUInt64 Returns a pointer to a value
func OptionalUInt64(value uint64) *uint64 <span class="cov0" title="0">{
        return &amp;value
}</span>

// OptionalInt16 Returns a pointer to a value
func OptionalInt16(value int16) *int16 <span class="cov0" title="0">{
        return &amp;value
}</span>

// OptionalInt Returns a pointer to a value
func OptionalInt(value int) *int <span class="cov0" title="0">{
        return &amp;value
}</span>

// OptionalInt64 Returns a pointer to a value
func OptionalInt64(value int64) *int64 <span class="cov0" title="0">{
        return &amp;value
}</span>

// OptionalFloat32 Returns a pointer to a value
func OptionalFloat32(value float32) *float32 <span class="cov0" title="0">{
        return &amp;value
}</span>

// OptionalFloat64 Returns a pointer to a value
func OptionalFloat64(value float64) *float64 <span class="cov0" title="0">{
        return &amp;value
}</span>

// OptionalString Returns a pointer to a value
func OptionalString(value string) *string <span class="cov0" title="0">{
        return &amp;value
}</span>

// OptionalBool Returns a pointer to a value
func OptionalBool(value bool) *bool <span class="cov0" title="0">{
        return &amp;value
}</span>

// OptionalTime Returns a pointer to a value
func OptionalTime(value time.Time) *time.Time <span class="cov8" title="1">{
        return &amp;value
}</span>

// OptionalDuration Returns a pointer to a value
func OptionalDuration(value time.Duration) *time.Duration <span class="cov0" title="0">{
        return &amp;value
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package db

import (
        "bytes"
        "sync"
)

// NewBufferPool returns a new BufferPool.
func NewBufferPool(bufferSize int) *BufferPool <span class="cov8" title="1">{
        return &amp;BufferPool{
                Pool: sync.Pool{New: func() interface{} </span><span class="cov8" title="1">{
                        b := bytes.NewBuffer(make([]byte, bufferSize))
                        b.Reset()
                        return b
                }</span>},
        }
}

// BufferPool is a sync.Pool of bytes.Buffer.
type BufferPool struct {
        sync.Pool
}

// Get returns a pooled bytes.Buffer instance.
func (bp *BufferPool) Get() *bytes.Buffer <span class="cov8" title="1">{
        return bp.Pool.Get().(*bytes.Buffer)
}</span>

// Put returns the pooled instance.
func (bp *BufferPool) Put(b *bytes.Buffer) <span class="cov8" title="1">{
        b.Reset()
        bp.Pool.Put(b)
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package db

import (
        "encoding/json"
        "reflect"
        "strings"

        "github.com/blend/go-sdk/exception"
)

// --------------------------------------------------------------------------------
// Column
// --------------------------------------------------------------------------------

// NewColumnFromFieldTag reads the contents of a field tag, ex: `json:"foo" db:"bar,isprimarykey,isserial"
func NewColumnFromFieldTag(field reflect.StructField) *Column <span class="cov8" title="1">{
        db := field.Tag.Get("db")
        if db != "-" </span><span class="cov8" title="1">{
                col := Column{}
                col.FieldName = field.Name
                col.ColumnName = strings.ToLower(field.Name)
                col.FieldType = field.Type
                if db != "" </span><span class="cov8" title="1">{
                        pieces := strings.Split(db, ",")

                        if !strings.HasPrefix(db, ",") </span><span class="cov8" title="1">{
                                col.ColumnName = pieces[0]
                        }</span>

                        <span class="cov8" title="1">if len(pieces) &gt;= 1 </span><span class="cov8" title="1">{
                                args := strings.Join(pieces[1:], ",")
                                col.IsPrimaryKey = strings.Contains(strings.ToLower(args), "pk")
                                col.IsSerial = strings.Contains(strings.ToLower(args), "serial")
                                col.IsNullable = strings.Contains(strings.ToLower(args), "nullable")
                                col.IsReadOnly = strings.Contains(strings.ToLower(args), "readonly")
                                col.IsJSON = strings.Contains(strings.ToLower(args), "json")
                        }</span>
                }
                <span class="cov8" title="1">return &amp;col</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Column represents a single field on a struct that is mapped to the database.
type Column struct {
        TableName    string
        FieldName    string
        FieldType    reflect.Type
        ColumnName   string
        Index        int
        IsPrimaryKey bool
        IsSerial     bool
        IsNullable   bool
        IsReadOnly   bool
        IsJSON       bool
}

// SetValue sets the field on a database mapped object to the instance of `value`.
func (c Column) SetValue(object interface{}, value interface{}) error <span class="cov8" title="1">{
        objValue := reflectValue(object)
        field := objValue.FieldByName(c.FieldName)
        fieldType := field.Type()
        if !field.CanSet() </span><span class="cov0" title="0">{
                return exception.New("hit a field we can't set: '" + c.FieldName + "', did you forget to pass the object as a reference?")
        }</span>

        <span class="cov8" title="1">valueReflected := reflectValue(value)
        if !valueReflected.IsValid() </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if c.IsJSON </span><span class="cov8" title="1">{
                valueAsString, ok := valueReflected.Interface().(string)
                if ok &amp;&amp; len(valueAsString) != 0 </span><span class="cov8" title="1">{
                        fieldAddr := field.Addr().Interface()
                        jsonErr := json.Unmarshal([]byte(valueAsString), fieldAddr)
                        if jsonErr != nil </span><span class="cov0" title="0">{
                                return exception.Wrap(jsonErr)
                        }</span>
                        <span class="cov8" title="1">field.Set(reflect.ValueOf(fieldAddr).Elem())</span>
                }
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">if valueReflected.Type().AssignableTo(fieldType) </span><span class="cov8" title="1">{
                if field.Kind() == reflect.Ptr &amp;&amp; valueReflected.CanAddr() </span><span class="cov0" title="0">{
                        field.Set(valueReflected.Addr())
                }</span> else<span class="cov8" title="1"> {
                        field.Set(valueReflected)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">if field.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                if valueReflected.CanAddr() </span><span class="cov8" title="1">{
                        if fieldType.Elem() == valueReflected.Type() </span><span class="cov8" title="1">{
                                field.Set(valueReflected.Addr())
                        }</span> else<span class="cov0" title="0"> {
                                convertedValue := valueReflected.Convert(fieldType.Elem())
                                if convertedValue.CanAddr() </span><span class="cov0" title="0">{
                                        field.Set(convertedValue.Addr())
                                }</span>
                        }
                        <span class="cov8" title="1">return nil</span>
                }

                <span class="cov0" title="0">return exception.Newf("Cannot take address of value: %#v", value)</span>
        }

        <span class="cov8" title="1">convertedValue := valueReflected.Convert(fieldType)
        field.Set(convertedValue)

        return nil</span>
}

// GetValue returns the value for a column on a given database mapped object.
func (c Column) GetValue(object DatabaseMapped) interface{} <span class="cov8" title="1">{
        value := reflectValue(object)
        valueField := value.Field(c.Index)
        return valueField.Interface()
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">package db

import (
        "encoding/json"
        "fmt"
        "reflect"
        "strings"
        "sync"

        "github.com/blend/go-sdk/util"
)

var (
        metaCacheLock sync.Mutex
        metaCache     map[string]*ColumnCollection
)

// --------------------------------------------------------------------------------
// Utility
// --------------------------------------------------------------------------------

// ColumnNamesCSV returns a csv of column names.
func ColumnNamesCSV(object DatabaseMapped) string <span class="cov0" title="0">{
        return getCachedColumnCollectionFromInstance(object).ColumnNamesCSV()
}</span>

// Columns returns the cached column metadata for an object.
func Columns(object DatabaseMapped) *ColumnCollection <span class="cov0" title="0">{
        return getCachedColumnCollectionFromInstance(object)
}</span>

// --------------------------------------------------------------------------------
// Column Collection
// --------------------------------------------------------------------------------
// func NewColumnCollection() *ColumnCollection { return &amp;ColumnCollection{lookup: map[string]*Column} }

// newColumnCollectionWithPrefix makes a new column collection with a column prefix.
func newColumnCollectionWithPrefix(columnPrefix string) *ColumnCollection <span class="cov8" title="1">{
        return &amp;ColumnCollection{lookup: map[string]*Column{}, columnPrefix: columnPrefix}
}</span>

// newColumnCollectionFromColumns creates a column lookup for a slice of columns.
func newColumnCollectionFromColumns(columns []Column) *ColumnCollection <span class="cov8" title="1">{
        cc := ColumnCollection{columns: columns}
        lookup := make(map[string]*Column)
        for i := 0; i &lt; len(columns); i++ </span><span class="cov8" title="1">{
                col := &amp;columns[i]
                lookup[col.ColumnName] = col
        }</span>
        <span class="cov8" title="1">cc.lookup = lookup
        return &amp;cc</span>
}

// newColumnCollectionWithPrefixFromColumns creates a column lookup for a slice of columns.
func newColumnCollectionWithPrefixFromColumns(prefix string, columns []Column) *ColumnCollection <span class="cov8" title="1">{
        cc := ColumnCollection{columns: columns, columnPrefix: prefix}
        lookup := make(map[string]*Column)
        for i := 0; i &lt; len(columns); i++ </span><span class="cov8" title="1">{
                col := &amp;columns[i]
                lookup[col.ColumnName] = col
        }</span>
        <span class="cov8" title="1">cc.lookup = lookup
        return &amp;cc</span>
}

// newColumnCacheKey creates a cache key for a type.
func newColumnCacheKey(objectType reflect.Type) string <span class="cov8" title="1">{
        typeName := objectType.String()
        instance := reflect.New(objectType).Interface()
        if typed, isTyped := instance.(TableNameProvider); isTyped </span><span class="cov8" title="1">{
                return typeName + "_" + typed.TableName()
        }</span>
        <span class="cov8" title="1">return typeName</span>
}

// getCachedColumnCollectionFromInstance reflects an object instance into a new column collection.
func getCachedColumnCollectionFromInstance(object interface{}) *ColumnCollection <span class="cov8" title="1">{
        objectType := reflect.TypeOf(object)
        return getCachedColumnCollectionFromType(newColumnCacheKey(objectType), objectType)
}</span>

// getCachedColumnCollectionFromType reflects a reflect.Type into a column collection.
// The results of this are cached for speed.
func getCachedColumnCollectionFromType(identifier string, t reflect.Type) *ColumnCollection <span class="cov8" title="1">{
        metaCacheLock.Lock()
        defer metaCacheLock.Unlock()

        if metaCache == nil </span><span class="cov8" title="1">{
                metaCache = map[string]*ColumnCollection{}
        }</span>

        <span class="cov8" title="1">cachedMeta, ok := metaCache[identifier]
        if !ok </span><span class="cov8" title="1">{
                metadata := generateColumnCollectionForType(t)
                metaCache[identifier] = metadata
                return metadata
        }</span>
        <span class="cov8" title="1">return cachedMeta</span>
}

// GenerateColumnCollectionForType reflects a new column collection from a reflect.Type.
func generateColumnCollectionForType(t reflect.Type) *ColumnCollection <span class="cov8" title="1">{
        for t.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                t = t.Elem()
        }</span>

        <span class="cov8" title="1">tableName := TableNameByType(t)
        numFields := t.NumField()

        var cols []Column
        for index := 0; index &lt; numFields; index++ </span><span class="cov8" title="1">{
                field := t.Field(index)
                if !field.Anonymous </span><span class="cov8" title="1">{
                        col := NewColumnFromFieldTag(field)
                        if col != nil </span><span class="cov8" title="1">{
                                col.Index = index
                                col.TableName = tableName
                                cols = append(cols, *col)
                        }</span>
                }
        }

        <span class="cov8" title="1">return newColumnCollectionFromColumns(cols)</span>
}

// ColumnCollection represents the column metadata for a given struct.
type ColumnCollection struct {
        columns      []Column
        lookup       map[string]*Column
        columnPrefix string

        serials        *ColumnCollection
        notSerials     *ColumnCollection
        readOnly       *ColumnCollection
        notReadOnly    *ColumnCollection
        primaryKeys    *ColumnCollection
        notPrimaryKeys *ColumnCollection
        writeColumns   *ColumnCollection
        updateColumns  *ColumnCollection
}

// Len returns the number of columns.
func (cc *ColumnCollection) Len() int <span class="cov8" title="1">{
        return len(cc.columns)
}</span>

// Add adds a column.
func (cc *ColumnCollection) Add(c Column) <span class="cov8" title="1">{
        cc.columns = append(cc.columns, c)
        cc.lookup[c.ColumnName] = &amp;c
}</span>

// Remove removes a column (by column name) from the collection.
func (cc *ColumnCollection) Remove(columnName string) <span class="cov8" title="1">{
        var newColumns []Column
        for _, c := range cc.columns </span><span class="cov8" title="1">{
                if c.ColumnName != columnName </span><span class="cov8" title="1">{
                        newColumns = append(newColumns, c)
                }</span>
        }
        <span class="cov8" title="1">cc.columns = newColumns
        delete(cc.lookup, columnName)</span>
}

// HasColumn returns if a column name is present in the collection.
func (cc *ColumnCollection) HasColumn(columnName string) bool <span class="cov8" title="1">{
        _, hasColumn := cc.lookup[columnName]
        return hasColumn
}</span>

// Copy creates a new column collection instance and carries over an existing column prefix.
func (cc ColumnCollection) Copy() *ColumnCollection <span class="cov8" title="1">{
        return newColumnCollectionWithPrefixFromColumns(cc.columnPrefix, cc.columns)
}</span>

// CopyWithColumnPrefix applies a column prefix to column names and returns a new column collection.
func (cc ColumnCollection) CopyWithColumnPrefix(prefix string) *ColumnCollection <span class="cov8" title="1">{
        return newColumnCollectionWithPrefixFromColumns(prefix, cc.columns)
}</span>

// WriteColumns are non-serial, non-primary key, non-readonly columns.
func (cc *ColumnCollection) WriteColumns() *ColumnCollection <span class="cov8" title="1">{
        if cc.writeColumns != nil </span><span class="cov8" title="1">{
                return cc.writeColumns
        }</span>

        <span class="cov8" title="1">cc.writeColumns = cc.NotReadOnly().NotSerials().NotPrimaryKeys()
        return cc.writeColumns</span>
}

// UpdateColumns are non-readonly, non-serial columns.
func (cc *ColumnCollection) UpdateColumns() *ColumnCollection <span class="cov8" title="1">{
        if cc.updateColumns != nil </span><span class="cov8" title="1">{
                return cc.updateColumns
        }</span>

        <span class="cov8" title="1">cc.updateColumns = cc.NotReadOnly().NotPrimaryKeys().ConcatWith(cc.PrimaryKeys())
        return cc.updateColumns</span>
}

// PrimaryKeys are columns we use as where predicates and can't update.
func (cc *ColumnCollection) PrimaryKeys() *ColumnCollection <span class="cov8" title="1">{
        if cc.primaryKeys != nil </span><span class="cov8" title="1">{
                return cc.primaryKeys
        }</span>

        <span class="cov8" title="1">newCC := newColumnCollectionWithPrefix(cc.columnPrefix)
        for _, c := range cc.columns </span><span class="cov8" title="1">{
                if c.IsPrimaryKey </span><span class="cov8" title="1">{
                        newCC.Add(c)
                }</span>
        }

        <span class="cov8" title="1">cc.primaryKeys = newCC
        return cc.primaryKeys</span>
}

// NotPrimaryKeys are columns we can update.
func (cc *ColumnCollection) NotPrimaryKeys() *ColumnCollection <span class="cov8" title="1">{
        if cc.notPrimaryKeys != nil </span><span class="cov8" title="1">{
                return cc.notPrimaryKeys
        }</span>

        <span class="cov8" title="1">newCC := newColumnCollectionWithPrefix(cc.columnPrefix)

        for _, c := range cc.columns </span><span class="cov8" title="1">{
                if !c.IsPrimaryKey </span><span class="cov8" title="1">{
                        newCC.Add(c)
                }</span>
        }

        <span class="cov8" title="1">cc.notPrimaryKeys = newCC
        return cc.notPrimaryKeys</span>
}

// Serials are columns we have to return the id of.
func (cc *ColumnCollection) Serials() *ColumnCollection <span class="cov8" title="1">{
        if cc.serials != nil </span><span class="cov8" title="1">{
                return cc.serials
        }</span>

        <span class="cov8" title="1">newCC := newColumnCollectionWithPrefix(cc.columnPrefix)

        for _, c := range cc.columns </span><span class="cov8" title="1">{
                if c.IsSerial </span><span class="cov8" title="1">{
                        newCC.Add(c)
                }</span>
        }

        <span class="cov8" title="1">cc.serials = newCC
        return cc.serials</span>
}

// NotSerials are columns we don't have to return the id of.
func (cc *ColumnCollection) NotSerials() *ColumnCollection <span class="cov8" title="1">{
        if cc.notSerials != nil </span><span class="cov8" title="1">{
                return cc.notSerials
        }</span>

        <span class="cov8" title="1">newCC := newColumnCollectionWithPrefix(cc.columnPrefix)

        for _, c := range cc.columns </span><span class="cov8" title="1">{
                if !c.IsSerial </span><span class="cov8" title="1">{
                        newCC.Add(c)
                }</span>
        }
        <span class="cov8" title="1">cc.notSerials = newCC
        return cc.notSerials</span>
}

// ReadOnly are columns that we don't have to insert upon Create().
func (cc *ColumnCollection) ReadOnly() *ColumnCollection <span class="cov8" title="1">{
        if cc.readOnly != nil </span><span class="cov0" title="0">{
                return cc.readOnly
        }</span>

        <span class="cov8" title="1">newCC := newColumnCollectionWithPrefix(cc.columnPrefix)

        for _, c := range cc.columns </span><span class="cov8" title="1">{
                if c.IsReadOnly </span><span class="cov8" title="1">{
                        newCC.Add(c)
                }</span>
        }

        <span class="cov8" title="1">cc.readOnly = newCC
        return cc.readOnly</span>
}

// NotReadOnly are columns that we have to insert upon Create().
func (cc *ColumnCollection) NotReadOnly() *ColumnCollection <span class="cov8" title="1">{
        if cc.notReadOnly != nil </span><span class="cov8" title="1">{
                return cc.notReadOnly
        }</span>

        <span class="cov8" title="1">newCC := newColumnCollectionWithPrefix(cc.columnPrefix)

        for _, c := range cc.columns </span><span class="cov8" title="1">{
                if !c.IsReadOnly </span><span class="cov8" title="1">{
                        newCC.Add(c)
                }</span>
        }

        <span class="cov8" title="1">cc.notReadOnly = newCC
        return cc.notReadOnly</span>
}

// ColumnNames returns the string names for all the columns in the collection.
func (cc ColumnCollection) ColumnNames() []string <span class="cov8" title="1">{
        names := make([]string, len(cc.columns))
        for x := 0; x &lt; len(cc.columns); x++ </span><span class="cov8" title="1">{
                c := cc.columns[x]
                if len(cc.columnPrefix) != 0 </span><span class="cov0" title="0">{
                        names[x] = fmt.Sprintf("%s%s", cc.columnPrefix, c.ColumnName)
                }</span> else<span class="cov8" title="1"> {
                        names[x] = c.ColumnName
                }</span>
        }
        <span class="cov8" title="1">return names</span>
}

// Columns returns the colummns
func (cc *ColumnCollection) Columns() []Column <span class="cov8" title="1">{
        return cc.columns
}</span>

// Lookup gets the column name lookup.
func (cc *ColumnCollection) Lookup() map[string]*Column <span class="cov8" title="1">{
        if len(cc.columnPrefix) != 0 </span><span class="cov0" title="0">{
                lookup := map[string]*Column{}
                for key, value := range cc.lookup </span><span class="cov0" title="0">{
                        lookup[fmt.Sprintf("%s%s", cc.columnPrefix, key)] = value
                }</span>
                <span class="cov0" title="0">return lookup</span>
        }
        <span class="cov8" title="1">return cc.lookup</span>
}

// ColumnNamesFromAlias returns the string names for all the columns in the collection.
func (cc ColumnCollection) ColumnNamesFromAlias(tableAlias string) []string <span class="cov0" title="0">{
        names := make([]string, len(cc.columns))
        for x := 0; x &lt; len(cc.columns); x++ </span><span class="cov0" title="0">{
                c := cc.columns[x]
                if len(cc.columnPrefix) != 0 </span><span class="cov0" title="0">{
                        names[x] = fmt.Sprintf("%s.%s as %s%s", tableAlias, c.ColumnName, cc.columnPrefix, c.ColumnName)
                }</span> else<span class="cov0" title="0"> {
                        names[x] = fmt.Sprintf("%s.%s", tableAlias, c.ColumnName)
                }</span>
        }
        <span class="cov0" title="0">return names</span>
}

// ColumnNamesCSVFromAlias returns the string names for all the columns in the collection.
func (cc ColumnCollection) ColumnNamesCSVFromAlias(tableAlias string) string <span class="cov0" title="0">{
        names := make([]string, len(cc.columns))
        for x := 0; x &lt; len(cc.columns); x++ </span><span class="cov0" title="0">{
                c := cc.columns[x]
                if len(cc.columnPrefix) != 0 </span><span class="cov0" title="0">{
                        names[x] = fmt.Sprintf("%s.%s as %s%s", tableAlias, c.ColumnName, cc.columnPrefix, c.ColumnName)
                }</span> else<span class="cov0" title="0"> {
                        names[x] = fmt.Sprintf("%s.%s", tableAlias, c.ColumnName)
                }</span>
        }
        <span class="cov0" title="0">return util.String.CSV(names)</span>
}

// ColumnValues returns the reflected value for all the columns on a given instance.
func (cc ColumnCollection) ColumnValues(instance interface{}) []interface{} <span class="cov8" title="1">{
        value := reflectValue(instance)

        values := make([]interface{}, len(cc.columns))
        for x := 0; x &lt; len(cc.columns); x++ </span><span class="cov8" title="1">{
                c := cc.columns[x]
                valueField := value.FieldByName(c.FieldName)
                if c.IsJSON </span><span class="cov0" title="0">{
                        toSerialize := valueField.Interface()
                        jsonBytes, _ := json.Marshal(toSerialize)
                        values[x] = string(jsonBytes)
                }</span> else<span class="cov8" title="1"> {
                        values[x] = valueField.Interface()
                }</span>
        }
        <span class="cov8" title="1">return values</span>
}

// FirstOrDefault returns the first column in the collection or `nil` if the collection is empty.
func (cc ColumnCollection) FirstOrDefault() *Column <span class="cov8" title="1">{
        if len(cc.columns) &gt; 0 </span><span class="cov8" title="1">{
                return &amp;cc.columns[0]
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ConcatWith merges a collection with another collection.
func (cc ColumnCollection) ConcatWith(other *ColumnCollection) *ColumnCollection <span class="cov8" title="1">{
        total := make([]Column, len(cc.columns)+len(other.columns))
        var x int
        for ; x &lt; len(cc.columns); x++ </span><span class="cov8" title="1">{
                total[x] = cc.columns[x]
        }</span>
        <span class="cov8" title="1">for y := 0; y &lt; len(other.columns); y++ </span><span class="cov8" title="1">{
                total[x+y] = other.columns[y]
        }</span>
        <span class="cov8" title="1">return newColumnCollectionFromColumns(total)</span>
}

func (cc ColumnCollection) String() string <span class="cov0" title="0">{
        return strings.Join(cc.ColumnNames(), ", ")
}</span>

// ColumnNamesCSV returns a csv of column names.
func (cc ColumnCollection) ColumnNamesCSV() string <span class="cov0" title="0">{
        return util.String.CSV(cc.ColumnNames())
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package db

import (
        "fmt"
        "net/url"
        "strings"
        "time"

        "github.com/blend/go-sdk/env"
        "github.com/blend/go-sdk/exception"
        "github.com/blend/go-sdk/util"
        "github.com/lib/pq"
)

const (
        // EnvVarDatabaseURL is an environment variable.
        EnvVarDatabaseURL = "DATABASE_URL"

        // DefaultHost is the default database hostname, typically used
        // when developing locally.
        DefaultHost = "localhost"
        // DefaultPort is the default postgres port.
        DefaultPort = "5432"
        // DefaultDatabase is the default database to connect to, we use
        // `postgres` to not pollute the template databases.
        DefaultDatabase = "postgres"
        // DefaultSSLMode is the default connection ssl mode.
        // We use `disable` because typical dev installs do not provision certs.
        DefaultSSLMode = SSLModeDisable

        // SSLModeDisable is an ssl mode.
        // Postgres Docs: "I don't care about security, and I don't want to pay the overhead of encryption."
        SSLModeDisable = "disable"
        // SSLModeAllow is an ssl mode.
        // Postgres Docs: "I don't care about security, but I will pay the overhead of encryption if the server insists on it."
        SSLModeAllow = "allow"
        // SSLModePrefer is an ssl mode.
        // Postgres Docs: "I don't care about encryption, but I wish to pay the overhead of encryption if the server supports it"
        SSLModePrefer = "prefer"
        // SSLModeRequire is an ssl mode.
        // Postgres Docs: "I want my data to be encrypted, and I accept the overhead. I trust that the network will make sure I always connect to the server I want."
        SSLModeRequire = "require"
        // SSLModeVerifyCA is an ssl mode.
        // Postgres Docs: "I want my data encrypted, and I accept the overhead. I want to be sure that I connect to a server that I trust."
        SSLModeVerifyCA = "verify-ca"
        // SSLModeVerifyFull is an ssl mode.
        // Postgres Docs: "I want my data encrypted, and I accept the overhead. I want to be sure that I connect to a server I trust, and that it's the one I specify."
        SSLModeVerifyFull = "verify-full"

        // DefaultUseStatementCache is the default if we should enable the statement cache.
        DefaultUseStatementCache = true
        // DefaultIdleConnections is the default number of idle connections.
        DefaultIdleConnections = 16
        // DefaultMaxConnections is the default maximum number of connections.
        DefaultMaxConnections = 32
        // DefaultMaxLifetime is the default maximum lifetime of driver connections.
        DefaultMaxLifetime time.Duration = 0
        // DefaultBufferPoolSize is the default number of buffer pool entries to maintain.
        DefaultBufferPoolSize = 1024
)

// NewConfig creates a new config.
func NewConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{}
}</span>

// NewConfigFromDSN creates a new config from a dsn.
func NewConfigFromDSN(dsn string) (*Config, error) <span class="cov8" title="1">{
        parsed, err := pq.ParseURL(dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>

        <span class="cov8" title="1">var config Config
        pieces := util.String.SplitOnSpace(parsed)
        for _, piece := range pieces </span><span class="cov8" title="1">{
                if strings.HasPrefix(piece, "host=") </span><span class="cov8" title="1">{
                        config.Host = strings.TrimPrefix(piece, "host=")
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(piece, "port=") </span><span class="cov8" title="1">{
                        config.Port = strings.TrimPrefix(piece, "port=")
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(piece, "dbname=") </span><span class="cov8" title="1">{
                        config.Database = strings.TrimPrefix(piece, "dbname=")
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(piece, "user=") </span><span class="cov0" title="0">{
                        config.Username = strings.TrimPrefix(piece, "user=")
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(piece, "password=") </span><span class="cov0" title="0">{
                        config.Password = strings.TrimPrefix(piece, "password=")
                }</span> else<span class="cov8" title="1"> if strings.HasPrefix(piece, "sslmode=") </span><span class="cov8" title="1">{
                        config.SSLMode = strings.TrimPrefix(piece, "sslmode=")
                }</span>
        }
        <span class="cov8" title="1">return &amp;config, nil</span>
}

// NewConfigFromEnv returns a new config from the environment.
// The environment variable mappings are as follows:
//        -        DATABSE_URL         = DSN         //note that this has precedence over other vars (!!)
//         -        DB_HOST                 = Host
//        -        DB_PORT                 = Port
//        -         DB_NAME                 = Database
//        -        DB_SCHEMA                = Schema
//        -        DB_USER                 = Username
//        -        DB_PASSWORD         = Password
//        -        DB_SSLMODE                 = SSLMode
func NewConfigFromEnv() *Config <span class="cov8" title="1">{
        var config Config
        env.Env().ReadInto(&amp;config)
        return &amp;config
}</span>

// Config is a set of connection config options.
type Config struct {
        // DSN is a fully formed DSN (this skips DSN formation from all other variables outside `schema`).
        DSN string `json:"dsn" yaml:"dsn" env:"DATABASE_URL"`
        // Host is the server to connect to.
        Host string `json:"host" yaml:"host" env:"DB_HOST"`
        // Port is the port to connect to.
        Port string `json:"port" yaml:"port" env:"DB_PORT"`
        // DBName is the database name
        Database string `json:"database" yaml:"database" env:"DB_NAME"`
        // Schema is the application schema within the database, defaults to `public`.
        Schema string `json:"schema" yaml:"schema" env:"DB_SCHEMA"`
        // Username is the username for the connection via password auth.
        Username string `json:"username" yaml:"username" env:"DB_USER"`
        // Password is the password for the connection via password auth.
        Password string `json:"password" yaml:"password" env:"DB_PASSWORD"`
        // SSLMode is the sslmode for the connection.
        SSLMode string `json:"sslMode" yaml:"sslMode" env:"DB_SSLMODE"`
        // UseStatementCache indicates if we should use the prepared statement cache.
        UseStatementCache *bool `json:"useStatementCache" yaml:"useStatementCache" env:"DB_USE_STATEMENT_CACHE"`
        // IdleConnections is the number of idle connections.
        IdleConnections int `json:"idleConnections" yaml:"idleConnections" env:"DB_IDLE_CONNECTIONS"`
        // MaxConnections is the maximum number of connections.
        MaxConnections int `json:"maxConnections" yaml:"maxConnections" env:"DB_MAX_CONNECTIONS"`
        // MaxLifetime is the maximum time a connection can be open.
        MaxLifetime time.Duration `json:"maxLifetime" yaml:"maxLifetime" env:"DB_MAX_LIFETIME"`
        // BufferPoolSize is the number of query composition buffers to maintain.
        BufferPoolSize int `json:"bufferPoolSize" yaml:"bufferPoolSize" env:"DB_BUFFER_POOL_SIZE"`
}

// WithDSN sets the config dsn and returns a reference to the config.
func (c *Config) WithDSN(dsn string) *Config <span class="cov0" title="0">{
        c.DSN = dsn
        return c
}</span>

// WithHost sets the config host and returns a reference to the config.
func (c *Config) WithHost(host string) *Config <span class="cov0" title="0">{
        c.Host = host
        return c
}</span>

// WithPort sets the config host and returns a reference to the config.
func (c *Config) WithPort(port string) *Config <span class="cov0" title="0">{
        c.Port = port
        return c
}</span>

// WithDatabase sets the config database and returns a reference to the config.
func (c *Config) WithDatabase(database string) *Config <span class="cov0" title="0">{
        c.Database = database
        return c
}</span>

// WithSchema sets the config schema and returns a reference to the config.
func (c *Config) WithSchema(schema string) *Config <span class="cov0" title="0">{
        c.Schema = schema
        return c
}</span>

// WithUsername sets the config username and returns a reference to the config.
func (c *Config) WithUsername(username string) *Config <span class="cov0" title="0">{
        c.Username = username
        return c
}</span>

// WithPassword sets the config password and returns a reference to the config.
func (c *Config) WithPassword(password string) *Config <span class="cov0" title="0">{
        c.Password = password
        return c
}</span>

// WithSSLMode sets the config sslMode and returns a reference to the config.
func (c *Config) WithSSLMode(sslMode string) *Config <span class="cov0" title="0">{
        c.SSLMode = sslMode
        return c
}</span>

// GetDSN returns the postgres dsn (fully quallified url) for the config.
// If unset, it's generated from the host, port and database.
func (c Config) GetDSN(inherited ...string) string <span class="cov8" title="1">{
        return util.Coalesce.String(c.DSN, "", inherited...)
}</span>

// GetHost returns the postgres host for the connection or a default.
func (c Config) GetHost(inherited ...string) string <span class="cov8" title="1">{
        return util.Coalesce.String(c.Host, DefaultHost, inherited...)
}</span>

// GetPort returns the port for a connection if it is not the standard postgres port.
func (c Config) GetPort(inherited ...string) string <span class="cov8" title="1">{
        return util.Coalesce.String(c.Port, DefaultPort, inherited...)
}</span>

// GetDatabase returns the connection database or a default.
func (c Config) GetDatabase(inherited ...string) string <span class="cov8" title="1">{
        return util.Coalesce.String(c.Database, DefaultDatabase, inherited...)
}</span>

// GetSchema returns the connection schema or a default.
func (c Config) GetSchema(inherited ...string) string <span class="cov8" title="1">{
        return util.Coalesce.String(c.Schema, "", inherited...)
}</span>

// GetUsername returns the connection username or a default.
func (c Config) GetUsername(inherited ...string) string <span class="cov8" title="1">{
        return util.Coalesce.String(c.Username, "", inherited...)
}</span>

// GetPassword returns the connection password or a default.
func (c Config) GetPassword(inherited ...string) string <span class="cov8" title="1">{
        return util.Coalesce.String(c.Password, "", inherited...)
}</span>

// GetSSLMode returns the connection ssl mode or a default.
func (c Config) GetSSLMode(inherited ...string) string <span class="cov8" title="1">{
        return util.Coalesce.String(c.SSLMode, DefaultSSLMode, inherited...)
}</span>

// GetUseStatementCache returns if we should enable the statement cache or a default.
func (c Config) GetUseStatementCache(inherited ...bool) bool <span class="cov8" title="1">{
        return util.Coalesce.Bool(c.UseStatementCache, DefaultUseStatementCache, inherited...)
}</span>

// GetIdleConnections returns the number of idle connections or a default.
func (c Config) GetIdleConnections(inherited ...int) int <span class="cov8" title="1">{
        return util.Coalesce.Int(c.IdleConnections, DefaultIdleConnections, inherited...)
}</span>

// GetMaxConnections returns the maximum number of connections or a default.
func (c Config) GetMaxConnections(inherited ...int) int <span class="cov8" title="1">{
        return util.Coalesce.Int(c.MaxConnections, DefaultMaxConnections, inherited...)
}</span>

// GetMaxLifetime returns the maximum lifetime of a driver connection.
func (c Config) GetMaxLifetime(inherited ...time.Duration) time.Duration <span class="cov8" title="1">{
        return util.Coalesce.Duration(c.MaxLifetime, DefaultMaxLifetime, inherited...)
}</span>

// GetBufferPoolSize returns the number of query buffers to maintain or a default.
func (c Config) GetBufferPoolSize(inherited ...int) int <span class="cov8" title="1">{
        return util.Coalesce.Int(c.BufferPoolSize, DefaultBufferPoolSize, inherited...)
}</span>

// CreateDSN creates a postgres connection string from the config.
func (c Config) CreateDSN() string <span class="cov8" title="1">{
        if len(c.GetDSN()) != 0 </span><span class="cov8" title="1">{
                return c.GetDSN()
        }</span>

        <span class="cov8" title="1">var sslMode string
        if len(c.GetSSLMode()) &gt; 0 </span><span class="cov8" title="1">{
                sslMode = fmt.Sprintf("?sslmode=%s", url.QueryEscape(c.GetSSLMode()))
        }</span>

        <span class="cov8" title="1">var port string
        if len(c.GetPort()) &gt; 0 </span><span class="cov8" title="1">{
                port = fmt.Sprintf(":%s", c.GetPort())
        }</span>

        <span class="cov8" title="1">if len(c.GetUsername()) &gt; 0 </span><span class="cov8" title="1">{
                if len(c.GetPassword()) &gt; 0 </span><span class="cov8" title="1">{
                        return fmt.Sprintf("postgres://%s:%s@%s%s/%s%s", url.QueryEscape(c.GetUsername()), url.QueryEscape(c.GetPassword()), c.GetHost(), port, c.GetDatabase(), sslMode)
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("postgres://%s@%s%s/%s%s", url.QueryEscape(c.GetUsername()), c.GetHost(), port, c.GetDatabase(), sslMode)</span>
        }
        <span class="cov8" title="1">return fmt.Sprintf("postgres://%s%s/%s%s", c.GetHost(), port, c.GetDatabase(), sslMode)</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Package db providers a basic abstraction layer above normal database/sql that makes it easier to
// interact with the database and organize database related code. It is not intended to replace actual sql
// (you write queries yourself).
package db

import (
        "database/sql"
        "fmt"
        "sync"
        "time"

        "github.com/blend/go-sdk/exception"
        "github.com/blend/go-sdk/logger"

        // PQ is the postgres driver
        _ "github.com/lib/pq"
)

const (
        //DBNilError is a common error
        DBNilError = "connection is nil"
)

const (
        runeComma   = rune(',')
        runeNewline = rune('\n')
        runeTab     = rune('\t')
        runeSpace   = rune(' ')
)

// --------------------------------------------------------------------------------
// Connection
// --------------------------------------------------------------------------------

// New returns a new Connection.
func New() *Connection <span class="cov0" title="0">{
        return &amp;Connection{
                Config:             &amp;Config{},
                bufferPool:         NewBufferPool(DefaultBufferPoolSize),
                useStatementCache:  DefaultUseStatementCache,
                statementCacheLock: &amp;sync.Mutex{},
                connectionLock:     &amp;sync.Mutex{},
        }
}</span>

// NewFromConfig returns a new connection from a config.
func NewFromConfig(cfg *Config) *Connection <span class="cov8" title="1">{
        return &amp;Connection{
                Config:             cfg,
                bufferPool:         NewBufferPool(cfg.GetBufferPoolSize()),
                useStatementCache:  cfg.GetUseStatementCache(), //doesnt actually help perf, maybe someday.
                statementCacheLock: &amp;sync.Mutex{},
                connectionLock:     &amp;sync.Mutex{},
        }
}</span>

// NewFromEnv creates a new db connection from environment variables.
func NewFromEnv() *Connection <span class="cov8" title="1">{
        return NewFromConfig(NewConfigFromEnv())
}</span>

// Connection is the basic wrapper for connection parameters and saves a reference to the created sql.Connection.
type Connection struct {
        // Connection is the underlying sql driver connection for the Connection.
        Connection *sql.DB
        Config     *Config

        connectionLock     *sync.Mutex
        statementCacheLock *sync.Mutex

        bufferPool *BufferPool
        log        *logger.Logger

        useStatementCache bool
        statementCache    *StatementCache

        // database is used for logging.
        database string
}

// Database returns the connected database name.
func (dbc *Connection) Database() string <span class="cov8" title="1">{
        return dbc.database
}</span>

// Close implements a closer.
func (dbc *Connection) Close() error <span class="cov8" title="1">{
        var err error
        if dbc.statementCache != nil </span><span class="cov8" title="1">{
                err = dbc.statementCache.Close()
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return dbc.Connection.Close()</span>
}

// WithLogger sets the connection's diagnostic agent.
func (dbc *Connection) WithLogger(log *logger.Logger) <span class="cov0" title="0">{
        dbc.log = log
}</span>

// Logger returns the diagnostics agent.
func (dbc *Connection) Logger() *logger.Logger <span class="cov0" title="0">{
        return dbc.log
}</span>

func (dbc *Connection) fireEvent(flag logger.Flag, query string, elapsed time.Duration, err error, optionalQueryLabel ...string) <span class="cov0" title="0">{
        if dbc.log != nil </span><span class="cov0" title="0">{
                var queryLabel string
                if len(optionalQueryLabel) &gt; 0 </span><span class="cov0" title="0">{
                        queryLabel = optionalQueryLabel[0]
                }</span>

                <span class="cov0" title="0">dbc.log.Trigger(logger.NewQueryEvent(query, elapsed).WithFlag(flag).WithDatabase(dbc.database).WithQueryLabel(queryLabel).WithEngine("postgres"))
                if err != nil </span><span class="cov0" title="0">{
                        dbc.log.Error(err)
                }</span>
        }
}

// EnableStatementCache opts to cache statements for the connection.
func (dbc *Connection) EnableStatementCache() <span class="cov8" title="1">{
        dbc.useStatementCache = true
}</span>

// DisableStatementCache opts to not use the statement cache.
func (dbc *Connection) DisableStatementCache() <span class="cov0" title="0">{
        dbc.useStatementCache = false
}</span>

// WithUseStatementCache returns if we should use the statement cache.
func (dbc *Connection) WithUseStatementCache(enabled bool) *Connection <span class="cov0" title="0">{
        dbc.useStatementCache = enabled
        return dbc
}</span>

// StatementCache returns the statement cache.
func (dbc *Connection) StatementCache() *StatementCache <span class="cov8" title="1">{
        return dbc.statementCache
}</span>

// openNewSQLConnection returns a new connection object.
func (dbc *Connection) openNewSQLConnection() (*sql.DB, error) <span class="cov8" title="1">{
        if dbc.Config == nil </span><span class="cov0" title="0">{
                return nil, exception.New("connection configuration is unset")
        }</span>

        // the config resolution step is a little weird
        // first, fully synthesize the dsn
        // as it can be set directly or composed from individual fields
        <span class="cov8" title="1">dsn := dbc.Config.CreateDSN()
        // then re-parse it to get relevant fields we might want to save
        // like the database name etc.
        parsed, err := NewConfigFromDSN(dsn)
        if err != nil </span><span class="cov0" title="0">{
                exception.Wrap(err)
        }</span>

        // open the connection
        <span class="cov8" title="1">dbConn, err := sql.Open("postgres", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>

        // memoize the db name for logging calls
        <span class="cov8" title="1">dbc.database = parsed.GetDatabase()
        // action config points.
        dbConn.SetConnMaxLifetime(dbc.Config.GetMaxLifetime())
        dbConn.SetMaxIdleConns(dbc.Config.GetIdleConnections())
        dbConn.SetMaxOpenConns(dbc.Config.GetMaxConnections())

        schema := dbc.Config.GetSchema()
        if len(schema) &gt; 0 </span><span class="cov0" title="0">{
                _, err = dbConn.Exec(fmt.Sprintf("SET search_path TO %s,public;", schema))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, exception.Wrap(err)
                }</span>
        }

        // sanity check on the connection.
        <span class="cov8" title="1">_, err = dbConn.Exec("select 'ok!'")
        if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>

        <span class="cov8" title="1">return dbConn, nil</span>
}

// Open returns a connection object, either a cached connection object or creating a new one in the process.
func (dbc *Connection) Open() (*Connection, error) <span class="cov8" title="1">{
        if dbc.Connection == nil </span><span class="cov8" title="1">{
                dbc.connectionLock.Lock()
                defer dbc.connectionLock.Unlock()

                if dbc.Connection == nil </span><span class="cov8" title="1">{
                        newConn, err := dbc.openNewSQLConnection()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">dbc.Connection = newConn</span>
                }
        }
        <span class="cov8" title="1">return dbc, nil</span>
}

// Begin starts a new transaction.
func (dbc *Connection) Begin() (*sql.Tx, error) <span class="cov8" title="1">{
        if dbc.Connection != nil </span><span class="cov8" title="1">{
                tx, txErr := dbc.Connection.Begin()
                return tx, exception.Wrap(txErr)
        }</span>

        <span class="cov8" title="1">connection, err := dbc.Open()
        if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>
        <span class="cov8" title="1">tx, err := connection.Begin()
        return tx, exception.Wrap(err)</span>
}

// Prepare prepares a new statement for the connection.
func (dbc *Connection) Prepare(statement string, tx *sql.Tx) (*sql.Stmt, error) <span class="cov8" title="1">{
        if tx != nil </span><span class="cov8" title="1">{
                stmt, err := tx.Prepare(statement)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, exception.Wrap(err)
                }</span>
                <span class="cov8" title="1">return stmt, nil</span>
        }

        // open shared connection
        <span class="cov8" title="1">dbConn, err := dbc.Open()
        if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>

        <span class="cov8" title="1">stmt, err := dbConn.Connection.Prepare(statement)
        if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>
        <span class="cov8" title="1">return stmt, nil</span>
}

func (dbc *Connection) ensureStatementCache() error <span class="cov8" title="1">{
        if dbc.statementCache == nil </span><span class="cov8" title="1">{
                dbc.statementCacheLock.Lock()
                defer dbc.statementCacheLock.Unlock()
                if dbc.statementCache == nil </span><span class="cov8" title="1">{
                        db, err := dbc.Open()
                        if err != nil </span><span class="cov0" title="0">{
                                return exception.Wrap(err)
                        }</span>
                        <span class="cov8" title="1">dbc.statementCache = newStatementCache(db.Connection)</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// PrepareCached prepares a potentially cached statement.
func (dbc *Connection) PrepareCached(id, statement string, tx *sql.Tx) (*sql.Stmt, error) <span class="cov8" title="1">{
        if tx != nil </span><span class="cov8" title="1">{
                stmt, err := tx.Prepare(statement)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, exception.Wrap(err)
                }</span>
                <span class="cov8" title="1">return stmt, nil</span>
        }

        <span class="cov8" title="1">if dbc.useStatementCache </span><span class="cov8" title="1">{
                dbc.ensureStatementCache()
                return dbc.statementCache.Prepare(id, statement)
        }</span>
        <span class="cov0" title="0">return dbc.Prepare(statement, tx)</span>
}

// --------------------------------------------------------------------------------
// Invocation context
// --------------------------------------------------------------------------------

// DB returns a new db context.
func (dbc *Connection) DB(txs ...*sql.Tx) *DB <span class="cov0" title="0">{
        return &amp;DB{
                conn:       dbc,
                tx:         OptionalTx(txs...),
                fireEvents: dbc.log != nil,
        }
}</span>

// Invoke returns a new invocation.
func (dbc *Connection) Invoke(txs ...*sql.Tx) *Invocation <span class="cov8" title="1">{
        return &amp;Invocation{
                conn:       dbc,
                tx:         OptionalTx(txs...),
                fireEvents: dbc.log != nil,
        }
}</span>

// InTx is an alias to Invoke.
func (dbc *Connection) InTx(txs ...*sql.Tx) *Invocation <span class="cov0" title="0">{
        return dbc.Invoke(txs...)
}</span>

// --------------------------------------------------------------------------------
// Invocation Context Stubs
// --------------------------------------------------------------------------------

// Exec runs the statement without creating a QueryResult.
func (dbc *Connection) Exec(statement string, args ...interface{}) error <span class="cov8" title="1">{
        return dbc.ExecInTx(statement, nil, args...)
}</span>

// ExecWithCacheLabel runs the statement without creating a QueryResult.
func (dbc *Connection) ExecWithCacheLabel(statement, cacheLabel string, args ...interface{}) error <span class="cov0" title="0">{
        return dbc.ExecInTxWithCacheLabel(statement, cacheLabel, nil, args...)
}</span>

// ExecInTx runs a statement within a transaction.
func (dbc *Connection) ExecInTx(statement string, tx *sql.Tx, args ...interface{}) (err error) <span class="cov8" title="1">{
        return dbc.ExecInTxWithCacheLabel(statement, statement, tx, args...)
}</span>

// ExecInTxWithCacheLabel runs a statement within a transaction.
func (dbc *Connection) ExecInTxWithCacheLabel(statement, cacheLabel string, tx *sql.Tx, args ...interface{}) (err error) <span class="cov8" title="1">{
        return dbc.Invoke(tx).WithLabel(cacheLabel).Exec(statement, args...)
}</span>

// Query runs the selected statement and returns a Query.
func (dbc *Connection) Query(statement string, args ...interface{}) *Query <span class="cov8" title="1">{
        return dbc.QueryInTx(statement, nil, args...)
}</span>

// QueryInTx runs the selected statement in a transaction and returns a Query.
func (dbc *Connection) QueryInTx(statement string, tx *sql.Tx, args ...interface{}) (result *Query) <span class="cov8" title="1">{
        return dbc.Invoke(tx).Query(statement, args...)
}</span>

// Get returns a given object based on a group of primary key ids.
func (dbc *Connection) Get(object DatabaseMapped, ids ...interface{}) error <span class="cov0" title="0">{
        return dbc.GetInTx(object, nil, ids...)
}</span>

// GetInTx returns a given object based on a group of primary key ids within a transaction.
func (dbc *Connection) GetInTx(object DatabaseMapped, tx *sql.Tx, args ...interface{}) error <span class="cov8" title="1">{
        return dbc.Invoke(tx).Get(object, args...)
}</span>

// GetAll returns all rows of an object mapped table.
func (dbc *Connection) GetAll(collection interface{}) error <span class="cov0" title="0">{
        return dbc.GetAllInTx(collection, nil)
}</span>

// GetAllInTx returns all rows of an object mapped table wrapped in a transaction.
func (dbc *Connection) GetAllInTx(collection interface{}, tx *sql.Tx) error <span class="cov8" title="1">{
        return dbc.Invoke(tx).GetAll(collection)
}</span>

// Create writes an object to the database.
func (dbc *Connection) Create(object DatabaseMapped) error <span class="cov0" title="0">{
        return dbc.CreateInTx(object, nil)
}</span>

// CreateInTx writes an object to the database within a transaction.
func (dbc *Connection) CreateInTx(object DatabaseMapped, tx *sql.Tx) (err error) <span class="cov8" title="1">{
        return dbc.Invoke(tx).Create(object)
}</span>

// CreateIfNotExists writes an object to the database if it does not already exist.
func (dbc *Connection) CreateIfNotExists(object DatabaseMapped) error <span class="cov0" title="0">{
        return dbc.CreateIfNotExistsInTx(object, nil)
}</span>

// CreateIfNotExistsInTx writes an object to the database if it does not already exist within a transaction.
func (dbc *Connection) CreateIfNotExistsInTx(object DatabaseMapped, tx *sql.Tx) (err error) <span class="cov8" title="1">{
        return dbc.Invoke(tx).CreateIfNotExists(object)
}</span>

// CreateMany writes many an objects to the database.
func (dbc *Connection) CreateMany(objects interface{}) error <span class="cov0" title="0">{
        return dbc.CreateManyInTx(objects, nil)
}</span>

// CreateManyInTx writes many an objects to the database within a transaction.
func (dbc *Connection) CreateManyInTx(objects interface{}, tx *sql.Tx) (err error) <span class="cov8" title="1">{
        return dbc.Invoke(tx).CreateMany(objects)
}</span>

// Update updates an object.
func (dbc *Connection) Update(object DatabaseMapped) error <span class="cov0" title="0">{
        return dbc.UpdateInTx(object, nil)
}</span>

// UpdateInTx updates an object wrapped in a transaction.
func (dbc *Connection) UpdateInTx(object DatabaseMapped, tx *sql.Tx) (err error) <span class="cov8" title="1">{
        return dbc.Invoke(tx).Update(object)
}</span>

// Exists returns a bool if a given object exists (utilizing the primary key columns if they exist).
func (dbc *Connection) Exists(object DatabaseMapped) (bool, error) <span class="cov0" title="0">{
        return dbc.ExistsInTx(object, nil)
}</span>

// ExistsInTx returns a bool if a given object exists (utilizing the primary key columns if they exist) wrapped in a transaction.
func (dbc *Connection) ExistsInTx(object DatabaseMapped, tx *sql.Tx) (exists bool, err error) <span class="cov8" title="1">{
        return dbc.Invoke(tx).Exists(object)
}</span>

// Delete deletes an object from the database.
func (dbc *Connection) Delete(object DatabaseMapped) error <span class="cov0" title="0">{
        return dbc.DeleteInTx(object, nil)
}</span>

// DeleteInTx deletes an object from the database wrapped in a transaction.
func (dbc *Connection) DeleteInTx(object DatabaseMapped, tx *sql.Tx) (err error) <span class="cov8" title="1">{
        return dbc.Invoke(tx).Delete(object)
}</span>

// Upsert inserts the object if it doesn't exist already (as defined by its primary keys) or updates it.
func (dbc *Connection) Upsert(object DatabaseMapped) error <span class="cov0" title="0">{
        return dbc.UpsertInTx(object, nil)
}</span>

// UpsertInTx inserts the object if it doesn't exist already (as defined by its primary keys) or updates it wrapped in a transaction.
func (dbc *Connection) UpsertInTx(object DatabaseMapped, tx *sql.Tx) (err error) <span class="cov8" title="1">{
        return dbc.Invoke(tx).Upsert(object)
}</span>

// Truncate fully removes an tables rows in a single opertation.
func (dbc *Connection) Truncate(object DatabaseMapped) error <span class="cov0" title="0">{
        return dbc.TruncateInTx(object, nil)
}</span>

// TruncateInTx applies a truncation in a transaction.
func (dbc *Connection) TruncateInTx(object DatabaseMapped, tx *sql.Tx) error <span class="cov8" title="1">{
        return dbc.Invoke(tx).Truncate(object)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package db

import (
        "context"
        "database/sql"

        "github.com/blend/go-sdk/exception"
)

// NewDB returns a new DB.
func NewDB() *DB <span class="cov8" title="1">{
        return &amp;DB{}
}</span>

// DB represents a connection context.
// It rolls both the underlying connection and an optional tx into one struct.
// The motivation here is so that if you have datamanager functions they can be
// used across databases, and don't assume internally which db they talk to.
type DB struct {
        conn       *Connection
        ctx        context.Context
        tx         *sql.Tx
        err        error
        fireEvents bool
}

// WithCtx sets the db context.
func (db *DB) WithCtx(ctx context.Context) *DB <span class="cov0" title="0">{
        db.ctx = ctx
        return db
}</span>

// Ctx returns the context on the db.
func (db *DB) Ctx() context.Context <span class="cov0" title="0">{
        return db.ctx
}</span>

// FireEvents returns if events are enabled.
func (db *DB) FireEvents() bool <span class="cov0" title="0">{
        return db.fireEvents
}</span>

// WithFireEvents sets the `FireEvents` property.
func (db *DB) WithFireEvents(flag bool) *DB <span class="cov0" title="0">{
        db.fireEvents = flag
        return db
}</span>

// WithConn sets the connection for the context.
func (db *DB) WithConn(conn *Connection) *DB <span class="cov8" title="1">{
        db.conn = conn
        return db
}</span>

// Conn returns the underlying connection for the context.
func (db *DB) Conn() *Connection <span class="cov0" title="0">{
        return db.conn
}</span>

// InTx isolates a context to a transaction.
// The order precedence of the three main transaction sources are as follows:
// - InTx(...) transaction arguments will be used above everything else
// - an existing transaction on the context (i.e. if you call `.InTx().InTx()`)
// - beginning a new transaction with the connection
func (db *DB) InTx(txs ...*sql.Tx) *DB <span class="cov8" title="1">{
        if len(txs) &gt; 0 </span><span class="cov8" title="1">{
                db.tx = txs[0]
                return db
        }</span>
        <span class="cov8" title="1">if db.tx != nil </span><span class="cov8" title="1">{
                return db
        }</span>
        <span class="cov8" title="1">if db.conn == nil </span><span class="cov8" title="1">{
                db.err = exception.Newf(connectionErrorMessage)
                return db
        }</span>
        <span class="cov8" title="1">db.tx, db.err = db.conn.Begin()
        return db</span>
}

// Tx returns the transction for the context.
func (db *DB) Tx() *sql.Tx <span class="cov8" title="1">{
        return db.tx
}</span>

// Commit calls `Commit()` on the underlying transaction.
func (db *DB) Commit() error <span class="cov0" title="0">{
        if db.tx == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return db.tx.Commit()</span>
}

// Rollback calls `Rollback()` on the underlying transaction.
func (db *DB) Rollback() error <span class="cov8" title="1">{
        if db.tx == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return db.tx.Rollback()</span>
}

// Err returns the carried error.
func (db *DB) Err() error <span class="cov0" title="0">{
        return db.err
}</span>

// Invoke starts a new invocation.
func (db *DB) Invoke() *Invocation <span class="cov8" title="1">{
        return &amp;Invocation{conn: db.conn, ctx: db.ctx, tx: db.tx, err: db.err, fireEvents: db.fireEvents}
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package db

import (
        "sync"
)

var (
        defaultConnection *Connection
        defaultLock       = sync.Mutex{}
)

// SetDefault sets an alias created with `CreateDbAlias` as default. This lets you refer to it later via. `Default()`
//
//        spiffy.CreateDbAlias("main", spiffy.NewDbConnection("localhost", "test_db", "", ""))
//        spiffy.SetDefault("main")
//        execErr := spiffy.Default().Execute("select 'ok!')
//
// This will then let you refer to the alias via. `Default()`
func SetDefault(conn *Connection) <span class="cov8" title="1">{
        defaultLock.Lock()
        defaultConnection = conn
        defaultLock.Unlock()
}</span>

// Default returns a reference to the DbConnection set as default.
//
//        spiffy.Default().Exec("select 'ok!")
//
func Default() *Connection <span class="cov8" title="1">{
        return defaultConnection
}</span>

// OpenDefault sets the default connection and opens it.
func OpenDefault(conn *Connection) error <span class="cov8" title="1">{
        db, err := conn.Open()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">SetDefault(db)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package db

import (
        "context"
        "database/sql"
        "fmt"
        "reflect"
        "strconv"
        "time"

        "github.com/blend/go-sdk/exception"
        "github.com/blend/go-sdk/logger"
)

const (
        connectionErrorMessage = "invocation context; db connection is nil"
)

// Invocation is a specific operation against a context.
type Invocation struct {
        conn           *Connection
        ctx            context.Context
        tx             *sql.Tx
        fireEvents     bool
        statementLabel string
        err            error
}

// WithCtx sets the ctx and returns a reference to the invocation.
func (i *Invocation) WithCtx(ctx context.Context) *Invocation <span class="cov0" title="0">{
        i.ctx = ctx
        return i
}</span>

// Ctx returns the underlying context.
func (i *Invocation) Ctx() context.Context <span class="cov0" title="0">{
        return i.ctx
}</span>

// FireEvents returns if events are enabled.
func (i *Invocation) FireEvents() bool <span class="cov0" title="0">{
        return i.fireEvents
}</span>

// WithFireEvents sets the fire events property and returns an invocation.
func (i *Invocation) WithFireEvents(flag bool) *Invocation <span class="cov0" title="0">{
        i.fireEvents = flag
        return i
}</span>

// Err returns the context's error.
func (i *Invocation) Err() error <span class="cov8" title="1">{
        return i.err
}</span>

// WithLabel instructs the query generator to get or create a cached prepared statement.
func (i *Invocation) WithLabel(label string) *Invocation <span class="cov8" title="1">{
        i.statementLabel = label
        return i
}</span>

// Label returns the statement / plan cache label for the context.
func (i *Invocation) Label() string <span class="cov8" title="1">{
        return i.statementLabel
}</span>

// Tx returns the underlying transaction.
func (i *Invocation) Tx() *sql.Tx <span class="cov0" title="0">{
        return i.tx
}</span>

// Prepare returns a cached or newly prepared statment plan for a given sql statement.
func (i *Invocation) Prepare(statement string) (*sql.Stmt, error) <span class="cov8" title="1">{
        if i.err != nil </span><span class="cov8" title="1">{
                return nil, i.err
        }</span>
        <span class="cov8" title="1">if len(i.statementLabel) &gt; 0 </span><span class="cov8" title="1">{
                return i.conn.PrepareCached(i.statementLabel, statement, i.tx)
        }</span>
        <span class="cov8" title="1">return i.conn.Prepare(statement, i.tx)</span>
}

// Exec executes a sql statement with a given set of arguments.
func (i *Invocation) Exec(statement string, args ...interface{}) (err error) <span class="cov8" title="1">{
        err = i.check()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">start := time.Now()
        defer func() </span><span class="cov8" title="1">{ err = i.finalizer(recover(), err, logger.Query, statement, start) }</span>()

        <span class="cov8" title="1">stmt, stmtErr := i.Prepare(statement)
        if stmtErr != nil </span><span class="cov8" title="1">{
                err = exception.Wrap(stmtErr)
                return
        }</span>

        <span class="cov8" title="1">defer i.closeStatement(err, stmt)

        if _, execErr := stmt.Exec(args...); execErr != nil </span><span class="cov0" title="0">{
                err = exception.Wrap(execErr)
                if err != nil </span><span class="cov0" title="0">{
                        i.invalidateCachedStatement()
                }</span>
                <span class="cov0" title="0">return</span>
        }

        <span class="cov8" title="1">return</span>
}

// Query returns a new query object for a given sql query and arguments.
func (i *Invocation) Query(query string, args ...interface{}) *Query <span class="cov8" title="1">{
        return &amp;Query{statement: query, args: args, start: time.Now(), conn: i.conn, ctx: i.ctx, tx: i.tx, fireEvents: i.fireEvents, err: i.check(), statementLabel: i.statementLabel}
}</span>

// Get returns a given object based on a group of primary key ids within a transaction.
func (i *Invocation) Get(object DatabaseMapped, ids ...interface{}) (err error) <span class="cov8" title="1">{
        err = i.check()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if ids == nil </span><span class="cov0" title="0">{
                return exception.New("invalid `ids` parameter.")
        }</span>

        <span class="cov8" title="1">var queryBody string
        start := time.Now()

        meta := getCachedColumnCollectionFromInstance(object)
        standardCols := meta.NotReadOnly()
        tableName := TableName(object)

        if len(i.statementLabel) == 0 </span><span class="cov8" title="1">{
                i.statementLabel = fmt.Sprintf("%s_get", tableName)
        }</span>

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ err = i.finalizer(recover(), err, logger.Query, queryBody, start) }</span>()

        <span class="cov8" title="1">columnNames := standardCols.ColumnNames()
        pks := standardCols.PrimaryKeys()
        if pks.Len() == 0 </span><span class="cov0" title="0">{
                err = exception.New("no primary key on object to get by.")
                return
        }</span>

        <span class="cov8" title="1">queryBodyBuffer := i.conn.bufferPool.Get()
        defer i.conn.bufferPool.Put(queryBodyBuffer)

        queryBodyBuffer.WriteString("SELECT ")
        for i, name := range columnNames </span><span class="cov8" title="1">{
                queryBodyBuffer.WriteString(name)
                if i &lt; (len(columnNames) - 1) </span><span class="cov8" title="1">{
                        queryBodyBuffer.WriteRune(runeComma)
                }</span>
        }

        <span class="cov8" title="1">queryBodyBuffer.WriteString(" FROM ")
        queryBodyBuffer.WriteString(tableName)
        queryBodyBuffer.WriteString(" WHERE ")

        for i, pk := range pks.Columns() </span><span class="cov8" title="1">{
                queryBodyBuffer.WriteString(pk.ColumnName)
                queryBodyBuffer.WriteString(" = ")
                queryBodyBuffer.WriteString("$" + strconv.Itoa(i+1))

                if i &lt; (pks.Len() - 1) </span><span class="cov0" title="0">{
                        queryBodyBuffer.WriteString(" AND ")
                }</span>
        }

        <span class="cov8" title="1">queryBody = queryBodyBuffer.String()
        stmt, stmtErr := i.Prepare(queryBody)
        if stmtErr != nil </span><span class="cov0" title="0">{
                err = exception.Wrap(stmtErr)
                return
        }</span>
        <span class="cov8" title="1">defer i.closeStatement(err, stmt)

        var rows *sql.Rows
        var queryErr error
        if i.ctx != nil </span><span class="cov0" title="0">{
                rows, queryErr = stmt.QueryContext(i.ctx, ids...)
        }</span> else<span class="cov8" title="1"> {
                rows, queryErr = stmt.Query(ids...)
        }</span>

        <span class="cov8" title="1">if queryErr != nil </span><span class="cov0" title="0">{
                err = exception.Wrap(queryErr)
                i.invalidateCachedStatement()
                return
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                closeErr := rows.Close()
                if closeErr != nil </span><span class="cov0" title="0">{
                        err = exception.Nest(err, closeErr)
                }</span>
        }()

        <span class="cov8" title="1">var popErr error
        if rows.Next() </span><span class="cov8" title="1">{
                if isPopulatable(object) </span><span class="cov8" title="1">{
                        popErr = asPopulatable(object).Populate(rows)
                }</span> else<span class="cov8" title="1"> {
                        popErr = PopulateInOrder(object, rows, standardCols)
                }</span>

                <span class="cov8" title="1">if popErr != nil </span><span class="cov0" title="0">{
                        err = exception.Wrap(popErr)
                        return
                }</span>
        }

        <span class="cov8" title="1">err = exception.Wrap(rows.Err())
        return</span>
}

// GetAll returns all rows of an object mapped table wrapped in a transaction.
func (i *Invocation) GetAll(collection interface{}) (err error) <span class="cov8" title="1">{
        err = i.check()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">var queryBody string
        start := time.Now()
        defer func() </span><span class="cov8" title="1">{ err = i.finalizer(recover(), err, logger.Query, queryBody, start) }</span>()

        <span class="cov8" title="1">collectionValue := reflectValue(collection)
        t := reflectSliceType(collection)
        tableName := TableNameByType(t)

        if len(i.statementLabel) == 0 </span><span class="cov8" title="1">{
                i.statementLabel = fmt.Sprintf("%s_get_all", tableName)
        }</span>

        <span class="cov8" title="1">meta := getCachedColumnCollectionFromType(tableName, t).NotReadOnly()

        columnNames := meta.ColumnNames()

        queryBodyBuffer := i.conn.bufferPool.Get()
        defer i.conn.bufferPool.Put(queryBodyBuffer)

        queryBodyBuffer.WriteString("SELECT ")
        for i, name := range columnNames </span><span class="cov8" title="1">{
                queryBodyBuffer.WriteString(name)
                if i &lt; (len(columnNames) - 1) </span><span class="cov8" title="1">{
                        queryBodyBuffer.WriteRune(runeComma)
                }</span>
        }
        <span class="cov8" title="1">queryBodyBuffer.WriteString(" FROM ")
        queryBodyBuffer.WriteString(tableName)

        queryBody = queryBodyBuffer.String()
        stmt, stmtErr := i.Prepare(queryBody)
        if stmtErr != nil </span><span class="cov0" title="0">{
                err = exception.Wrap(stmtErr)
                i.invalidateCachedStatement()
                return
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ err = i.closeStatement(err, stmt) }</span>()

        <span class="cov8" title="1">var rows *sql.Rows
        var queryErr error
        if i.ctx != nil </span><span class="cov0" title="0">{
                rows, queryErr = stmt.QueryContext(i.ctx)
        }</span> else<span class="cov8" title="1"> {
                rows, queryErr = stmt.Query()
        }</span>
        <span class="cov8" title="1">if queryErr != nil </span><span class="cov0" title="0">{
                err = exception.Wrap(queryErr)
                return
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                closeErr := rows.Close()
                if closeErr != nil </span><span class="cov0" title="0">{
                        err = exception.Nest(err, closeErr)
                }</span>
        }()

        <span class="cov8" title="1">v, err := makeNewDatabaseMapped(t)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">isPopulatable := isPopulatable(v)

        var popErr error
        for rows.Next() </span><span class="cov8" title="1">{
                newObj, _ := makeNewDatabaseMapped(t)

                if isPopulatable </span><span class="cov8" title="1">{
                        popErr = asPopulatable(newObj).Populate(rows)
                }</span> else<span class="cov0" title="0"> {
                        popErr = PopulateInOrder(newObj, rows, meta)
                        if popErr != nil </span><span class="cov0" title="0">{
                                err = exception.Wrap(popErr)
                                return
                        }</span>
                }
                <span class="cov8" title="1">newObjValue := reflectValue(newObj)
                collectionValue.Set(reflect.Append(collectionValue, newObjValue))</span>
        }

        <span class="cov8" title="1">err = exception.Wrap(rows.Err())
        return</span>
}

// Create writes an object to the database within a transaction.
func (i *Invocation) Create(object DatabaseMapped) (err error) <span class="cov8" title="1">{
        err = i.check()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">var queryBody string
        start := time.Now()
        defer func() </span><span class="cov8" title="1">{ err = i.finalizer(recover(), err, logger.Query, queryBody, start) }</span>()

        <span class="cov8" title="1">cols := getCachedColumnCollectionFromInstance(object)
        writeCols := cols.NotReadOnly().NotSerials()

        //NOTE: we're only using one.
        serials := cols.Serials()
        tableName := TableName(object)

        if len(i.statementLabel) == 0 </span><span class="cov8" title="1">{
                i.statementLabel = fmt.Sprintf("%s_create", tableName)
        }</span>

        <span class="cov8" title="1">colNames := writeCols.ColumnNames()
        colValues := writeCols.ColumnValues(object)

        queryBodyBuffer := i.conn.bufferPool.Get()
        defer i.conn.bufferPool.Put(queryBodyBuffer)

        queryBodyBuffer.WriteString("INSERT INTO ")
        queryBodyBuffer.WriteString(tableName)
        queryBodyBuffer.WriteString(" (")
        for i, name := range colNames </span><span class="cov8" title="1">{
                queryBodyBuffer.WriteString(name)
                if i &lt; len(colNames)-1 </span><span class="cov8" title="1">{
                        queryBodyBuffer.WriteRune(runeComma)
                }</span>
        }
        <span class="cov8" title="1">queryBodyBuffer.WriteString(") VALUES (")
        for x := 0; x &lt; writeCols.Len(); x++ </span><span class="cov8" title="1">{
                queryBodyBuffer.WriteString("$" + strconv.Itoa(x+1))
                if x &lt; (writeCols.Len() - 1) </span><span class="cov8" title="1">{
                        queryBodyBuffer.WriteRune(runeComma)
                }</span>
        }
        <span class="cov8" title="1">queryBodyBuffer.WriteString(")")

        if serials.Len() &gt; 0 </span><span class="cov8" title="1">{
                serial := serials.FirstOrDefault()
                queryBodyBuffer.WriteString(" RETURNING ")
                queryBodyBuffer.WriteString(serial.ColumnName)
        }</span>

        <span class="cov8" title="1">queryBody = queryBodyBuffer.String()
        stmt, stmtErr := i.Prepare(queryBody)
        if stmtErr != nil </span><span class="cov0" title="0">{
                err = exception.Wrap(stmtErr)
                return
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ err = i.closeStatement(err, stmt) }</span>()

        <span class="cov8" title="1">var execErr error
        if serials.Len() == 0 </span><span class="cov0" title="0">{
                if i.ctx != nil </span><span class="cov0" title="0">{
                        _, execErr = stmt.ExecContext(i.ctx, colValues...)
                }</span> else<span class="cov0" title="0"> {
                        _, execErr = stmt.Exec(colValues...)
                }</span>

                <span class="cov0" title="0">if execErr != nil </span><span class="cov0" title="0">{
                        err = exception.Wrap(execErr)
                        i.invalidateCachedStatement()
                        return
                }</span>
        } else<span class="cov8" title="1"> {
                serial := serials.FirstOrDefault()

                var id interface{}
                if i.ctx != nil </span><span class="cov0" title="0">{
                        execErr = stmt.QueryRowContext(i.ctx, colValues...).Scan(&amp;id)
                }</span> else<span class="cov8" title="1"> {
                        execErr = stmt.QueryRow(colValues...).Scan(&amp;id)
                }</span>

                <span class="cov8" title="1">if execErr != nil </span><span class="cov0" title="0">{
                        err = exception.Wrap(execErr)
                        return
                }</span>
                <span class="cov8" title="1">setErr := serial.SetValue(object, id)
                if setErr != nil </span><span class="cov0" title="0">{
                        err = exception.Wrap(setErr)
                        return
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// CreateIfNotExists writes an object to the database if it does not already exist within a transaction.
func (i *Invocation) CreateIfNotExists(object DatabaseMapped) (err error) <span class="cov8" title="1">{
        err = i.check()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">var queryBody string
        start := time.Now()
        defer func() </span><span class="cov8" title="1">{ err = i.finalizer(recover(), err, logger.Query, queryBody, start) }</span>()

        <span class="cov8" title="1">cols := getCachedColumnCollectionFromInstance(object)
        writeCols := cols.NotReadOnly().NotSerials()

        //NOTE: we're only using one.
        serials := cols.Serials()
        pks := cols.PrimaryKeys()
        tableName := TableName(object)

        if len(i.statementLabel) == 0 </span><span class="cov8" title="1">{
                i.statementLabel = fmt.Sprintf("%s_create_if_not_exists", tableName)
        }</span>

        <span class="cov8" title="1">colNames := writeCols.ColumnNames()
        colValues := writeCols.ColumnValues(object)

        queryBodyBuffer := i.conn.bufferPool.Get()
        defer i.conn.bufferPool.Put(queryBodyBuffer)

        queryBodyBuffer.WriteString("INSERT INTO ")
        queryBodyBuffer.WriteString(tableName)
        queryBodyBuffer.WriteString(" (")
        for i, name := range colNames </span><span class="cov8" title="1">{
                queryBodyBuffer.WriteString(name)
                if i &lt; len(colNames)-1 </span><span class="cov8" title="1">{
                        queryBodyBuffer.WriteRune(runeComma)
                }</span>
        }
        <span class="cov8" title="1">queryBodyBuffer.WriteString(") VALUES (")
        for x := 0; x &lt; writeCols.Len(); x++ </span><span class="cov8" title="1">{
                queryBodyBuffer.WriteString("$" + strconv.Itoa(x+1))
                if x &lt; (writeCols.Len() - 1) </span><span class="cov8" title="1">{
                        queryBodyBuffer.WriteRune(runeComma)
                }</span>
        }
        <span class="cov8" title="1">queryBodyBuffer.WriteString(")")

        if pks.Len() &gt; 0 </span><span class="cov8" title="1">{
                queryBodyBuffer.WriteString(" ON CONFLICT (")
                pkColumnNames := pks.ColumnNames()
                for i, name := range pkColumnNames </span><span class="cov8" title="1">{
                        queryBodyBuffer.WriteString(name)
                        if i &lt; len(pkColumnNames)-1 </span><span class="cov0" title="0">{
                                queryBodyBuffer.WriteRune(runeComma)
                        }</span>
                }
                <span class="cov8" title="1">queryBodyBuffer.WriteString(") DO NOTHING")</span>
        }

        <span class="cov8" title="1">if serials.Len() &gt; 0 </span><span class="cov0" title="0">{
                serial := serials.FirstOrDefault()
                queryBodyBuffer.WriteString(" RETURNING ")
                queryBodyBuffer.WriteString(serial.ColumnName)
        }</span>

        <span class="cov8" title="1">queryBody = queryBodyBuffer.String()
        stmt, stmtErr := i.Prepare(queryBody)
        if stmtErr != nil </span><span class="cov0" title="0">{
                err = exception.Wrap(stmtErr)
                return
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ err = i.closeStatement(err, stmt) }</span>()

        <span class="cov8" title="1">var execErr error
        if serials.Len() == 0 </span><span class="cov8" title="1">{
                if i.ctx != nil </span><span class="cov0" title="0">{
                        _, execErr = stmt.ExecContext(i.ctx, colValues...)
                }</span> else<span class="cov8" title="1"> {
                        _, execErr = stmt.Exec(colValues...)
                }</span>
                <span class="cov8" title="1">if execErr != nil </span><span class="cov0" title="0">{
                        err = exception.Wrap(execErr)
                        i.invalidateCachedStatement()
                        return
                }</span>
        } else<span class="cov0" title="0"> {
                serial := serials.FirstOrDefault()

                var id interface{}
                if i.ctx != nil </span><span class="cov0" title="0">{
                        execErr = stmt.QueryRowContext(i.ctx, colValues...).Scan(&amp;id)
                }</span> else<span class="cov0" title="0"> {
                        execErr = stmt.QueryRow(colValues...).Scan(&amp;id)
                }</span>

                <span class="cov0" title="0">if execErr != nil </span><span class="cov0" title="0">{
                        err = exception.Wrap(execErr)
                        return
                }</span>
                <span class="cov0" title="0">setErr := serial.SetValue(object, id)
                if setErr != nil </span><span class="cov0" title="0">{
                        err = exception.Wrap(setErr)
                        return
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// CreateMany writes many an objects to the database within a transaction.
func (i *Invocation) CreateMany(objects interface{}) (err error) <span class="cov8" title="1">{
        err = i.check()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">var queryBody string
        start := time.Now()
        defer func() </span><span class="cov8" title="1">{ err = i.finalizer(recover(), err, logger.Query, queryBody, start) }</span>()

        <span class="cov8" title="1">sliceValue := reflectValue(objects)
        if sliceValue.Len() == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">sliceType := reflectSliceType(objects)
        tableName := TableNameByType(sliceType)

        cols := getCachedColumnCollectionFromType(tableName, sliceType)
        writeCols := cols.NotReadOnly().NotSerials()

        //NOTE: we're only using one.
        //serials := cols.Serials()
        colNames := writeCols.ColumnNames()

        queryBodyBuffer := i.conn.bufferPool.Get()
        defer i.conn.bufferPool.Put(queryBodyBuffer)

        queryBodyBuffer.WriteString("INSERT INTO ")
        queryBodyBuffer.WriteString(tableName)
        queryBodyBuffer.WriteString(" (")
        for i, name := range colNames </span><span class="cov8" title="1">{
                queryBodyBuffer.WriteString(name)
                if i &lt; len(colNames)-1 </span><span class="cov8" title="1">{
                        queryBodyBuffer.WriteRune(runeComma)
                }</span>
        }

        <span class="cov8" title="1">queryBodyBuffer.WriteString(") VALUES ")

        metaIndex := 1
        for x := 0; x &lt; sliceValue.Len(); x++ </span><span class="cov8" title="1">{
                queryBodyBuffer.WriteString("(")
                for y := 0; y &lt; writeCols.Len(); y++ </span><span class="cov8" title="1">{
                        queryBodyBuffer.WriteString(fmt.Sprintf("$%d", metaIndex))
                        metaIndex = metaIndex + 1
                        if y &lt; writeCols.Len()-1 </span><span class="cov8" title="1">{
                                queryBodyBuffer.WriteRune(runeComma)
                        }</span>
                }
                <span class="cov8" title="1">queryBodyBuffer.WriteString(")")
                if x &lt; sliceValue.Len()-1 </span><span class="cov8" title="1">{
                        queryBodyBuffer.WriteRune(runeComma)
                }</span>
        }

        <span class="cov8" title="1">queryBody = queryBodyBuffer.String()
        stmt, stmtErr := i.Prepare(queryBody)
        if stmtErr != nil </span><span class="cov0" title="0">{
                err = exception.Wrap(stmtErr)
                return
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ err = i.closeStatement(err, stmt) }</span>()

        <span class="cov8" title="1">var colValues []interface{}
        for row := 0; row &lt; sliceValue.Len(); row++ </span><span class="cov8" title="1">{
                colValues = append(colValues, writeCols.ColumnValues(sliceValue.Index(row).Interface())...)
        }</span>

        <span class="cov8" title="1">_, execErr := stmt.Exec(colValues...)
        if execErr != nil </span><span class="cov0" title="0">{
                err = exception.Wrap(execErr)
                i.invalidateCachedStatement()
                return
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Update updates an object wrapped in a transaction.
func (i *Invocation) Update(object DatabaseMapped) (err error) <span class="cov8" title="1">{
        err = i.check()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">var queryBody string
        start := time.Now()
        defer func() </span><span class="cov8" title="1">{ err = i.finalizer(recover(), err, logger.Query, queryBody, start) }</span>()

        <span class="cov8" title="1">tableName := TableName(object)
        if len(i.statementLabel) == 0 </span><span class="cov8" title="1">{
                i.statementLabel = fmt.Sprintf("%s_update", tableName)
        }</span>

        <span class="cov8" title="1">cols := getCachedColumnCollectionFromInstance(object)
        writeCols := cols.WriteColumns()
        pks := cols.PrimaryKeys()
        updateCols := cols.UpdateColumns()
        updateValues := updateCols.ColumnValues(object)
        numColumns := writeCols.Len()

        queryBodyBuffer := i.conn.bufferPool.Get()
        defer i.conn.bufferPool.Put(queryBodyBuffer)

        queryBodyBuffer.WriteString("UPDATE ")
        queryBodyBuffer.WriteString(tableName)
        queryBodyBuffer.WriteString(" SET ")

        var writeColIndex int
        var col Column
        for ; writeColIndex &lt; writeCols.Len(); writeColIndex++ </span><span class="cov8" title="1">{
                col = writeCols.columns[writeColIndex]
                queryBodyBuffer.WriteString(col.ColumnName)
                queryBodyBuffer.WriteString(" = $" + strconv.Itoa(writeColIndex+1))
                if writeColIndex != numColumns-1 </span><span class="cov8" title="1">{
                        queryBodyBuffer.WriteRune(runeComma)
                }</span>
        }

        <span class="cov8" title="1">queryBodyBuffer.WriteString(" WHERE ")
        for i, pk := range pks.Columns() </span><span class="cov8" title="1">{
                queryBodyBuffer.WriteString(pk.ColumnName)
                queryBodyBuffer.WriteString(" = ")
                queryBodyBuffer.WriteString("$" + strconv.Itoa(i+(writeColIndex+1)))

                if i &lt; (pks.Len() - 1) </span><span class="cov0" title="0">{
                        queryBodyBuffer.WriteString(" AND ")
                }</span>
        }

        <span class="cov8" title="1">queryBody = queryBodyBuffer.String()
        stmt, stmtErr := i.Prepare(queryBody)
        if stmtErr != nil </span><span class="cov0" title="0">{
                err = exception.Wrap(stmtErr)
                return
        }</span>

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ err = i.closeStatement(err, stmt) }</span>()

        <span class="cov8" title="1">var execErr error
        if i.ctx != nil </span><span class="cov0" title="0">{
                _, execErr = stmt.ExecContext(i.ctx, updateValues...)
        }</span> else<span class="cov8" title="1"> {
                _, execErr = stmt.Exec(updateValues...)
        }</span>
        <span class="cov8" title="1">if execErr != nil </span><span class="cov0" title="0">{
                err = exception.Wrap(execErr)
                i.invalidateCachedStatement()
                return
        }</span>

        <span class="cov8" title="1">return</span>
}

// Exists returns a bool if a given object exists (utilizing the primary key columns if they exist) wrapped in a transaction.
func (i *Invocation) Exists(object DatabaseMapped) (exists bool, err error) <span class="cov8" title="1">{
        err = i.check()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">var queryBody string
        start := time.Now()
        defer func() </span><span class="cov8" title="1">{ err = i.finalizer(recover(), err, logger.Query, queryBody, start) }</span>()

        <span class="cov8" title="1">tableName := TableName(object)
        if len(i.statementLabel) == 0 </span><span class="cov8" title="1">{
                i.statementLabel = fmt.Sprintf("%s_exists", tableName)
        }</span>
        <span class="cov8" title="1">cols := getCachedColumnCollectionFromInstance(object)
        pks := cols.PrimaryKeys()

        if pks.Len() == 0 </span><span class="cov0" title="0">{
                exists = false
                err = exception.New("No primary key on object.")
                return
        }</span>

        <span class="cov8" title="1">queryBodyBuffer := i.conn.bufferPool.Get()
        defer i.conn.bufferPool.Put(queryBodyBuffer)

        queryBodyBuffer.WriteString("SELECT 1 FROM ")
        queryBodyBuffer.WriteString(tableName)
        queryBodyBuffer.WriteString(" WHERE ")

        for i, pk := range pks.Columns() </span><span class="cov8" title="1">{
                queryBodyBuffer.WriteString(pk.ColumnName)
                queryBodyBuffer.WriteString(" = ")
                queryBodyBuffer.WriteString("$" + strconv.Itoa(i+1))

                if i &lt; (pks.Len() - 1) </span><span class="cov0" title="0">{
                        queryBodyBuffer.WriteString(" AND ")
                }</span>
        }

        <span class="cov8" title="1">queryBody = queryBodyBuffer.String()
        stmt, stmtErr := i.Prepare(queryBody)
        if stmtErr != nil </span><span class="cov0" title="0">{
                exists = false
                err = exception.Wrap(stmtErr)
                return
        }</span>

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ err = i.closeStatement(err, stmt) }</span>()

        <span class="cov8" title="1">pkValues := pks.ColumnValues(object)
        var rows *sql.Rows
        var queryErr error
        if i.ctx != nil </span><span class="cov0" title="0">{
                rows, queryErr = stmt.QueryContext(i.ctx, pkValues...)
        }</span> else<span class="cov8" title="1"> {
                rows, queryErr = stmt.Query(pkValues...)
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                closeErr := rows.Close()
                if closeErr != nil </span><span class="cov0" title="0">{
                        err = exception.Nest(err, closeErr)
                }</span>
        }()

        <span class="cov8" title="1">if queryErr != nil </span><span class="cov0" title="0">{
                exists = false
                err = exception.Wrap(queryErr)
                i.invalidateCachedStatement()
                return
        }</span>

        <span class="cov8" title="1">exists = rows.Next()
        return</span>
}

// Delete deletes an object from the database wrapped in a transaction.
func (i *Invocation) Delete(object DatabaseMapped) (err error) <span class="cov8" title="1">{
        err = i.check()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">var queryBody string
        start := time.Now()
        defer func() </span><span class="cov8" title="1">{ err = i.finalizer(recover(), err, logger.Query, queryBody, start) }</span>()

        <span class="cov8" title="1">tableName := TableName(object)

        if len(i.statementLabel) == 0 </span><span class="cov8" title="1">{
                i.statementLabel = fmt.Sprintf("%s_delete", tableName)
        }</span>

        <span class="cov8" title="1">cols := getCachedColumnCollectionFromInstance(object)
        pks := cols.PrimaryKeys()

        if len(pks.Columns()) == 0 </span><span class="cov0" title="0">{
                err = exception.New("No primary key on object.")
                return
        }</span>

        <span class="cov8" title="1">queryBodyBuffer := i.conn.bufferPool.Get()
        defer i.conn.bufferPool.Put(queryBodyBuffer)

        queryBodyBuffer.WriteString("DELETE FROM ")
        queryBodyBuffer.WriteString(tableName)
        queryBodyBuffer.WriteString(" WHERE ")

        for i, pk := range pks.Columns() </span><span class="cov8" title="1">{
                queryBodyBuffer.WriteString(pk.ColumnName)
                queryBodyBuffer.WriteString(" = ")
                queryBodyBuffer.WriteString("$" + strconv.Itoa(i+1))

                if i &lt; (pks.Len() - 1) </span><span class="cov0" title="0">{
                        queryBodyBuffer.WriteString(" AND ")
                }</span>
        }

        <span class="cov8" title="1">queryBody = queryBodyBuffer.String()
        stmt, stmtErr := i.Prepare(queryBody)
        if stmtErr != nil </span><span class="cov0" title="0">{
                err = exception.Wrap(stmtErr)
                return
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ err = i.closeStatement(err, stmt) }</span>()

        <span class="cov8" title="1">pkValues := pks.ColumnValues(object)

        var execErr error
        if i.ctx != nil </span><span class="cov0" title="0">{
                _, execErr = stmt.ExecContext(i.ctx, pkValues...)
        }</span> else<span class="cov8" title="1"> {
                _, execErr = stmt.Exec(pkValues...)
        }</span>
        <span class="cov8" title="1">if execErr != nil </span><span class="cov0" title="0">{
                err = exception.Wrap(execErr)
                i.invalidateCachedStatement()
        }</span>
        <span class="cov8" title="1">return</span>
}

// Truncate completely empties a table in a single command.
func (i *Invocation) Truncate(object DatabaseMapped) (err error) <span class="cov8" title="1">{
        err = i.check()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">var queryBody string
        start := time.Now()
        defer func() </span><span class="cov8" title="1">{ err = i.finalizer(recover(), err, logger.Query, queryBody, start) }</span>()

        <span class="cov8" title="1">tableName := TableName(object)

        if len(i.statementLabel) == 0 </span><span class="cov8" title="1">{
                i.statementLabel = fmt.Sprintf("%s_truncate", tableName)
        }</span>

        <span class="cov8" title="1">queryBodyBuffer := i.conn.bufferPool.Get()
        defer i.conn.bufferPool.Put(queryBodyBuffer)

        queryBodyBuffer.WriteString("TRUNCATE ")
        queryBodyBuffer.WriteString(tableName)

        queryBody = queryBodyBuffer.String()
        stmt, stmtErr := i.Prepare(queryBody)
        if stmtErr != nil </span><span class="cov0" title="0">{
                err = exception.Wrap(stmtErr)
                return
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ err = i.closeStatement(err, stmt) }</span>()

        <span class="cov8" title="1">var execErr error
        if i.ctx != nil </span><span class="cov0" title="0">{
                _, execErr = stmt.ExecContext(i.ctx)
        }</span> else<span class="cov8" title="1"> {
                _, execErr = stmt.Exec()
        }</span>

        <span class="cov8" title="1">if execErr != nil </span><span class="cov0" title="0">{
                err = exception.Wrap(execErr)
                i.invalidateCachedStatement()
        }</span>
        <span class="cov8" title="1">return</span>
}

// Upsert inserts the object if it doesn't exist already (as defined by its primary keys) or updates it wrapped in a transaction.
func (i *Invocation) Upsert(object DatabaseMapped) (err error) <span class="cov8" title="1">{
        err = i.check()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">var queryBody string
        start := time.Now()
        defer func() </span><span class="cov8" title="1">{ err = i.finalizer(recover(), err, logger.Query, queryBody, start) }</span>()

        <span class="cov8" title="1">cols := getCachedColumnCollectionFromInstance(object)
        writeCols := cols.NotReadOnly().NotSerials()

        conflictUpdateCols := cols.NotReadOnly().NotSerials().NotPrimaryKeys()

        serials := cols.Serials()
        pks := cols.PrimaryKeys()
        tableName := TableName(object)

        if len(i.statementLabel) == 0 </span><span class="cov8" title="1">{
                i.statementLabel = fmt.Sprintf("%s_upsert", tableName)
        }</span>

        <span class="cov8" title="1">colNames := writeCols.ColumnNames()
        colValues := writeCols.ColumnValues(object)

        queryBodyBuffer := i.conn.bufferPool.Get()
        defer i.conn.bufferPool.Put(queryBodyBuffer)

        queryBodyBuffer.WriteString("INSERT INTO ")
        queryBodyBuffer.WriteString(tableName)
        queryBodyBuffer.WriteString(" (")
        for i, name := range colNames </span><span class="cov8" title="1">{
                queryBodyBuffer.WriteString(name)
                if i &lt; len(colNames)-1 </span><span class="cov8" title="1">{
                        queryBodyBuffer.WriteRune(runeComma)
                }</span>
        }
        <span class="cov8" title="1">queryBodyBuffer.WriteString(") VALUES (")

        for x := 0; x &lt; writeCols.Len(); x++ </span><span class="cov8" title="1">{
                queryBodyBuffer.WriteString("$" + strconv.Itoa(x+1))
                if x &lt; (writeCols.Len() - 1) </span><span class="cov8" title="1">{
                        queryBodyBuffer.WriteRune(runeComma)
                }</span>
        }

        <span class="cov8" title="1">queryBodyBuffer.WriteString(")")

        if pks.Len() &gt; 0 </span><span class="cov8" title="1">{
                tokenMap := map[string]string{}
                for i, col := range writeCols.Columns() </span><span class="cov8" title="1">{
                        tokenMap[col.ColumnName] = "$" + strconv.Itoa(i+1)
                }</span>

                <span class="cov8" title="1">queryBodyBuffer.WriteString(" ON CONFLICT (")
                pkColumnNames := pks.ColumnNames()
                for i, name := range pkColumnNames </span><span class="cov8" title="1">{
                        queryBodyBuffer.WriteString(name)
                        if i &lt; len(pkColumnNames)-1 </span><span class="cov0" title="0">{
                                queryBodyBuffer.WriteRune(runeComma)
                        }</span>
                }
                <span class="cov8" title="1">queryBodyBuffer.WriteString(") DO UPDATE SET ")

                conflictCols := conflictUpdateCols.Columns()
                for i, col := range conflictCols </span><span class="cov8" title="1">{
                        queryBodyBuffer.WriteString(col.ColumnName + " = " + tokenMap[col.ColumnName])
                        if i &lt; (len(conflictCols) - 1) </span><span class="cov8" title="1">{
                                queryBodyBuffer.WriteRune(runeComma)
                        }</span>
                }
        }

        <span class="cov8" title="1">var serial = serials.FirstOrDefault()
        if serials.Len() != 0 </span><span class="cov8" title="1">{
                queryBodyBuffer.WriteString(" RETURNING ")
                queryBodyBuffer.WriteString(serial.ColumnName)
        }</span>

        <span class="cov8" title="1">queryBody = queryBodyBuffer.String()

        stmt, stmtErr := i.Prepare(queryBody)
        if stmtErr != nil </span><span class="cov0" title="0">{
                err = exception.Wrap(stmtErr)
                return
        }</span>
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{ err = i.closeStatement(err, stmt) }</span>()

        <span class="cov8" title="1">var execErr error
        if serials.Len() != 0 </span><span class="cov8" title="1">{
                var id interface{}
                if i.ctx != nil </span><span class="cov0" title="0">{
                        execErr = stmt.QueryRowContext(i.ctx, colValues...).Scan(&amp;id)
                }</span> else<span class="cov8" title="1"> {
                        execErr = stmt.QueryRow(colValues...).Scan(&amp;id)
                }</span>
                <span class="cov8" title="1">if execErr != nil </span><span class="cov0" title="0">{
                        err = exception.Wrap(execErr)
                        i.invalidateCachedStatement()
                        return
                }</span>
                <span class="cov8" title="1">setErr := serial.SetValue(object, id)
                if setErr != nil </span><span class="cov0" title="0">{
                        err = exception.Wrap(setErr)
                        return
                }</span>
        } else<span class="cov8" title="1"> {
                if i.ctx != nil </span><span class="cov0" title="0">{
                        _, execErr = stmt.ExecContext(i.ctx, colValues...)
                }</span> else<span class="cov8" title="1"> {
                        _, execErr = stmt.Exec(colValues...)
                }</span>
                <span class="cov8" title="1">if execErr != nil </span><span class="cov0" title="0">{
                        err = exception.Wrap(execErr)
                        return
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// --------------------------------------------------------------------------------
// helpers
// --------------------------------------------------------------------------------

func (i *Invocation) check() error <span class="cov8" title="1">{
        if i.conn == nil </span><span class="cov8" title="1">{
                return exception.Newf(connectionErrorMessage)
        }</span>
        <span class="cov8" title="1">if i.err != nil </span><span class="cov8" title="1">{
                return i.err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (i *Invocation) invalidateCachedStatement() <span class="cov0" title="0">{
        if i.conn.useStatementCache &amp;&amp; len(i.statementLabel) &gt; 0 </span><span class="cov0" title="0">{
                i.conn.statementCache.InvalidateStatement(i.statementLabel)
        }</span>
}

func (i *Invocation) closeStatement(err error, stmt *sql.Stmt) error <span class="cov8" title="1">{
        if !i.conn.useStatementCache </span><span class="cov0" title="0">{
                closeErr := stmt.Close()
                if closeErr != nil </span><span class="cov0" title="0">{
                        return exception.Nest(err, closeErr)
                }</span>
        }
        <span class="cov8" title="1">return err</span>
}

func (i *Invocation) finalizer(r interface{}, err error, flag logger.Flag, statement string, start time.Time) error <span class="cov8" title="1">{
        if r != nil </span><span class="cov0" title="0">{
                recoveryException := exception.New(r)
                err = exception.Nest(err, recoveryException)
        }</span>
        <span class="cov8" title="1">if i.fireEvents </span><span class="cov0" title="0">{
                i.conn.fireEvent(flag, statement, time.Now().Sub(start), err, i.statementLabel)
        }</span>
        <span class="cov8" title="1">i.statementLabel = ""
        return err</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package migration

import (
        "database/sql"

        "github.com/blend/go-sdk/db"
)

// Body returns an invocable of a set of invocable actions.
func Body(actions ...Action) Invocable <span class="cov8" title="1">{
        return &amp;body{actions: actions}
}</span>

// body wraps a user supplied invocation body.
type body struct {
        actions []Action
}

// Invoke applies the invocation.
func (b *body) Invoke(c *db.Connection, tx *sql.Tx) error <span class="cov8" title="1">{
        var err error
        for _, action := range b.actions </span><span class="cov8" title="1">{
                err = action(c, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package migration

import (
        "bytes"
        "database/sql"
        "fmt"
        "io"
        "os"
        "regexp"
        "strings"

        "github.com/blend/go-sdk/db"
        "github.com/blend/go-sdk/exception"
        "github.com/blend/go-sdk/util"
        "github.com/lib/pq"
)

const (
        runeTab          = rune('\t')
        runeNewline      = rune('\n')
        byteNewLine      = byte('\n')
        byteTab          = byte('\t')
        null             = `\N`
        regexCopyExtract = `COPY (.*)? \((.*)?\)`
)

// ReadDataFile returns a new DataFileReader
func ReadDataFile(filePath string) *DataFileReader <span class="cov0" title="0">{
        return &amp;DataFileReader{
                path:          filePath,
                copyExtractor: regexp.MustCompile(regexCopyExtract),
        }
}</span>

// DataFileReader reads a postgres dump.
type DataFileReader struct {
        parent Migration
        label  string
        path   string
        logger *Logger

        copyExtractor *regexp.Regexp
}

// Label returns the label for the data file reader.
func (dfr *DataFileReader) Label() string <span class="cov0" title="0">{
        if len(dfr.label) == 0 </span><span class="cov0" title="0">{
                dfr.label = fmt.Sprintf("read data file `%s`", dfr.path)
        }</span>
        <span class="cov0" title="0">return dfr.label</span>
}

// SetLabel sets the migration label.
func (dfr *DataFileReader) SetLabel(value string) <span class="cov0" title="0">{
        dfr.label = value
}</span>

// WithLabel sets the migration label.
func (dfr *DataFileReader) WithLabel(value string) Migration <span class="cov0" title="0">{
        dfr.label = value
        return dfr
}</span>

// Parent returns the parent for the data file reader.
func (dfr *DataFileReader) Parent() Migration <span class="cov0" title="0">{
        return dfr.parent
}</span>

// SetParent sets the parent for the data file reader.
func (dfr *DataFileReader) SetParent(parent Migration) <span class="cov0" title="0">{
        dfr.parent = parent
}</span>

// WithParent sets the parent for the data file reader.
func (dfr *DataFileReader) WithParent(parent Migration) Migration <span class="cov0" title="0">{
        dfr.parent = parent
        return dfr
}</span>

// Logger returns the logger.
func (dfr *DataFileReader) Logger() *Logger <span class="cov0" title="0">{
        return dfr.logger
}</span>

// SetLogger sets the logger for the data file reader.
func (dfr *DataFileReader) SetLogger(logger *Logger) <span class="cov0" title="0">{
        dfr.logger = logger
}</span>

// WithLogger sets the logger for the data file reader.
func (dfr *DataFileReader) WithLogger(logger *Logger) Migration <span class="cov0" title="0">{
        dfr.logger = logger
        return dfr
}</span>

// IsTransactionIsolated returns if the migration is transaction isolated or not.
func (dfr *DataFileReader) IsTransactionIsolated() bool <span class="cov0" title="0">{
        return true
}</span>

// Test runs the data file reader and then rolls-back the txn.
func (dfr *DataFileReader) Test(c *db.Connection, optionalTx ...*sql.Tx) (err error) <span class="cov0" title="0">{
        tx, err := c.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("%v", err)
                }</span>
                <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                        dfr.logger.Applyf(dfr, "done")
                }</span> else<span class="cov0" title="0"> {
                        dfr.logger.Error(dfr, err)
                }</span>
                <span class="cov0" title="0">tx.Rollback()</span>
        }()
        <span class="cov0" title="0">err = dfr.Invoke(c, tx)
        return</span>
}

// Apply applies the data file reader.
func (dfr *DataFileReader) Apply(c *db.Connection, optionalTx ...*sql.Tx) (err error) <span class="cov0" title="0">{
        tx, err := c.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("%v", err)
                }</span>
                <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                        tx.Commit()
                        dfr.logger.Applyf(dfr, "done")
                }</span> else<span class="cov0" title="0"> {
                        tx.Rollback()
                        dfr.logger.Error(dfr, err)
                }</span>
        }()

        <span class="cov0" title="0">err = dfr.Invoke(c, tx)
        return</span>
}

// Invoke consumes the data file and writes it to the db.
func (dfr *DataFileReader) Invoke(c *db.Connection, tx *sql.Tx) (err error) <span class="cov0" title="0">{
        var f *os.File
        if f, err = os.Open(dfr.path); err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">defer f.Close()

        var stmt *sql.Stmt
        var state int

        var cursor int64
        var readBuffer = make([]byte, 32)
        var readErr error
        var lineBuffer = bytes.NewBuffer([]byte{})
        var line string
        var pieces []interface{}

        for readErr == nil </span><span class="cov0" title="0">{
                lineBuffer.Reset()

                switch state </span>{
                case 0:<span class="cov0" title="0">
                        cursor, readErr = dfr.readLine(f, cursor, readBuffer, lineBuffer)
                        if readErr != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">line = lineBuffer.String()

                        if util.String.HasPrefixCaseInsensitive(line, "--") </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">if util.String.HasPrefixCaseInsensitive(line, "set") </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">if util.String.HasPrefixCaseInsensitive(line, "copy") </span><span class="cov0" title="0">{
                                if !util.String.HasSuffixCaseInsensitive(line, "from stdin;") </span><span class="cov0" title="0">{
                                        err = fmt.Errorf("only `stdin` from clauses supported at this time, cannot continue")
                                        return
                                }</span>

                                <span class="cov0" title="0">stmt, err = dfr.executeCopyLine(line, c, tx)
                                if err != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">state = 1
                                continue</span>
                        }

                        <span class="cov0" title="0">err = c.ExecInTx(line, tx)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                case 1:<span class="cov0" title="0">
                        pieces, cursor, readErr = dfr.readTabLine(f, cursor, readBuffer, lineBuffer)
                        if readErr != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">if len(pieces) == 0 </span><span class="cov0" title="0">{
                                err = fmt.Errorf("empty data line, we error on this for now")
                                return
                        }</span>

                        <span class="cov0" title="0">if len(pieces) == 1 &amp;&amp; util.String.HasPrefixCaseInsensitive(pieces[0].(string), `\.`) </span><span class="cov0" title="0">{
                                err = stmt.Close()
                                if err != nil </span><span class="cov0" title="0">{
                                        return
                                }</span>
                                <span class="cov0" title="0">state = 0
                                continue</span>
                        }

                        <span class="cov0" title="0">_, err = stmt.Exec(pieces...)
                        if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (dfr *DataFileReader) executeCopyLine(line string, c *db.Connection, tx *sql.Tx) (*sql.Stmt, error) <span class="cov0" title="0">{
        pieces := dfr.extractCopyLine(line)
        if len(pieces) &lt; 3 </span><span class="cov0" title="0">{
                return nil, exception.New("Invalid `COPY ...` line, cannot continue.")
        }</span>
        <span class="cov0" title="0">tableName := pieces[1]
        columnCSV := pieces[2]
        columns := strings.Split(columnCSV, ", ")
        return tx.Prepare(pq.CopyIn(tableName, columns...))</span>
}

// regexExtractSubMatches returns sub matches for an expr because go's regexp library is weird.
func (dfr *DataFileReader) extractCopyLine(line string) []string <span class="cov0" title="0">{
        allResults := dfr.copyExtractor.FindAllStringSubmatch(line, -1)
        results := []string{}
        for _, resultSet := range allResults </span><span class="cov0" title="0">{
                for _, result := range resultSet </span><span class="cov0" title="0">{
                        results = append(results, result)
                }</span>
        }

        <span class="cov0" title="0">return results</span>
}

func (dfr *DataFileReader) extractDataLine(line string) []interface{} <span class="cov0" title="0">{
        var values []interface{}
        var value string
        var state int

        appendValue := func() </span><span class="cov0" title="0">{
                if value == `\N` </span><span class="cov0" title="0">{
                        values = append(values, nil)
                }</span> else<span class="cov0" title="0"> {
                        values = append(values, value)
                }</span>
        }

        <span class="cov0" title="0">for _, r := range line </span><span class="cov0" title="0">{
                switch state </span>{
                case 0:<span class="cov0" title="0">
                        if r == runeTab </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">state = 1
                        value = value + string(r)</span>
                case 1:<span class="cov0" title="0">
                        if r == runeTab </span><span class="cov0" title="0">{
                                appendValue()
                                state = 0
                                value = ""
                                continue</span>
                        }

                        <span class="cov0" title="0">value = value + string(r)</span>
                }
        }

        <span class="cov0" title="0">if len(value) &gt; 0 </span><span class="cov0" title="0">{
                appendValue()
        }</span>

        <span class="cov0" title="0">return values</span>
}

// readLine reads a file until a newline.
func (dfr *DataFileReader) readLine(f io.ReaderAt, cursor int64, readBuffer []byte, lineBuffer *bytes.Buffer) (int64, error) <span class="cov8" title="1">{
        // bytesRead is the return from the ReadAt function
        // it indicates how many effective bytes we read from the stream.
        var bytesRead int
        // err is our primary indicator if there was an issue with the stream
        // or if we've reached the end of the file.
        var err error
        // b is the byte we're reading at a time.
        var b byte

        // while we haven't hit an error (this includes EOF!)
        for err == nil </span><span class="cov8" title="1">{
                // read the stream
                bytesRead, err = f.ReadAt(readBuffer, cursor)
                // abort on error
                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{ //let this continue on eof
                        return cursor, err
                }</span>

                // slurp the read buffer.
                <span class="cov8" title="1">for readBufferIndex := 0; readBufferIndex &lt; bytesRead; readBufferIndex++ </span><span class="cov8" title="1">{
                        // advance the cursor regardless of what we read out.
                        // if we read a newline, great! we'll start the next character after the newline after.
                        cursor++

                        // slurp the byte out of the read buffer
                        b = readBuffer[readBufferIndex]
                        if b == byteNewLine </span><span class="cov8" title="1">{
                                // we bifurcate here because we need to forward the eof
                                // if we read the buffer exactly right.
                                if readBufferIndex == bytesRead-1 </span><span class="cov8" title="1">{
                                        return cursor, err
                                }</span>
                                // otherwise the newline may have happened
                                // before the actual eof.
                                <span class="cov8" title="1">return cursor, nil</span>
                        }

                        // b wasnt a newline, write it to the output buffer.
                        <span class="cov8" title="1">lineBuffer.WriteByte(b)</span>
                }
        }
        // we've reached the end of the file
        // there may not have been a newline
        // return what we have
        <span class="cov8" title="1">return cursor, err</span>
}

// readTabLine reads a file until a new line, collecting tab delimited sections into an array.
func (dfr *DataFileReader) readTabLine(f io.ReaderAt, cursor int64, readBuffer []byte, lineBuffer *bytes.Buffer) ([]interface{}, int64, error) <span class="cov8" title="1">{
        // bytesRead is the return from the ReadAt function
        // it indicates how many effective bytes we read from the stream.
        var bytesRead int
        // err is our primary indicator if there was an issue with the stream
        // or if we've reached the end of the file.
        var err error
        // b is the byte we're reading at a time.
        var b byte
        // pieces is used to collect the tab delimited components of the line.
        var pieces []interface{}
        // while we haven't hit an error (this includes EOF!)
        for err == nil </span><span class="cov8" title="1">{
                // read the stream
                bytesRead, err = f.ReadAt(readBuffer, cursor)
                // abort on error
                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{ //let this continue on eof
                        return pieces, cursor, err
                }</span>

                // slurp the read buffer.
                <span class="cov8" title="1">for readBufferIndex := 0; readBufferIndex &lt; bytesRead; readBufferIndex++ </span><span class="cov8" title="1">{
                        // advance the cursor regardless of what we read out.
                        // if we read a newline, great! we'll start the next character after the newline after.
                        cursor++

                        // slurp the byte out of the read buffer
                        b = readBuffer[readBufferIndex]
                        if b == byteNewLine </span><span class="cov8" title="1">{
                                // make sure to collect the remaining text in the
                                // linebuffer.
                                pieces = dfr.readTabLineAppendPiece(pieces, lineBuffer)

                                // we bifurcate here because we need to forward the eof
                                // if we read the buffer exactly right.
                                if readBufferIndex == bytesRead-1 </span><span class="cov0" title="0">{
                                        return pieces, cursor, err
                                }</span>
                                // otherwise the newline may have happened
                                // before the actual eof.
                                <span class="cov8" title="1">return pieces, cursor, nil</span>
                        }

                        // if we see a tab
                        // mark a tab section
                        // reset the buffer
                        <span class="cov8" title="1">if b == byteTab </span><span class="cov8" title="1">{
                                pieces = dfr.readTabLineAppendPiece(pieces, lineBuffer)
                                continue</span>
                        }

                        // b wasnt a newline, write it to the output buffer.
                        <span class="cov8" title="1">lineBuffer.WriteByte(b)</span>
                }
        }

        <span class="cov8" title="1">pieces = dfr.readTabLineAppendPiece(pieces, lineBuffer)
        // we've reached the end of the file
        // there may not have been a newline
        // return what we have
        return pieces, cursor, err</span>
}

// readTabLineAppendPiece is a commonly used code block
// that conditionally adds a new piece to the tab piece collection
func (dfr *DataFileReader) readTabLineAppendPiece(pieces []interface{}, lineBuffer *bytes.Buffer) []interface{} <span class="cov8" title="1">{
        if lineBuffer.Len() &gt; 0 </span><span class="cov8" title="1">{
                value := lineBuffer.String()
                lineBuffer.Reset()
                if value == null </span><span class="cov8" title="1">{
                        return append(pieces, nil)
                }</span>
                <span class="cov8" title="1">return append(pieces, value)</span>
        }
        <span class="cov8" title="1">return pieces</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package migration

var (
        defaultGroup = &amp;Group{}
)

// RegisterDefault adds migrations to the default group.
func RegisterDefault(m ...Migration) error <span class="cov0" title="0">{
        defaultGroup.Add(m...)
        return nil
}</span>

// SetDefault sets the default group.
func SetDefault(group *Group) <span class="cov0" title="0">{
        defaultGroup = group
}</span>

// Default returns the default migration suite.
func Default() *Group <span class="cov0" title="0">{
        return defaultGroup
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">package migration

import (
        "bytes"
        "fmt"
        "strings"
        "time"

        "github.com/blend/go-sdk/logger"
)

const (
        // Flag is a logger event flag.
        Flag logger.Flag = "db.migration"
)

// Event is a migration logger event.
type Event struct {
        ts     time.Time
        phase  string
        result string
        labels []string
        body   string
}

// Flag returns the logger flag.
func (e Event) Flag() logger.Flag <span class="cov0" title="0">{
        return Flag
}</span>

// Timestamp returns a timestamp.
func (e Event) Timestamp() time.Time <span class="cov0" title="0">{
        return e.ts
}</span>

func (e Event) colorizeFixedWidthLeftAligned(tf logger.TextFormatter, text string, color logger.AnsiColor, width int) string <span class="cov0" title="0">{
        fixedToken := fmt.Sprintf("%%-%ds", width)
        return tf.Colorize(fmt.Sprintf(fixedToken, text), color)
}</span>

// WriteText writes the migration event as text.
func (e Event) WriteText(tf logger.TextFormatter, buf *bytes.Buffer) <span class="cov0" title="0">{
        resultColor := logger.ColorBlue
        switch e.result </span>{
        case "skipped":<span class="cov0" title="0">
                resultColor = logger.ColorYellow</span>
        case "failed":<span class="cov0" title="0">
                resultColor = logger.ColorRed</span>
        }

        <span class="cov0" title="0">buf.WriteString(e.colorizeFixedWidthLeftAligned(tf, e.phase, logger.ColorBlue, 5))
        buf.WriteRune(logger.RuneSpace)
        buf.WriteString(tf.Colorize("--", logger.ColorLightBlack))
        buf.WriteRune(logger.RuneSpace)
        buf.WriteString(e.colorizeFixedWidthLeftAligned(tf, e.result, resultColor, 5))

        if len(e.labels) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteRune(logger.RuneSpace)
                buf.WriteString(strings.Join(e.labels, " &gt; "))
        }</span>
        <span class="cov0" title="0">if len(e.body) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteRune(logger.RuneSpace)
                buf.WriteString(tf.Colorize("--", logger.ColorLightBlack))
                buf.WriteRune(logger.RuneSpace)
                buf.WriteString(e.body)
        }</span>
}

// WriteJSON implements logger.JSONWritable.
func (e Event) WriteJSON() logger.JSONObj <span class="cov0" title="0">{
        return logger.JSONObj{
                "phase":  e.phase,
                "result": e.result,
                "labels": e.labels,
                "body":   e.body,
        }
}</span>

// StatsEvent is a migration logger event.
type StatsEvent struct {
        ts      time.Time
        applied int
        skipped int
        failed  int
        total   int
}

// Flag returns the logger flag.
func (se StatsEvent) Flag() logger.Flag <span class="cov0" title="0">{
        return Flag
}</span>

// Timestamp returns a timestamp.
func (se StatsEvent) Timestamp() time.Time <span class="cov0" title="0">{
        return se.ts
}</span>

// WriteText writes the event to a text writer.
func (se StatsEvent) WriteText(tf logger.TextFormatter, buf *bytes.Buffer) <span class="cov0" title="0">{
        buf.WriteString(fmt.Sprintf("%s applied %s skipped %s failed %s total",
                tf.Colorize(fmt.Sprintf("%d", se.applied), logger.ColorGreen),
                tf.Colorize(fmt.Sprintf("%d", se.skipped), logger.ColorLightGreen),
                tf.Colorize(fmt.Sprintf("%d", se.failed), logger.ColorRed),
                tf.Colorize(fmt.Sprintf("%d", se.total), logger.ColorLightWhite),
        ))
}</span>

// WriteJSON implements logger.JSONWritable.
func (se StatsEvent) WriteJSON() logger.JSONObj <span class="cov0" title="0">{
        return logger.JSONObj{
                "applied": se.applied,
                "skipped": se.skipped,
                "failed":  se.failed,
                "total":   se.total,
        }
}</span>
</pre>
		
		<pre class="file" id="file31" style="display: none">package migration

import (
        "database/sql"
        "fmt"

        "github.com/blend/go-sdk/db"
        "github.com/blend/go-sdk/exception"
)

// New creates a new migration group.
func New(migrations ...Migration) *Group <span class="cov0" title="0">{
        return NewGroup(migrations...)
}</span>

// NewGroup creates a new migration group.
func NewGroup(migrations ...Migration) *Group <span class="cov0" title="0">{
        r := &amp;Group{
                shouldAbortOnError: false,
        }
        r.Add(migrations...)
        return r
}</span>

// Group is an atomic series of migrations.
type Group struct {
        label              string
        shouldAbortOnError bool
        parent             Migration
        stack              []string
        log                *Logger
        migrations         []Migration
}

// Add adds migrations to the suite.
func (g *Group) Add(migrations ...Migration) <span class="cov0" title="0">{
        for _, m := range migrations </span><span class="cov0" title="0">{
                m.SetParent(g)
                g.migrations = append(g.migrations, m)
        }</span>
}

// Clear removes migrations from the suite.
func (g *Group) Clear() <span class="cov0" title="0">{
        g.migrations = []Migration{}
}</span>

// Label returns a label for the runner.
func (g *Group) Label() string <span class="cov0" title="0">{
        return g.label
}</span>

// SetLabel sets the migration label.
func (g *Group) SetLabel(value string) <span class="cov0" title="0">{
        g.label = value
}</span>

// WithLabel sets the migration label.
func (g *Group) WithLabel(value string) Migration <span class="cov0" title="0">{
        g.label = value
        return g
}</span>

// IsRoot denotes if the runner is the root runner (or not).
func (g *Group) IsRoot() bool <span class="cov0" title="0">{
        return g.parent == nil
}</span>

// Parent returns the runner's parent.
func (g *Group) Parent() Migration <span class="cov0" title="0">{
        return g.parent
}</span>

// SetParent sets the runner's parent.
func (g *Group) SetParent(parent Migration) <span class="cov0" title="0">{
        g.parent = parent
}</span>

// WithParent sets the runner's parent.
func (g *Group) WithParent(parent Migration) Migration <span class="cov0" title="0">{
        g.parent = parent
        return g
}</span>

// ShouldAbortOnError indicates that the group will abort if it sees an error from a step.
func (g *Group) ShouldAbortOnError() bool <span class="cov0" title="0">{
        return g.shouldAbortOnError
}</span>

// SetShouldAbortOnError sets if the group should abort on error.
func (g *Group) SetShouldAbortOnError(value bool) <span class="cov0" title="0">{
        g.shouldAbortOnError = value
}</span>

// WithShouldAbortOnError sets if the group should abort on error.
func (g *Group) WithShouldAbortOnError(value bool) *Group <span class="cov0" title="0">{
        g.shouldAbortOnError = value
        return g
}</span>

// Logger returns the logger.
func (g *Group) Logger() *Logger <span class="cov0" title="0">{
        return g.log
}</span>

// SetLogger sets the logger the Runner should use.
func (g *Group) SetLogger(logger *Logger) <span class="cov0" title="0">{
        g.log = logger
}</span>

// WithLogger sets the logger the Runner should use.
func (g *Group) WithLogger(logger *Logger) Migration <span class="cov0" title="0">{
        g.log = logger
        return g
}</span>

// IsTransactionIsolated returns if the migration is transaction isolated.
func (g *Group) IsTransactionIsolated() bool <span class="cov0" title="0">{
        return true
}</span>

// Test wraps the action in a transaction and rolls the transaction back upon completion.
func (g *Group) Test(c *db.Connection, optionalTx ...*sql.Tx) (err error) <span class="cov0" title="0">{
        if g.log != nil </span><span class="cov0" title="0">{
                g.log.Phase = "test"
        }</span>

        <span class="cov0" title="0">for _, m := range g.migrations </span><span class="cov0" title="0">{
                if g.log != nil </span><span class="cov0" title="0">{
                        m.SetLogger(g.log)
                }</span>

                <span class="cov0" title="0">err = g.invoke(true, m, c, optionalTx...)
                if err != nil &amp;&amp; g.shouldAbortOnError </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov0" title="0">return</span>
}

// Apply wraps the action in a transaction and commits it if there were no errors, rolling back if there were.
func (g *Group) Apply(c *db.Connection, optionalTx ...*sql.Tx) (err error) <span class="cov0" title="0">{
        if g.log != nil </span><span class="cov0" title="0">{
                g.log.Phase = "apply"
        }</span>

        <span class="cov0" title="0">for _, m := range g.migrations </span><span class="cov0" title="0">{
                if g.log != nil </span><span class="cov0" title="0">{
                        m.SetLogger(g.log)
                }</span>

                <span class="cov0" title="0">err = g.invoke(false, m, c, optionalTx...)
                if err != nil &amp;&amp; g.shouldAbortOnError </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">if g.IsRoot() &amp;&amp; g.log != nil </span><span class="cov0" title="0">{
                g.log.WriteStats()
        }</span>
        <span class="cov0" title="0">return</span>
}

func (g *Group) invoke(isTest bool, m Migration, c *db.Connection, optionalTx ...*sql.Tx) (err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("%v", err)
                }</span>
        }()

        <span class="cov0" title="0">if m.IsTransactionIsolated() </span><span class="cov0" title="0">{
                err = m.Apply(c, db.OptionalTx(optionalTx...))
                return
        }</span>

        <span class="cov0" title="0">var tx *sql.Tx
        tx, err = c.Begin()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer func() </span><span class="cov0" title="0">{
                if err == nil </span><span class="cov0" title="0">{
                        err = exception.Wrap(tx.Commit())
                }</span> else<span class="cov0" title="0"> {
                        err = exception.Nest(err, exception.New(tx.Rollback()))
                }</span>
        }()
        <span class="cov0" title="0">err = m.Apply(c, tx)
        return</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package migration

import (
        "database/sql"
        "fmt"
        "strings"

        "github.com/blend/go-sdk/db"
        "github.com/blend/go-sdk/util"
)

const (
        verbCreate = "create"
        verbAlter  = "alter"
        verbRun    = "run"

        nounColumn     = "column"
        nounTable      = "table"
        nounIndex      = "index"
        nounConstraint = "constraint"
        nounRole       = "role"

        adverbAlways    = "always"
        adverbExists    = "exists"
        adverbNotExists = "not exists"
)

// --------------------------------------------------------------------------------
// Guards
// --------------------------------------------------------------------------------

// DynamicGuard is a dynamic guard.
func DynamicGuard(label string, guard func(c *db.Connection, tx *sql.Tx) (bool, error)) Guard <span class="cov8" title="1">{
        return func(s *Step, c *db.Connection, tx *sql.Tx) error </span><span class="cov8" title="1">{
                s.SetLabel(label)

                proceed, err := guard(c, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return s.logger.Error(s, err)
                }</span>

                <span class="cov8" title="1">if proceed </span><span class="cov8" title="1">{
                        err = s.body.Invoke(c, tx)
                        if err != nil </span><span class="cov0" title="0">{
                                return s.logger.Error(s, err)
                        }</span>
                        <span class="cov8" title="1">return s.logger.Applyf(s, label)</span>
                }

                <span class="cov0" title="0">return s.logger.Skipf(s, label)</span>
        }
}

// AlwaysRun always runs a step.
func AlwaysRun() Guard <span class="cov0" title="0">{
        return func(s *Step, c *db.Connection, tx *sql.Tx) error </span><span class="cov0" title="0">{
                return guardImpl(s, verbRun, adverbAlways, c, tx)
        }</span>
}

// IfExists only runs the statement if the given item exists.
func IfExists(statement string) Guard <span class="cov0" title="0">{
        return func(s *Step, c *db.Connection, tx *sql.Tx) error </span><span class="cov0" title="0">{
                return guardImpl1(s, verbRun, adverbExists, exists, statement, c, tx)
        }</span>
}

// IfNotExists only runs the statement if the given item doesn't exist.
func IfNotExists(statement string) Guard <span class="cov0" title="0">{
        return func(s *Step, c *db.Connection, tx *sql.Tx) error </span><span class="cov0" title="0">{
                return guardImpl1(s, verbRun, adverbNotExists, notExists, statement, c, tx)
        }</span>
}

// ColumnNotExists creates a table on the given connection if it does not exist.
func ColumnNotExists(tableName, columnName string) Guard <span class="cov8" title="1">{
        return func(s *Step, c *db.Connection, tx *sql.Tx) error </span><span class="cov8" title="1">{
                return guardImpl2(s, verbCreate, nounColumn, columnExists, tableName, columnName, c, tx)
        }</span>
}

// ConstraintNotExists creates a table on the given connection if it does not exist.
func ConstraintNotExists(constraintName string) Guard <span class="cov0" title="0">{
        return func(s *Step, c *db.Connection, tx *sql.Tx) error </span><span class="cov0" title="0">{
                return guardImpl1(s, verbCreate, nounConstraint, constraintExists, constraintName, c, tx)
        }</span>
}

// TableNotExists creates a table on the given connection if it does not exist.
func TableNotExists(tableName string) Guard <span class="cov8" title="1">{
        return func(s *Step, c *db.Connection, tx *sql.Tx) error </span><span class="cov8" title="1">{
                return guardImpl1(s, verbCreate, nounTable, tableExists, tableName, c, tx)
        }</span>
}

// IndexNotExists creates a index on the given connection if it does not exist.
func IndexNotExists(tableName, indexName string) Guard <span class="cov8" title="1">{
        return func(s *Step, c *db.Connection, tx *sql.Tx) error </span><span class="cov8" title="1">{
                return guardImpl2(s, verbCreate, nounIndex, indexExists, tableName, indexName, c, tx)
        }</span>
}

// RoleNotExists creates a new role if it doesn't exist.
func RoleNotExists(roleName string) Guard <span class="cov8" title="1">{
        return func(s *Step, c *db.Connection, tx *sql.Tx) error </span><span class="cov8" title="1">{
                return guardImpl1(s, verbCreate, nounRole, roleExists, roleName, c, tx)
        }</span>
}

// ColumnExists alters an existing column, erroring if it doesn't exist
func ColumnExists(tableName, columnName string) Guard <span class="cov0" title="0">{
        return func(s *Step, c *db.Connection, tx *sql.Tx) error </span><span class="cov0" title="0">{
                return guardImpl2(s, verbAlter, nounTable, columnExists, tableName, columnName, c, tx)
        }</span>
}

// ConstraintExists alters an existing constraint, erroring if it doesn't exist
func ConstraintExists(constraintName string) Guard <span class="cov0" title="0">{
        return func(s *Step, c *db.Connection, tx *sql.Tx) error </span><span class="cov0" title="0">{
                return guardImpl1(s, verbAlter, nounConstraint, constraintExists, constraintName, c, tx)
        }</span>
}

// TableExists alters an existing table, erroring if it doesn't exist
func TableExists(tableName string) Guard <span class="cov0" title="0">{
        return func(s *Step, c *db.Connection, tx *sql.Tx) error </span><span class="cov0" title="0">{
                return guardImpl1(s, verbAlter, nounTable, tableExists, tableName, c, tx)
        }</span>
}

// IndexExists alters an existing index, erroring if it doesn't exist
func IndexExists(tableName, indexName string) Guard <span class="cov0" title="0">{
        return func(s *Step, c *db.Connection, tx *sql.Tx) error </span><span class="cov0" title="0">{
                return guardImpl2(s, verbAlter, nounIndex, indexExists, tableName, indexName, c, tx)
        }</span>
}

// RoleExists alters an existing role in the db
func RoleExists(roleName string) Guard <span class="cov0" title="0">{
        return func(s *Step, c *db.Connection, tx *sql.Tx) error </span><span class="cov0" title="0">{
                return guardImpl1(s, verbAlter, nounRole, roleExists, roleName, c, tx)
        }</span>
}

// actionName joins a noun and a verb
func actionName(verb, noun string) string <span class="cov8" title="1">{
        return fmt.Sprintf("%v %v", verb, noun)
}</span>

// guard1 is for guards that require (1) arg such as `create table` and create constraint`
type guard1 func(c *db.Connection, tx *sql.Tx, arg string) (bool, error)

// guard2 is for guards that require (2) args such as `create column` and `create index`
type guard2 func(c *db.Connection, tx *sql.Tx, arg1, arg2 string) (bool, error)

// actionImpl is an unguarded action, it doesn't care if something exists or doesn't
// it is a requirement of the operation to guard itself.
func guardImpl(s *Step, verb, noun string, c *db.Connection, tx *sql.Tx) error <span class="cov0" title="0">{
        err := s.body.Invoke(c, tx)

        if err != nil </span><span class="cov0" title="0">{
                if s.logger != nil </span><span class="cov0" title="0">{
                        return s.logger.Error(s, err)
                }</span>
                <span class="cov0" title="0">return nil</span>
        }
        <span class="cov0" title="0">if s.logger != nil </span><span class="cov0" title="0">{
                return s.logger.Applyf(s, "done")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func guardImpl1(s *Step, verb, noun string, guard guard1, subject string, c *db.Connection, tx *sql.Tx) error <span class="cov8" title="1">{
        s.SetLabel(actionName(verb, noun))

        if exists, err := guard(c, tx, subject); err != nil </span><span class="cov0" title="0">{
                return s.logger.Error(s, err)
        }</span> else<span class="cov8" title="1"> if (verb == verbCreate &amp;&amp; !exists) ||
                (verb == verbAlter &amp;&amp; exists) ||
                (verb == verbRun &amp;&amp; exists) </span><span class="cov8" title="1">{
                err = s.body.Invoke(c, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return s.logger.Error(s, err)
                }</span>
                <span class="cov8" title="1">return s.logger.Applyf(s, "%s `%s`", verb, subject)</span>
        }
        <span class="cov8" title="1">return s.logger.Skipf(s, "%s `%s`", verb, subject)</span>
}

func guardImpl2(s *Step, verb, noun string, guard guard2, subject1, subject2 string, c *db.Connection, tx *sql.Tx) error <span class="cov8" title="1">{
        s.SetLabel(actionName(verb, noun))

        if exists, err := guard(c, tx, subject1, subject2); err != nil </span><span class="cov0" title="0">{
                return s.logger.Error(s, err)
        }</span> else<span class="cov8" title="1"> if (verb == verbCreate &amp;&amp; !exists) || (verb == verbAlter &amp;&amp; exists) || (verb == verbRun &amp;&amp; exists) </span><span class="cov8" title="1">{
                err = s.body.Invoke(c, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return s.logger.Error(s, err)
                }</span>

                <span class="cov8" title="1">return s.logger.Applyf(s, "%s `%s` on `%s`", verb, subject2, subject1)</span>
        }

        <span class="cov0" title="0">return s.logger.Skipf(s, "%s `%s` on `%s`", verb, subject2, subject1)</span>
}

// --------------------------------------------------------------------------------
// Guards Implementations
// --------------------------------------------------------------------------------

// TableExists returns if a table exists on the given connection.
func tableExists(c *db.Connection, tx *sql.Tx, tableName string) (bool, error) <span class="cov8" title="1">{
        return c.QueryInTx(`SELECT 1 FROM pg_catalog.pg_tables WHERE tablename = $1`, tx, strings.ToLower(tableName)).Any()
}</span>

// ColumnExists returns if a column exists on a table on the given connection.
func columnExists(c *db.Connection, tx *sql.Tx, tableName, columnName string) (bool, error) <span class="cov8" title="1">{
        return c.QueryInTx(`SELECT 1 FROM information_schema.columns i WHERE i.table_name = $1 and i.column_name = $2`, tx, strings.ToLower(tableName), strings.ToLower(columnName)).Any()
}</span>

// ConstraintExists returns if a constraint exists on a table on the given connection.
func constraintExists(c *db.Connection, tx *sql.Tx, constraintName string) (bool, error) <span class="cov8" title="1">{
        return c.QueryInTx(`SELECT 1 FROM pg_constraint WHERE conname = $1`, tx, strings.ToLower(constraintName)).Any()
}</span>

// IndexExists returns if a index exists on a table on the given connection.
func indexExists(c *db.Connection, tx *sql.Tx, tableName, indexName string) (bool, error) <span class="cov8" title="1">{
        return c.QueryInTx(`SELECT 1 FROM pg_catalog.pg_index ix join pg_catalog.pg_class t on t.oid = ix.indrelid join pg_catalog.pg_class i on i.oid = ix.indexrelid WHERE t.relname = $1 and i.relname = $2 and t.relkind = 'r'`, tx, strings.ToLower(tableName), strings.ToLower(indexName)).Any()
}</span>

// roleExists returns if a role exists or not.
func roleExists(c *db.Connection, tx *sql.Tx, roleName string) (bool, error) <span class="cov8" title="1">{
        return c.QueryInTx(`SELECT 1 FROM pg_roles WHERE rolname ilike $1`, tx, roleName).Any()
}</span>

// exists returns if a statement has results.
func exists(c *db.Connection, tx *sql.Tx, selectStatement string) (bool, error) <span class="cov0" title="0">{
        if !util.String.HasPrefixCaseInsensitive(selectStatement, "select") </span><span class="cov0" title="0">{
                return false, fmt.Errorf("statement must be a `SELECT`")
        }</span>
        <span class="cov0" title="0">return c.QueryInTx(selectStatement, tx).Any()</span>
}

// notExists returns if a statement doesnt have results.
func notExists(c *db.Connection, tx *sql.Tx, selectStatement string) (bool, error) <span class="cov8" title="1">{
        if !util.String.HasPrefixCaseInsensitive(selectStatement, "select") </span><span class="cov0" title="0">{
                return false, fmt.Errorf("statement must be a `SELECT`")
        }</span>
        <span class="cov8" title="1">return c.QueryInTx(selectStatement, tx).None()</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package migration

import (
        "fmt"
        "time"

        "github.com/blend/go-sdk/logger"
)

// NewLogger returns a new logger instance.
func NewLogger(log *logger.Logger) *Logger <span class="cov0" title="0">{
        log.Enable(Flag)
        return &amp;Logger{
                Output: log,
        }
}</span>

// NewLoggerFromEnv returns a new logger instance.
func NewLoggerFromEnv() *Logger <span class="cov0" title="0">{
        log := logger.NewFromEnv()
        log.Enable(Flag)
        return &amp;Logger{
                Output: log,
        }
}</span>

// Logger is a logger for migration steps.
type Logger struct {
        Output *logger.Logger
        Phase  string // `test` or `apply`
        Result string // `apply` or `skipped` or `failed`

        applied int
        skipped int
        failed  int
        total   int
}

// Applyf active actions to the log.
func (l *Logger) Applyf(m Migration, body string, args ...interface{}) error <span class="cov8" title="1">{
        if l == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">l.applied = l.applied + 1
        l.total = l.total + 1
        l.Result = "applied"
        l.write(m, fmt.Sprintf(body, args...))
        return nil</span>
}

// Skipf passive actions to the log.
func (l *Logger) Skipf(m Migration, body string, args ...interface{}) error <span class="cov8" title="1">{
        if l == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov0" title="0">l.skipped = l.skipped + 1
        l.total = l.total + 1
        l.Result = "skipped"
        l.write(m, fmt.Sprintf(body, args...))
        return nil</span>
}

// Errorf writes errors to the log.
func (l *Logger) Error(m Migration, err error) error <span class="cov0" title="0">{
        if l == nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">l.failed = l.failed + 1
        l.total = l.total + 1
        l.Result = "failed"
        l.write(m, fmt.Sprintf("%v", err.Error()))
        return err</span>
}

// WriteStats writes final stats to output
func (l *Logger) WriteStats() <span class="cov0" title="0">{
        l.Output.SyncTrigger(StatsEvent{
                ts:      time.Now().UTC(),
                applied: l.applied,
                skipped: l.skipped,
                failed:  l.failed,
                total:   l.total,
        })
}</span>

func (l *Logger) colorize(text string, color logger.AnsiColor) string <span class="cov0" title="0">{
        if len(l.Output.Writers()) == 0 </span><span class="cov0" title="0">{
                return text
        }</span>
        <span class="cov0" title="0">if typed, isTyped := l.Output.Writers()[0].(logger.TextFormatter); isTyped </span><span class="cov0" title="0">{
                return typed.Colorize(text, color)
        }</span>
        <span class="cov0" title="0">return text</span>
}

func (l *Logger) write(m Migration, body string) <span class="cov0" title="0">{
        l.Output.SyncTrigger(Event{
                ts:     time.Now().UTC(),
                phase:  l.Phase,
                result: l.Result,
                labels: l.labels(m),
                body:   body,
        })
}</span>

func (l *Logger) labels(m Migration) []string <span class="cov0" title="0">{
        labels := []string{m.Label()}
        cursor := m.Parent()
        for cursor != nil </span><span class="cov0" title="0">{
                if len(cursor.Label()) &gt; 0 </span><span class="cov0" title="0">{
                        labels = append([]string{cursor.Label()}, labels...)
                }</span>
                <span class="cov0" title="0">cursor = cursor.Parent()</span>
        }
        <span class="cov0" title="0">return labels</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package migration

import (
        "database/sql"

        "github.com/blend/go-sdk/db"
)

// Statements is an alias to Body(...Statement(stmt))
func Statements(stmts ...string) Invocable <span class="cov8" title="1">{
        return statements(stmts)
}</span>

// statements is a collection of statements to run as an action.
// they are executed serially.
type statements []string

// Invoke executes the statement block
func (s statements) Invoke(c *db.Connection, tx *sql.Tx) (err error) <span class="cov8" title="1">{
        for _, step := range s </span><span class="cov8" title="1">{
                err = c.ExecInTx(step, tx)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package migration

import (
        "database/sql"

        "github.com/blend/go-sdk/db"
)

// NewStep is an alias to NewOperation.
func NewStep(guard Guard, body Invocable) *Step <span class="cov8" title="1">{
        return &amp;Step{
                guard: guard,
                body:  body,
        }
}</span>

// Step is a single guarded function.
type Step struct {
        label  string
        parent Migration
        logger *Logger

        guard Guard
        body  Invocable
}

// Label returns the operation label.
func (s *Step) Label() string <span class="cov0" title="0">{
        return s.label
}</span>

// SetLabel sets the operation label.
func (s *Step) SetLabel(label string) <span class="cov8" title="1">{
        s.label = label
}</span>

// WithLabel sets the operation label.
func (s *Step) WithLabel(label string) Migration <span class="cov0" title="0">{
        s.label = label
        return s
}</span>

// Parent returns the parent.
func (s *Step) Parent() Migration <span class="cov0" title="0">{
        return s.parent
}</span>

// SetParent sets the operation parent.
func (s *Step) SetParent(parent Migration) <span class="cov0" title="0">{
        s.parent = parent
}</span>

// WithParent sets the operation parent.
func (s *Step) WithParent(parent Migration) Migration <span class="cov0" title="0">{
        s.parent = parent
        return s
}</span>

// Logger returns the logger
func (s *Step) Logger() *Logger <span class="cov0" title="0">{
        return s.logger
}</span>

// SetLogger implements the migration method `SetLogger`.
func (s *Step) SetLogger(logger *Logger) <span class="cov0" title="0">{
        s.logger = logger
}</span>

// WithLogger implements the migration method `WithLogger`.
func (s *Step) WithLogger(logger *Logger) Migration <span class="cov0" title="0">{
        s.logger = logger
        return s
}</span>

// IsTransactionIsolated returns if this migration requires its own transaction.
func (s *Step) IsTransactionIsolated() bool <span class="cov0" title="0">{
        return false
}</span>

// Test wraps the action in a transaction and rolls the transaction back upon completion.
func (s *Step) Test(c *db.Connection, optionalTx ...*sql.Tx) (err error) <span class="cov0" title="0">{
        err = s.Apply(c, optionalTx...)
        return
}</span>

// Apply wraps the action in a transaction and commits it if there were no errors, rolling back if there were.
func (s *Step) Apply(c *db.Connection, txs ...*sql.Tx) (err error) <span class="cov8" title="1">{
        tx := db.OptionalTx(txs...)
        err = s.guard(s, c, tx)
        return
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package db

import (
        "database/sql"
        "reflect"

        "github.com/blend/go-sdk/exception"
)

// PopulateByName sets the values of an object from the values of a sql.Rows object using column names.
func PopulateByName(object interface{}, row *sql.Rows, cols *ColumnCollection) error <span class="cov0" title="0">{
        rowColumns, rowColumnsErr := row.Columns()

        if rowColumnsErr != nil </span><span class="cov0" title="0">{
                return exception.Wrap(rowColumnsErr)
        }</span>

        <span class="cov0" title="0">var values = make([]interface{}, len(rowColumns))
        var columnLookup = cols.Lookup()

        for i, name := range rowColumns </span><span class="cov0" title="0">{
                if col, ok := columnLookup[name]; ok </span><span class="cov0" title="0">{
                        if col.IsJSON </span><span class="cov0" title="0">{
                                str := ""
                                values[i] = &amp;str
                        }</span> else<span class="cov0" title="0"> {
                                values[i] = reflect.New(reflect.PtrTo(col.FieldType)).Interface()
                        }</span>
                } else<span class="cov0" title="0"> {
                        var value interface{}
                        values[i] = &amp;value
                }</span>
        }

        <span class="cov0" title="0">scanErr := row.Scan(values...)

        if scanErr != nil </span><span class="cov0" title="0">{
                return exception.Wrap(scanErr)
        }</span>

        <span class="cov0" title="0">for i, v := range values </span><span class="cov0" title="0">{
                colName := rowColumns[i]

                if field, ok := columnLookup[colName]; ok </span><span class="cov0" title="0">{
                        err := field.SetValue(object, v)
                        if err != nil </span><span class="cov0" title="0">{
                                return exception.Wrap(err)
                        }</span>
                }
        }

        <span class="cov0" title="0">return nil</span>
}

// PopulateInOrder sets the values of an object in order from a sql.Rows object.
// Only use this method if you're certain of the column order. It is faster than populateByName.
// Optionally if your object implements Populatable this process will be skipped completely, which is even faster.
func PopulateInOrder(object DatabaseMapped, row *sql.Rows, cols *ColumnCollection) error <span class="cov8" title="1">{
        var values = make([]interface{}, cols.Len())

        for i, col := range cols.Columns() </span><span class="cov8" title="1">{
                if col.FieldType.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                        if col.IsJSON </span><span class="cov0" title="0">{
                                str := ""
                                values[i] = &amp;str
                        }</span> else<span class="cov0" title="0"> {
                                blankPtr := reflect.New(reflect.PtrTo(col.FieldType))
                                if blankPtr.CanAddr() </span><span class="cov0" title="0">{
                                        values[i] = blankPtr.Addr()
                                }</span> else<span class="cov0" title="0"> {
                                        values[i] = blankPtr.Interface()
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        if col.IsJSON </span><span class="cov0" title="0">{
                                str := ""
                                values[i] = &amp;str
                        }</span> else<span class="cov8" title="1"> {
                                values[i] = reflect.New(reflect.PtrTo(col.FieldType)).Interface()
                        }</span>
                }
        }

        <span class="cov8" title="1">scanErr := row.Scan(values...)

        if scanErr != nil </span><span class="cov0" title="0">{
                return exception.Wrap(scanErr)
        }</span>

        <span class="cov8" title="1">columns := cols.Columns()
        for i, v := range values </span><span class="cov8" title="1">{
                field := columns[i]
                err := field.SetValue(object, v)
                if err != nil </span><span class="cov0" title="0">{
                        return exception.Wrap(err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package db

import (
        "context"
        "database/sql"
        "reflect"
        "time"

        "github.com/blend/go-sdk/exception"
        "github.com/blend/go-sdk/logger"
)

// --------------------------------------------------------------------------------
// Query Result
// --------------------------------------------------------------------------------

// Query is the intermediate result of a query.
type Query struct {
        statement      string
        statementLabel string
        args           []interface{}

        start time.Time
        rows  *sql.Rows

        stmt       *sql.Stmt
        fireEvents bool
        conn       *Connection
        ctx        context.Context
        tx         *sql.Tx
        err        error
}

// Close closes and releases any resources retained by the QueryResult.
func (q *Query) Close() error <span class="cov8" title="1">{
        var rowsErr error
        var stmtErr error

        if q.rows != nil </span><span class="cov8" title="1">{
                rowsErr = q.rows.Close()
                q.rows = nil
        }</span>

        <span class="cov8" title="1">if !q.conn.useStatementCache </span><span class="cov0" title="0">{
                if q.stmt != nil </span><span class="cov0" title="0">{
                        stmtErr = q.stmt.Close()
                        q.stmt = nil
                }</span>
        }
        <span class="cov8" title="1">return exception.Nest(rowsErr, stmtErr)</span>
}

// CachedAs sets the statement cache label for the query.
func (q *Query) CachedAs(cacheLabel string) *Query <span class="cov8" title="1">{
        q.statementLabel = cacheLabel
        return q
}</span>

// Execute runs a given query, yielding the raw results.
func (q *Query) Execute() (stmt *sql.Stmt, rows *sql.Rows, err error) <span class="cov8" title="1">{
        var stmtErr error
        if q.shouldCacheStatement() </span><span class="cov8" title="1">{
                stmt, stmtErr = q.conn.PrepareCached(q.statementLabel, q.statement, q.tx)
        }</span> else<span class="cov8" title="1"> {
                stmt, stmtErr = q.conn.Prepare(q.statement, q.tx)
        }</span>

        <span class="cov8" title="1">if stmtErr != nil </span><span class="cov0" title="0">{
                if q.shouldCacheStatement() </span><span class="cov0" title="0">{
                        q.conn.statementCache.InvalidateStatement(q.statementLabel)
                }</span>
                <span class="cov0" title="0">err = exception.Wrap(stmtErr)
                return</span>
        }

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        if q.conn.useStatementCache </span><span class="cov0" title="0">{
                                err = exception.Nest(err, exception.New(r))
                        }</span> else<span class="cov0" title="0"> {
                                err = exception.Nest(err, exception.New(r), stmt.Close())
                        }</span>
                }
        }()

        <span class="cov8" title="1">var queryErr error
        if q.ctx != nil </span><span class="cov0" title="0">{
                rows, queryErr = stmt.QueryContext(q.ctx, q.args...)
        }</span> else<span class="cov8" title="1"> {
                rows, queryErr = stmt.Query(q.args...)
        }</span>

        <span class="cov8" title="1">if queryErr != nil </span><span class="cov0" title="0">{
                if q.shouldCacheStatement() </span><span class="cov0" title="0">{
                        q.conn.statementCache.InvalidateStatement(q.statementLabel)
                }</span>
                <span class="cov0" title="0">err = exception.Wrap(queryErr)</span>
        }
        <span class="cov8" title="1">return</span>
}

// Any returns if there are any results for the query.
func (q *Query) Any() (hasRows bool, err error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{ err = q.finalizer(recover(), err) }</span>()

        <span class="cov8" title="1">q.stmt, q.rows, q.err = q.Execute()
        if q.err != nil </span><span class="cov0" title="0">{
                hasRows = false
                err = exception.Wrap(q.err)
                return
        }</span>

        <span class="cov8" title="1">rowsErr := q.rows.Err()
        if rowsErr != nil </span><span class="cov0" title="0">{
                hasRows = false
                err = exception.Wrap(rowsErr)
                return
        }</span>

        <span class="cov8" title="1">hasRows = q.rows.Next()
        return</span>
}

// None returns if there are no results for the query.
func (q *Query) None() (hasRows bool, err error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{ err = q.finalizer(recover(), err) }</span>()

        <span class="cov8" title="1">q.stmt, q.rows, q.err = q.Execute()

        if q.err != nil </span><span class="cov0" title="0">{
                hasRows = false
                err = exception.Wrap(q.err)
                return
        }</span>

        <span class="cov8" title="1">rowsErr := q.rows.Err()
        if rowsErr != nil </span><span class="cov0" title="0">{
                hasRows = false
                err = exception.Wrap(rowsErr)
                return
        }</span>

        <span class="cov8" title="1">hasRows = !q.rows.Next()
        return</span>
}

// Scan writes the results to a given set of local variables.
func (q *Query) Scan(args ...interface{}) (err error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{ err = q.finalizer(recover(), err) }</span>()

        <span class="cov8" title="1">q.stmt, q.rows, q.err = q.Execute()
        if q.err != nil </span><span class="cov0" title="0">{
                err = exception.Wrap(q.err)
                return
        }</span>

        <span class="cov8" title="1">rowsErr := q.rows.Err()
        if rowsErr != nil </span><span class="cov0" title="0">{
                err = exception.Wrap(rowsErr)
                return
        }</span>

        <span class="cov8" title="1">if q.rows.Next() </span><span class="cov8" title="1">{
                scanErr := q.rows.Scan(args...)
                if scanErr != nil </span><span class="cov0" title="0">{
                        err = exception.Wrap(scanErr)
                }</span>
        }

        <span class="cov8" title="1">return</span>
}

// Out writes the query result to a single object via. reflection mapping.
func (q *Query) Out(object interface{}) (err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{ err = q.finalizer(recover(), err) }</span>()

        <span class="cov0" title="0">q.stmt, q.rows, q.err = q.Execute()
        if q.err != nil </span><span class="cov0" title="0">{
                err = exception.Wrap(q.err)
                return
        }</span>

        <span class="cov0" title="0">rowsErr := q.rows.Err()
        if rowsErr != nil </span><span class="cov0" title="0">{
                err = exception.Wrap(rowsErr)
                return
        }</span>

        <span class="cov0" title="0">sliceType := reflectType(object)
        if sliceType.Kind() != reflect.Struct </span><span class="cov0" title="0">{
                err = exception.New("destination object is not a struct")
                return
        }</span>

        <span class="cov0" title="0">columnMeta := getCachedColumnCollectionFromInstance(object)
        var popErr error
        if q.rows.Next() </span><span class="cov0" title="0">{
                if populatable, isPopulatable := object.(Populatable); isPopulatable </span><span class="cov0" title="0">{
                        popErr = populatable.Populate(q.rows)
                }</span> else<span class="cov0" title="0"> {
                        popErr = PopulateByName(object, q.rows, columnMeta)
                }</span>
                <span class="cov0" title="0">if popErr != nil </span><span class="cov0" title="0">{
                        err = popErr
                        return
                }</span>
        }

        <span class="cov0" title="0">return</span>
}

// OutMany writes the query results to a slice of objects.
func (q *Query) OutMany(collection interface{}) (err error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{ err = q.finalizer(recover(), err) }</span>()

        <span class="cov8" title="1">q.stmt, q.rows, q.err = q.Execute()
        if q.err != nil </span><span class="cov0" title="0">{
                err = exception.Wrap(q.err)
                return err
        }</span>

        <span class="cov8" title="1">rowsErr := q.rows.Err()
        if rowsErr != nil </span><span class="cov0" title="0">{
                err = exception.Wrap(rowsErr)
                return
        }</span>

        <span class="cov8" title="1">sliceType := reflectType(collection)
        if sliceType.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                err = exception.New("destination collection is not a slice")
                return
        }</span>

        <span class="cov8" title="1">sliceInnerType := reflectSliceType(collection)
        collectionValue := reflectValue(collection)

        v := makeNew(sliceInnerType)
        meta := getCachedColumnCollectionFromType(newColumnCacheKey(sliceInnerType), sliceInnerType)

        isPopulatable := isPopulatable(v)

        var popErr error
        didSetRows := false
        for q.rows.Next() </span><span class="cov8" title="1">{
                newObj := makeNew(sliceInnerType)

                if isPopulatable </span><span class="cov8" title="1">{
                        popErr = asPopulatable(newObj).Populate(q.rows)
                }</span> else<span class="cov0" title="0"> {
                        popErr = PopulateByName(newObj, q.rows, meta)
                }</span>

                <span class="cov8" title="1">if popErr != nil </span><span class="cov0" title="0">{
                        err = popErr
                        return
                }</span>
                <span class="cov8" title="1">newObjValue := reflectValue(newObj)
                collectionValue.Set(reflect.Append(collectionValue, newObjValue))
                didSetRows = true</span>
        }

        <span class="cov8" title="1">if !didSetRows </span><span class="cov0" title="0">{
                collectionValue.Set(reflect.MakeSlice(sliceType, 0, 0))
        }</span>
        <span class="cov8" title="1">return</span>
}

// Each writes the query results to a slice of objects.
func (q *Query) Each(consumer RowsConsumer) (err error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{ err = q.finalizer(recover(), err) }</span>()

        <span class="cov8" title="1">q.stmt, q.rows, q.err = q.Execute()
        if q.err != nil </span><span class="cov0" title="0">{
                return q.err
        }</span>

        <span class="cov8" title="1">rowsErr := q.rows.Err()
        if rowsErr != nil </span><span class="cov0" title="0">{
                err = exception.Wrap(rowsErr)
                return
        }</span>

        <span class="cov8" title="1">for q.rows.Next() </span><span class="cov8" title="1">{
                err = consumer(q.rows)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// --------------------------------------------------------------------------------
// helpers
// --------------------------------------------------------------------------------

func (q *Query) finalizer(r interface{}, err error) error <span class="cov8" title="1">{
        if r != nil </span><span class="cov8" title="1">{
                recoveryException := exception.New(r)
                err = exception.Nest(err, recoveryException)
        }</span>

        <span class="cov8" title="1">if closeErr := q.Close(); closeErr != nil </span><span class="cov0" title="0">{
                err = exception.Nest(err, closeErr)
        }</span>

        <span class="cov8" title="1">if q.fireEvents </span><span class="cov0" title="0">{
                q.conn.fireEvent(logger.Query, q.statement, time.Since(q.start), err, q.statementLabel)
        }</span>
        <span class="cov8" title="1">return err</span>
}

func (q *Query) shouldCacheStatement() bool <span class="cov8" title="1">{
        return q.conn.useStatementCache &amp;&amp; len(q.statementLabel) &gt; 0
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package db

import (
        "database/sql"
        "sync"
)

// newStatementCache returns a new `StatementCache`.
func newStatementCache(dbc *sql.DB) *StatementCache <span class="cov8" title="1">{
        return &amp;StatementCache{
                dbc:       dbc,
                cacheLock: &amp;sync.Mutex{},
                cache:     make(map[string]*sql.Stmt),
        }
}</span>

// StatementCache is a cache of prepared statements.
type StatementCache struct {
        dbc       *sql.DB
        cacheLock *sync.Mutex
        cache     map[string]*sql.Stmt
}

// Close implements io.Closer.
func (sc *StatementCache) Close() error <span class="cov8" title="1">{
        return sc.Clear()
}</span>

func (sc *StatementCache) closeAll() error <span class="cov8" title="1">{
        var err error
        for _, stmt := range sc.cache </span><span class="cov8" title="1">{
                err = stmt.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Clear deletes all cached statements.
func (sc *StatementCache) Clear() error <span class="cov8" title="1">{
        sc.cacheLock.Lock()
        defer sc.cacheLock.Unlock()

        err := sc.closeAll()
        sc.cache = make(map[string]*sql.Stmt)
        return err
}</span>

// HasStatement returns if the cache contains a statement.
func (sc *StatementCache) HasStatement(statementID string) bool <span class="cov8" title="1">{
        return sc.getCachedStatement(statementID) != nil
}</span>

// InvalidateStatement removes a statement from the cache.
func (sc *StatementCache) InvalidateStatement(statementID string) <span class="cov0" title="0">{
        sc.cacheLock.Lock()
        defer sc.cacheLock.Unlock()

        if _, hasStatement := sc.cache[statementID]; hasStatement </span><span class="cov0" title="0">{
                delete(sc.cache, statementID)
        }</span>
}

func (sc *StatementCache) getCachedStatement(statementID string) *sql.Stmt <span class="cov8" title="1">{
        sc.cacheLock.Lock()
        defer sc.cacheLock.Unlock()
        if stmt, hasStmt := sc.cache[statementID]; hasStmt </span><span class="cov8" title="1">{
                return stmt
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Prepare returns a cached expression for a statement, or creates and caches a new one.
func (sc *StatementCache) Prepare(id, statementProvider string) (*sql.Stmt, error) <span class="cov8" title="1">{
        cached := sc.getCachedStatement(id)
        if cached != nil </span><span class="cov8" title="1">{
                return cached, nil
        }</span>

        <span class="cov8" title="1">sc.cacheLock.Lock()
        defer sc.cacheLock.Unlock()
        if stmt, hasStmt := sc.cache[id]; hasStmt </span><span class="cov0" title="0">{
                return stmt, nil
        }</span>

        <span class="cov8" title="1">stmt, err := sc.dbc.Prepare(statementProvider)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">sc.cache[id] = stmt
        return stmt, nil</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package db

import (
        "database/sql"
        "fmt"
        "reflect"
        "strconv"
        "strings"

        "github.com/blend/go-sdk/exception"
)

// --------------------------------------------------------------------------------
// Utility Methods
// --------------------------------------------------------------------------------

// OptionalTx returns the first of a variadic set of txs.
// It is useful if you want to have a tx an optional parameter.
func OptionalTx(txs ...*sql.Tx) *sql.Tx <span class="cov8" title="1">{
        if len(txs) &gt; 0 </span><span class="cov8" title="1">{
                return txs[0]
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Tx is an alias for OptionalTx
func Tx(txs ...*sql.Tx) *sql.Tx <span class="cov0" title="0">{
        return OptionalTx(txs...)
}</span>

// TableNameByType returns the table name for a given reflect.Type by instantiating it and calling o.TableName().
// The type must implement DatabaseMapped or an exception will be returned.
func TableNameByType(t reflect.Type) string <span class="cov8" title="1">{
        instance := reflect.New(t).Interface()
        if typed, isTyped := instance.(TableNameProvider); isTyped </span><span class="cov8" title="1">{
                return typed.TableName()
        }</span>
        <span class="cov0" title="0">return strings.ToLower(t.Name())</span>
}

// TableName returns the mapped table name for a given instance; it will sniff for the `TableName()` function on the type.
func TableName(obj DatabaseMapped) string <span class="cov8" title="1">{
        if typed, isTyped := obj.(TableNameProvider); isTyped </span><span class="cov8" title="1">{
                return typed.TableName()
        }</span>
        <span class="cov8" title="1">return strings.ToLower(reflectType(obj).Name())</span>
}

// --------------------------------------------------------------------------------
// String Utility Methods
// --------------------------------------------------------------------------------

// ParamTokens returns a csv token string in the form "$1,$2,$3...$N" if passed (1, N).
func ParamTokens(startAt, count int) string <span class="cov0" title="0">{
        if count &lt; 1 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">var str string
        for i := startAt; i &lt; startAt+count; i++ </span><span class="cov0" title="0">{
                str = str + fmt.Sprintf("$%d", i)
                if i &lt; (startAt + count - 1) </span><span class="cov0" title="0">{
                        str = str + ","
                }</span>
        }
        <span class="cov0" title="0">return str</span>
}

// --------------------------------------------------------------------------------
// Internal / Reflection Utility Methods
// --------------------------------------------------------------------------------

// AsPopulatable casts an object as populatable.
func asPopulatable(object interface{}) Populatable <span class="cov8" title="1">{
        return object.(Populatable)
}</span>

// isPopulatable returns if an object is populatable
func isPopulatable(object interface{}) bool <span class="cov8" title="1">{
        _, isPopulatable := object.(Populatable)
        return isPopulatable
}</span>

// reflectValue returns the reflect.Value for an object following pointers.
func reflectValue(obj interface{}) reflect.Value <span class="cov8" title="1">{
        v := reflect.ValueOf(obj)
        for v.Kind() == reflect.Ptr || v.Kind() == reflect.Interface </span><span class="cov8" title="1">{
                v = v.Elem()
        }</span>
        <span class="cov8" title="1">return v</span>
}

// reflectType retruns the reflect.Type for an object following pointers.
func reflectType(obj interface{}) reflect.Type <span class="cov8" title="1">{
        t := reflect.TypeOf(obj)
        for t.Kind() == reflect.Ptr || t.Kind() == reflect.Interface </span><span class="cov8" title="1">{
                t = t.Elem()
        }</span>

        <span class="cov8" title="1">return t</span>
}

// reflectSliceType returns the inner type of a slice following pointers.
func reflectSliceType(collection interface{}) reflect.Type <span class="cov8" title="1">{
        v := reflect.ValueOf(collection)
        for v.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                v = v.Elem()
        }</span>
        <span class="cov8" title="1">if v.Len() == 0 </span><span class="cov8" title="1">{
                t := v.Type()
                for t.Kind() == reflect.Ptr || t.Kind() == reflect.Slice </span><span class="cov8" title="1">{
                        t = t.Elem()
                }</span>
                <span class="cov8" title="1">return t</span>
        }
        <span class="cov8" title="1">v = v.Index(0)
        for v.Kind() == reflect.Interface || v.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                v = v.Elem()
        }</span>

        <span class="cov8" title="1">return v.Type()</span>
}

// makeWhereClause returns the sql `where` clause for a column collection, starting at a given index (used in sql $1 parameterization).
func makeWhereClause(pks *ColumnCollection, startAt int) string <span class="cov0" title="0">{
        whereClause := " WHERE "
        for i, pk := range pks.Columns() </span><span class="cov0" title="0">{
                whereClause = whereClause + fmt.Sprintf("%s = %s", pk.ColumnName, "$"+strconv.Itoa(i+startAt))
                if i &lt; (pks.Len() - 1) </span><span class="cov0" title="0">{
                        whereClause = whereClause + " AND "
                }</span>
        }

        <span class="cov0" title="0">return whereClause</span>
}

// paramTokensCSV returns a csv token string in the form "$1,$2,$3...$N"
func paramTokensCSV(num int) string <span class="cov8" title="1">{
        str := ""
        for i := 1; i &lt;= num; i++ </span><span class="cov8" title="1">{
                str = str + fmt.Sprintf("$%d", i)
                if i != num </span><span class="cov8" title="1">{
                        str = str + ","
                }</span>
        }
        <span class="cov8" title="1">return str</span>
}

// makeNewDatabaseMapped returns a new instance of a database mapped type.
func makeNewDatabaseMapped(t reflect.Type) (DatabaseMapped, error) <span class="cov8" title="1">{
        newInterface := reflect.New(t).Interface()
        if typed, isTyped := newInterface.(DatabaseMapped); isTyped </span><span class="cov8" title="1">{
                return typed.(DatabaseMapped), nil
        }</span>
        <span class="cov0" title="0">return nil, exception.Newf("`%s` does not implement DatabaseMapped.", t.Name())</span>
}

// makeNew creates a new object.
func makeNew(t reflect.Type) interface{} <span class="cov8" title="1">{
        return reflect.New(t).Interface()
}</span>

func makeSliceOfType(t reflect.Type) interface{} <span class="cov8" title="1">{
        return reflect.New(reflect.SliceOf(t)).Interface()
}</span>
</pre>
		
		<pre class="file" id="file40" style="display: none">package env

import (
        "fmt"
        "os"
        "reflect"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/blend/go-sdk/util"
)

var (
        _env     Vars
        _envLock = sync.Mutex{}
)

// Service specific constants
const (
        // VarServiceEnv is a common env var name.
        VarServiceEnv = "SERVICE_ENV"
        // VarServiceName is a common env var name.
        VarServiceName = "SERVICE_NAME"
        // VarServiceSecret is a common env var name.
        VarServiceSecret = "SERVICE_SECRET"
        // VarPort is a common env var name.
        VarPort = "PORT"
        // VarSecurePort is a common env var name.
        VarSecurePort = "SECURE_PORT"
        // VarTLSCertPath is a common env var name.
        VarTLSCertPath = "TLS_CERT_PATH"
        // VarTLSKeyPath is a common env var name.
        VarTLSKeyPath = "TLS_KEY_PATH"
        // VarTLSCert is a common env var name.
        VarTLSCert = "TLS_CERT"
        // VarTLSKey is a common env var name.
        VarTLSKey = "TLS_KEY"

        // VarPGIdleConns is a common env var name.
        VarPGIdleConns = "PG_IDLE_CONNS"
        // VarPGMaxConns is a common env var name.
        VarPGMaxConns = "PG_MAX_CONNS"

        // ServiceEnvDev is a service environment.
        ServiceEnvDev = "dev"
        // ServiceEnvCI is a service environment.
        ServiceEnvCI = "ci"
        // ServiceEnvPreprod is a service environment.
        ServiceEnvPreprod = "preprod"
        // ServiceEnvBeta is a service environment.
        ServiceEnvBeta = "beta"
        // ServiceEnvProd is a service environment.
        ServiceEnvProd = "prod"
)

// ReadIntoConstants
const (
        // FieldTagEnv is the struct tag for what environment variable to use to populate a field.
        FieldTagEnv = "env"
        // FieldFlagCSV is a field tag flag (say that 10 times fast).
        FieldFlagCSV = "csv"
        // FieldFlagBase64 is a field tag flag (say that 10 times fast).
        FieldFlagBase64 = "base64"
        // FieldFlagBytes is a field tag flag (say that 10 times fast).
        FieldFlagBytes = "bytes"
)

// Marshaler is a type that implements `ReadInto`.
type Marshaler interface {
        MarshalEnv(vars Vars) error
}

// Env returns the current env var set.
func Env() Vars <span class="cov0" title="0">{
        if _env == nil </span><span class="cov0" title="0">{
                _envLock.Lock()
                defer _envLock.Unlock()
                if _env == nil </span><span class="cov0" title="0">{
                        _env = NewVarsFromEnvironment()
                }</span>
        }
        <span class="cov0" title="0">return _env</span>
}

// SetEnv sets the env vars.
func SetEnv(vars Vars) <span class="cov0" title="0">{
        _envLock.Lock()
        _env = vars
        _envLock.Unlock()
}</span>

// Restore sets .Env() to the current os environment.
func Restore() <span class="cov0" title="0">{
        SetEnv(NewVarsFromEnvironment())
}</span>

// NewVars returns a new env var set.
func NewVars() Vars <span class="cov8" title="1">{
        return Vars{}
}</span>

// NewVarsFromEnvironment reads an EnvVar set from the environment.
func NewVarsFromEnvironment() Vars <span class="cov8" title="1">{
        vars := Vars{}
        envVars := os.Environ()
        for _, ev := range envVars </span><span class="cov8" title="1">{
                parts := strings.SplitN(ev, "=", 2)
                if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                        vars[parts[0]] = parts[1]
                }</span>
        }
        <span class="cov8" title="1">return vars</span>
}

// Vars is a set of environment variables.
type Vars map[string]string

// Set sets a value for a key.
func (ev Vars) Set(envVar, value string) <span class="cov8" title="1">{
        ev[envVar] = value
}</span>

// Restore resets an environment variable to it's environment value.
func (ev Vars) Restore(key string) <span class="cov0" title="0">{
        ev[key] = os.Getenv(key)
}</span>

// Delete removes a key from the set.
func (ev Vars) Delete(key string) <span class="cov8" title="1">{
        delete(ev, key)
}</span>

// String returns a string value for a given key, with an optional default vaule.
func (ev Vars) String(envVar string, defaults ...string) string <span class="cov8" title="1">{
        if value, hasValue := ev[envVar]; hasValue </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov0" title="0">if len(defaults) &gt; 0 </span><span class="cov0" title="0">{
                return defaults[0]
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// CSV returns a string array for a given string var.
func (ev Vars) CSV(envVar string, defaults ...string) []string <span class="cov8" title="1">{
        if value, hasValue := ev[envVar]; hasValue &amp;&amp; len(value) &gt; 0 </span><span class="cov8" title="1">{
                return strings.Split(value, ",")
        }</span>
        <span class="cov8" title="1">return defaults</span>
}

// ReadFile reads a file from the env.
func (ev Vars) ReadFile(path string) error <span class="cov0" title="0">{
        return util.File.ReadByLines(path, func(line string) error </span><span class="cov0" title="0">{
                if len(line) == 0 </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">parts := strings.SplitN(line, "=", 2)
                if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">ev[parts[0]] = parts[1]
                return nil</span>
        })
}

// Bool returns a boolean value for a key, defaulting to false.
// Valid "truthy" values are `true`, `yes`, and `1`.
// Everything else is false, including `REEEEEEEEEEEEEEE`.
func (ev Vars) Bool(envVar string, defaults ...bool) bool <span class="cov8" title="1">{
        if value, hasValue := ev[envVar]; hasValue </span><span class="cov8" title="1">{
                if len(value) &gt; 0 </span><span class="cov8" title="1">{
                        return util.String.CaseInsensitiveEquals(value, "true") ||
                                util.String.CaseInsensitiveEquals(value, "yes") ||
                                util.String.CaseInsensitiveEquals(value, "enabled") ||
                                value == "1"
                }</span>
        }
        <span class="cov8" title="1">if len(defaults) &gt; 0 </span><span class="cov8" title="1">{
                return defaults[0]
        }</span>
        <span class="cov8" title="1">return false</span>
}

// Int returns an integer value for a given key.
func (ev Vars) Int(envVar string, defaults ...int) (int, error) <span class="cov8" title="1">{
        if value, hasValue := ev[envVar]; hasValue </span><span class="cov8" title="1">{
                return strconv.Atoi(value)
        }</span>
        <span class="cov8" title="1">if len(defaults) &gt; 0 </span><span class="cov8" title="1">{
                return defaults[0], nil
        }</span>
        <span class="cov8" title="1">return 0, nil</span>
}

// MustInt returns an integer value for a given key and panics if it is malformed.
func (ev Vars) MustInt(envVar string, defaults ...int) int <span class="cov8" title="1">{
        value, err := ev.Int(envVar, defaults...)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return value</span>
}

// Int32 returns an integer value for a given key.
func (ev Vars) Int32(envVar string, defaults ...int32) (int32, error) <span class="cov0" title="0">{
        if value, hasValue := ev[envVar]; hasValue </span><span class="cov0" title="0">{
                parsedValue, err := strconv.Atoi(value)
                return int32(parsedValue), err
        }</span>
        <span class="cov0" title="0">if len(defaults) &gt; 0 </span><span class="cov0" title="0">{
                return defaults[0], nil
        }</span>
        <span class="cov0" title="0">return 0, nil</span>
}

// MustInt32 returns an integer value for a given key and panics if it is malformed.
func (ev Vars) MustInt32(envVar string, defaults ...int32) int32 <span class="cov0" title="0">{
        value, err := ev.Int32(envVar, defaults...)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return value</span>
}

// Int64 returns an int64 value for a given key.
func (ev Vars) Int64(envVar string, defaults ...int64) (int64, error) <span class="cov8" title="1">{
        if value, hasValue := ev[envVar]; hasValue </span><span class="cov8" title="1">{
                return strconv.ParseInt(value, 10, 64)
        }</span>
        <span class="cov8" title="1">if len(defaults) &gt; 0 </span><span class="cov8" title="1">{
                return defaults[0], nil
        }</span>
        <span class="cov8" title="1">return 0, nil</span>
}

// MustInt64 returns an int64 value for a given key and panics if it is malformed.
func (ev Vars) MustInt64(envVar string, defaults ...int64) int64 <span class="cov8" title="1">{
        value, err := ev.Int64(envVar, defaults...)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return value</span>
}

// Uint32 returns an uint32 value for a given key.
func (ev Vars) Uint32(envVar string, defaults ...uint32) (uint32, error) <span class="cov0" title="0">{
        if value, hasValue := ev[envVar]; hasValue </span><span class="cov0" title="0">{
                parsedValue, err := strconv.ParseUint(value, 10, 32)
                return uint32(parsedValue), err
        }</span>
        <span class="cov0" title="0">if len(defaults) &gt; 0 </span><span class="cov0" title="0">{
                return defaults[0], nil
        }</span>
        <span class="cov0" title="0">return 0, nil</span>
}

// MustUint32 returns an uint32 value for a given key and panics if it is malformed.
func (ev Vars) MustUint32(envVar string, defaults ...uint32) uint32 <span class="cov0" title="0">{
        value, err := ev.Uint32(envVar, defaults...)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return value</span>
}

// Uint64 returns an uint64 value for a given key.
func (ev Vars) Uint64(envVar string, defaults ...uint64) (uint64, error) <span class="cov0" title="0">{
        if value, hasValue := ev[envVar]; hasValue </span><span class="cov0" title="0">{
                return strconv.ParseUint(value, 10, 64)
        }</span>
        <span class="cov0" title="0">if len(defaults) &gt; 0 </span><span class="cov0" title="0">{
                return defaults[0], nil
        }</span>
        <span class="cov0" title="0">return 0, nil</span>
}

// MustUint64 returns an uint64 value for a given key and panics if it is malformed.
func (ev Vars) MustUint64(envVar string, defaults ...uint64) uint64 <span class="cov0" title="0">{
        value, err := ev.Uint64(envVar, defaults...)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return value</span>
}

// Float64 returns an float64 value for a given key.
func (ev Vars) Float64(envVar string, defaults ...float64) (float64, error) <span class="cov8" title="1">{
        if value, hasValue := ev[envVar]; hasValue </span><span class="cov8" title="1">{
                return strconv.ParseFloat(value, 64)
        }</span>
        <span class="cov0" title="0">if len(defaults) &gt; 0 </span><span class="cov0" title="0">{
                return defaults[0], nil
        }</span>
        <span class="cov0" title="0">return 0, nil</span>
}

// MustFloat64 returns an float64 value for a given key and panics if it is malformed.
func (ev Vars) MustFloat64(envVar string, defaults ...float64) float64 <span class="cov0" title="0">{
        value, err := ev.Float64(envVar, defaults...)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return value</span>
}

// Duration returns a duration value for a given key.
func (ev Vars) Duration(envVar string, defaults ...time.Duration) (time.Duration, error) <span class="cov8" title="1">{
        if value, hasValue := ev[envVar]; hasValue </span><span class="cov8" title="1">{
                return time.ParseDuration(value)
        }</span>
        <span class="cov0" title="0">if len(defaults) &gt; 0 </span><span class="cov0" title="0">{
                return defaults[0], nil
        }</span>
        <span class="cov0" title="0">return 0, nil</span>
}

// MustDuration returnss a duration value for a given key and panics if malformed.
func (ev Vars) MustDuration(envVar string, defaults ...time.Duration) time.Duration <span class="cov0" title="0">{
        value, err := ev.Duration(envVar, defaults...)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return value</span>
}

// Bytes returns a []byte value for a given key.
func (ev Vars) Bytes(envVar string, defaults ...[]byte) []byte <span class="cov8" title="1">{
        if value, hasValue := ev[envVar]; hasValue &amp;&amp; len(value) &gt; 0 </span><span class="cov8" title="1">{
                return []byte(value)
        }</span>
        <span class="cov8" title="1">if len(defaults) &gt; 0 </span><span class="cov8" title="1">{
                return defaults[0]
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Base64 returns a []byte value for a given key whose value is encoded in base64.
func (ev Vars) Base64(envVar string, defaults ...[]byte) ([]byte, error) <span class="cov8" title="1">{
        if value, hasValue := ev[envVar]; hasValue &amp;&amp; len(value) &gt; 0 </span><span class="cov8" title="1">{
                return util.Base64.Decode(value)
        }</span>
        <span class="cov0" title="0">if len(defaults) &gt; 0 </span><span class="cov0" title="0">{
                return defaults[0], nil
        }</span>
        <span class="cov0" title="0">return nil, nil</span>
}

// MustBase64 returns a []byte value for a given key encoded with base64, and panics if malformed.
func (ev Vars) MustBase64(envVar string, defaults ...[]byte) []byte <span class="cov0" title="0">{
        value, err := ev.Base64(envVar, defaults...)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return value</span>
}

// Has returns if a key is present in the set.
func (ev Vars) Has(envVar string) bool <span class="cov8" title="1">{
        _, hasKey := ev[envVar]
        return hasKey
}</span>

// HasAll returns if all of the given vars are present in the set.
func (ev Vars) HasAll(envVars ...string) bool <span class="cov8" title="1">{
        if len(envVars) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for _, envVar := range envVars </span><span class="cov8" title="1">{
                if !ev.Has(envVar) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// HasAny returns if any of the given vars are present in the set.
func (ev Vars) HasAny(envVars ...string) bool <span class="cov8" title="1">{
        for _, envVar := range envVars </span><span class="cov8" title="1">{
                if ev.Has(envVar) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// Require enforces that a given set of environment variables are present.
func (ev Vars) Require(keys ...string) error <span class="cov0" title="0">{
        for _, key := range keys </span><span class="cov0" title="0">{
                if !ev.Has(key) </span><span class="cov0" title="0">{
                        return fmt.Errorf("the following environment variables are required: `%s`", strings.Join(keys, ","))
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// Must enforces that a given set of environment variables are present and panics
// if they're not present.
func (ev Vars) Must(keys ...string) <span class="cov0" title="0">{
        for _, key := range keys </span><span class="cov0" title="0">{
                if !ev.Has(key) </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("the following environment variables are required: `%s`", strings.Join(keys, ",")))</span>
                }
        }
}

// Union returns the union of the two sets, other replacing conflicts.
func (ev Vars) Union(other Vars) Vars <span class="cov8" title="1">{
        newSet := NewVars()
        for key, value := range ev </span><span class="cov8" title="1">{
                newSet[key] = value
        }</span>
        <span class="cov8" title="1">for key, value := range other </span><span class="cov8" title="1">{
                newSet[key] = value
        }</span>
        <span class="cov8" title="1">return newSet</span>
}

// Vars returns all the vars stored in the env var set.
func (ev Vars) Vars() []string <span class="cov8" title="1">{
        var envVars = make([]string, len(ev))
        var index int
        for envVar := range ev </span><span class="cov8" title="1">{
                envVars[index] = envVar
                index++
        }</span>
        <span class="cov8" title="1">return envVars</span>
}

// Raw returns a raw KEY=VALUE form of the vars.
func (ev Vars) Raw() []string <span class="cov0" title="0">{
        var raw []string
        for key, value := range ev </span><span class="cov0" title="0">{
                raw = append(raw, fmt.Sprintf("%s=%s", key, value))
        }</span>
        <span class="cov0" title="0">return raw</span>
}

// --------------------------------------------------------------------------------
// Service Specific helpers
// --------------------------------------------------------------------------------

// ServiceEnv is a common environment variable for the services environment.
// Common values include "dev", "ci", "sandbox", "preprod", "beta", and "prod".
func (ev Vars) ServiceEnv(defaults ...string) string <span class="cov0" title="0">{
        return ev.String(VarServiceEnv, defaults...)
}</span>

// IsProduction returns if the ServiceEnv is a production environment.
func (ev Vars) IsProduction() bool <span class="cov0" title="0">{
        return ev.ServiceEnv() == ServiceEnvPreprod ||
                ev.ServiceEnv() == ServiceEnvProd
}</span>

// IsProdlike returns if the ServiceEnv is "prodlike".
func (ev Vars) IsProdlike() bool <span class="cov0" title="0">{
        return ev.ServiceEnv() == ServiceEnvPreprod ||
                ev.ServiceEnv() == ServiceEnvBeta ||
                ev.ServiceEnv() == ServiceEnvProd
}</span>

// ServiceName is a common environment variable for the service's name.
func (ev Vars) ServiceName(defaults ...string) string <span class="cov0" title="0">{
        return ev.String(VarServiceName, defaults...)
}</span>

// ReadInto reads the environment into tagged fields on the `obj`.
func (ev Vars) ReadInto(obj interface{}) error <span class="cov8" title="1">{
        // check if the type implements marshaler.
        if typed, isTyped := obj.(Marshaler); isTyped </span><span class="cov0" title="0">{
                return typed.MarshalEnv(ev)
        }</span>

        <span class="cov8" title="1">objMeta := util.Reflection.ReflectType(obj)
        objValue := util.Reflection.ReflectValue(obj)

        typeBool := reflect.TypeOf(false)
        typeDuration := reflect.TypeOf(time.Nanosecond)
        typeFloat32 := reflect.TypeOf(float32(1.0))
        typeFloat64 := reflect.TypeOf(float64(1.0))
        typeInt := reflect.TypeOf(1)
        typeInt8 := reflect.TypeOf(int8(1))
        typeInt16 := reflect.TypeOf(int16(1))
        typeInt32 := reflect.TypeOf(int32(1))
        typeInt64 := reflect.TypeOf(int64(1))
        typeUint := reflect.TypeOf(uint(1))
        typeUint8 := reflect.TypeOf(uint8(1))
        typeUint16 := reflect.TypeOf(uint16(1))
        typeUint32 := reflect.TypeOf(uint32(1))
        typeUint64 := reflect.TypeOf(uint64(1))
        typeUintptr := reflect.TypeOf(uintptr(1))

        var field reflect.StructField
        var tag string
        var envValue interface{}
        var err error
        var pieces []string
        var envVar string

        for x := 0; x &lt; objMeta.NumField(); x++ </span><span class="cov8" title="1">{
                field = objMeta.Field(x)

                // Treat structs as nested values.
                if field.Type.Kind() == reflect.Struct </span><span class="cov8" title="1">{
                        if err = ev.ReadInto(objValue.Field(x).Addr().Interface()); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                <span class="cov8" title="1">tag = field.Tag.Get(FieldTagEnv)
                if len(tag) &gt; 0 </span><span class="cov8" title="1">{
                        var csv bool
                        var bytes bool
                        var base64 bool

                        pieces = strings.Split(tag, ",")
                        envVar = pieces[0]
                        if len(pieces) &gt; 1 </span><span class="cov8" title="1">{
                                for y := 1; y &lt; len(pieces); y++ </span><span class="cov8" title="1">{
                                        if pieces[y] == FieldFlagCSV </span><span class="cov8" title="1">{
                                                csv = true
                                        }</span> else<span class="cov8" title="1"> if pieces[y] == FieldFlagBase64 </span><span class="cov8" title="1">{
                                                base64 = true
                                        }</span> else<span class="cov8" title="1"> if pieces[y] == FieldFlagBytes </span><span class="cov8" title="1">{
                                                bytes = true
                                        }</span>
                                }
                        }

                        <span class="cov8" title="1">if !ev.Has(envVar) </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">if csv </span><span class="cov8" title="1">{
                                envValue = ev.CSV(envVar)
                        }</span> else<span class="cov8" title="1"> if base64 </span><span class="cov8" title="1">{
                                envValue, err = ev.Base64(envVar)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        } else<span class="cov8" title="1"> if bytes </span><span class="cov8" title="1">{
                                envValue = ev.Bytes(envVar)
                        }</span> else<span class="cov8" title="1"> {
                                // infer the type.
                                fieldType := util.Reflection.FollowType(field.Type)
                                switch fieldType </span>{
                                case typeBool:<span class="cov8" title="1">
                                        if ev.Has(envVar) </span><span class="cov8" title="1">{
                                                envValue = ev.Bool(envVar)
                                        }</span> else<span class="cov0" title="0"> {
                                                continue</span>
                                        }
                                case typeFloat32, typeFloat64:<span class="cov8" title="1">
                                        envValue, err = ev.Float64(envVar)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                case typeInt, typeInt8, typeInt16:<span class="cov8" title="1">
                                        envValue, err = ev.Int(envVar)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                case typeInt32:<span class="cov0" title="0">
                                        envValue, err = ev.Int32(envVar)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                case typeInt64:<span class="cov0" title="0">
                                        envValue, err = ev.Int64(envVar)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                case typeUint32:<span class="cov0" title="0">
                                        envValue, err = ev.Uint32(envVar)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                case typeUint, typeUint8, typeUint16, typeUint64, typeUintptr:<span class="cov0" title="0">
                                        envValue, err = ev.Uint64(envVar)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                case typeDuration:<span class="cov8" title="1">
                                        envValue, err = ev.Duration(envVar)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                default:<span class="cov8" title="1">
                                        envValue = ev.String(envVar)</span>
                                }
                        }

                        <span class="cov8" title="1">err = util.Reflection.SetValueByName(obj, field.Name, envValue)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package exception

import (
        "encoding/json"
        "fmt"
        "io"
)

// New returns a new exception with a call stack.
func New(classArgs ...interface{}) Exception <span class="cov8" title="1">{
        return &amp;Ex{
                class: fmt.Sprint(classArgs...),
                stack: callers(),
        }
}</span>

// Newf returns a new exception by `Sprintf`ing the format and the args.
func Newf(classFormat string, args ...interface{}) Exception <span class="cov8" title="1">{
        return &amp;Ex{
                class: fmt.Sprintf(classFormat, args...),
                stack: callers(),
        }
}</span>

// NewFromErr returns a new exception from an error.
func NewFromErr(err error) Exception <span class="cov8" title="1">{
        return &amp;Ex{
                inner: err,
                class: err.Error(),
                stack: callers(),
        }
}</span>

// Nest nests an arbitrary number of exceptions.
func Nest(err ...error) Exception <span class="cov8" title="1">{
        var ex *Ex
        var last *Ex
        var didSet bool

        for _, e := range err </span><span class="cov8" title="1">{
                if e != nil </span><span class="cov8" title="1">{
                        var wrappedEx *Ex
                        if typedEx, isTyped := e.(*Ex); !isTyped </span><span class="cov0" title="0">{
                                wrappedEx = &amp;Ex{
                                        class: e.Error(),
                                        stack: callers(),
                                }
                        }</span> else<span class="cov8" title="1"> {
                                wrappedEx = typedEx
                        }</span>

                        <span class="cov8" title="1">if wrappedEx != ex </span><span class="cov8" title="1">{
                                if ex == nil </span><span class="cov8" title="1">{
                                        ex = wrappedEx
                                        last = wrappedEx
                                }</span> else<span class="cov0" title="0"> {
                                        last.inner = wrappedEx
                                        last = wrappedEx
                                }</span>
                                <span class="cov8" title="1">didSet = true</span>
                        }
                }
        }
        <span class="cov8" title="1">if didSet </span><span class="cov8" title="1">{
                return ex
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Wrap wraps an exception, will return error-typed `nil` if the exception is nil.
func Wrap(err error) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if typed, isTyped := err.(*Ex); isTyped </span><span class="cov8" title="1">{
                return typed
        }</span>
        <span class="cov8" title="1">return NewFromErr(err)</span>
}

// Exception is an exception.
type Exception interface {
        error
        fmt.Formatter
        json.Marshaler

        WithClass(string) Exception
        Class() string
        WithMessagef(string, ...interface{}) Exception
        Message() string
        WithInner(error) Exception
        Inner() error
        WithStack(StackTrace) Exception
        Stack() StackTrace

        Decompose() map[string]interface{}
}

// Ex is an error with a stack trace.
type Ex struct {
        // Class disambiguates between errors, it can be used to identify the type of the error.
        class string
        // Message adds further detail to the error, and shouldn't be used for disambiguation.
        message string
        // Inner holds the original error in cases where we're wrapping an error with a stack trace.
        inner error
        // Stack is the call stack frames used to create the stack output.
        stack StackTrace
}

// Format allows for conditional expansion in printf statements
// based on the token and flags used.
//         %+v : class + message + stack
//         %v, %c : class
//         %m : message
//         %t : stack
func (e *Ex) Format(s fmt.State, verb rune) <span class="cov8" title="1">{
        switch verb </span>{
        case 'v':<span class="cov8" title="1">
                if s.Flag('+') </span><span class="cov0" title="0">{
                        if len(e.class) &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Fprintf(s, "%s", e.class)
                                if len(e.message) &gt; 0 </span><span class="cov0" title="0">{
                                        fmt.Fprintf(s, "\nmessage: %s", e.message)
                                }</span>
                        } else<span class="cov0" title="0"> if len(e.message) &gt; 0 </span><span class="cov0" title="0">{
                                io.WriteString(s, e.message)
                        }</span>

                        <span class="cov0" title="0">e.stack.Format(s, verb)
                        return</span>
                } else<span class="cov8" title="1"> if s.Flag('-') </span><span class="cov0" title="0">{
                        e.stack.Format(s, verb)
                        return
                }</span>

                <span class="cov8" title="1">if len(e.class) &gt; 0 </span><span class="cov8" title="1">{
                        io.WriteString(s, e.class)
                        if len(e.message) &gt; 0 </span><span class="cov8" title="1">{
                                fmt.Fprintf(s, "\nmessage: %s", e.message)
                        }</span>
                } else<span class="cov8" title="1"> if len(e.message) &gt; 0 </span><span class="cov8" title="1">{
                        io.WriteString(s, e.message)
                }</span>
                <span class="cov8" title="1">return</span>
        case 'c':<span class="cov0" title="0">
                io.WriteString(s, e.class)</span>
        case 'm':<span class="cov8" title="1">
                io.WriteString(s, e.message)</span>
        case 'q':<span class="cov0" title="0">
                fmt.Fprintf(s, "%q", e.message)</span>
        }
}

// Error implements the `error` interface
func (e *Ex) Error() string <span class="cov8" title="1">{ return e.class }</span>

// Decompose breaks the exception down to be marshalled into an intermediate format.
func (e *Ex) Decompose() map[string]interface{} <span class="cov8" title="1">{
        values := map[string]interface{}{}
        values["Class"] = e.class
        values["Message"] = e.message
        if e.stack != nil </span><span class="cov8" title="1">{
                values["Stack"] = e.Stack().Strings()
        }</span>
        <span class="cov8" title="1">if e.inner != nil </span><span class="cov0" title="0">{
                if typed, isTyped := e.inner.(*Ex); isTyped </span><span class="cov0" title="0">{
                        values["Inner"] = typed.Decompose()
                }</span> else<span class="cov0" title="0"> {
                        values["Inner"] = e.inner.Error()
                }</span>
        }
        <span class="cov8" title="1">return values</span>
}

// MarshalJSON is a custom json marshaler.
func (e *Ex) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(e.Decompose())
}</span>

// WithClass sets the exception class and returns the exepction.
func (e *Ex) WithClass(class string) Exception <span class="cov0" title="0">{
        e.class = class
        return e
}</span>

// Class returns the exception class.
func (e *Ex) Class() string <span class="cov0" title="0">{
        return e.class
}</span>

// WithInner sets the inner and returns the exception.
func (e *Ex) WithInner(err error) Exception <span class="cov0" title="0">{
        e.inner = err
        return e
}</span>

// Inner returns the nested exception.
func (e *Ex) Inner() error <span class="cov8" title="1">{
        return e.inner
}</span>

// Message returns just the message, it is effectively
// an alias to .Error()
func (e *Ex) Message() string <span class="cov0" title="0">{ return e.message }</span>

// WithMessagef sets the message based on a format and args, and returns the exception.
func (e *Ex) WithMessagef(format string, args ...interface{}) Exception <span class="cov8" title="1">{
        e.message = fmt.Sprintf(format, args...)
        return e
}</span>

// WithStack sets the stack.
func (e *Ex) WithStack(stack StackTrace) Exception <span class="cov8" title="1">{
        e.stack = stack
        return e
}</span>

// Stack returns the stack provider.
// This is typically the runtime []uintptr or []string if restored after the fact.
func (e *Ex) Stack() StackTrace <span class="cov8" title="1">{
        return e.stack
}</span>

// StackString returns the stack trace as a string.
func (e *Ex) StackString() string <span class="cov0" title="0">{
        return fmt.Sprintf("%v", e.stack)
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package exception

import (
        "encoding/json"
        "fmt"
        "io"
        "path"
        "runtime"
        "strings"
)

func callers() *StackPointers <span class="cov8" title="1">{
        const depth = 32
        var pcs [depth]uintptr
        n := runtime.Callers(4, pcs[:])
        var st StackPointers = pcs[0:n]
        return &amp;st
}</span>

// StackTrace is a stack trace provider.
type StackTrace interface {
        fmt.Formatter
        Strings() []string
}

// GetStackTrace is a utility method to get the current stack trace at call time.
func GetStackTrace() string <span class="cov8" title="1">{
        return fmt.Sprintf("%+v", callers())
}</span>

// StackPointers is stack of uintptr stack frames from innermost (newest) to outermost (oldest).
type StackPointers []uintptr

// Format formats the stack trace.
func (st StackPointers) Format(s fmt.State, verb rune) <span class="cov8" title="1">{
        switch verb </span>{
        case 'v':<span class="cov8" title="1">
                switch </span>{
                case s.Flag('+'):<span class="cov8" title="1">
                        for _, f := range st </span><span class="cov8" title="1">{
                                fmt.Fprintf(s, "\n%+v", Frame(f))
                        }</span>
                case s.Flag('#'):<span class="cov0" title="0">
                        for _, f := range st </span><span class="cov0" title="0">{
                                fmt.Fprintf(s, "\n%#v", Frame(f))
                        }</span>
                default:<span class="cov0" title="0">
                        for _, f := range st </span><span class="cov0" title="0">{
                                fmt.Fprintf(s, "\n%v", Frame(f))
                        }</span>
                }
        case 's':<span class="cov0" title="0">
                for _, f := range st </span><span class="cov0" title="0">{
                        fmt.Fprintf(s, "\n%s", Frame(f))
                }</span>
        }
}

// Strings dereferences the StackTrace as a string slice
func (st StackPointers) Strings() []string <span class="cov8" title="1">{
        res := make([]string, len(st))
        for i, frame := range st </span><span class="cov8" title="1">{
                res[i] = fmt.Sprintf("%+v", frame)
        }</span>
        <span class="cov8" title="1">return res</span>
}

//MarshalJSON is a custom json marshaler.
func (st StackPointers) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(st.Strings())
}</span>

// StackStrings represents a stack trace as string literals.
type StackStrings []string

// Format formats the stack trace.
func (ss StackStrings) Format(s fmt.State, verb rune) <span class="cov8" title="1">{
        switch verb </span>{
        case 'v':<span class="cov8" title="1">
                switch </span>{
                case s.Flag('+'):<span class="cov8" title="1">
                        for _, f := range ss </span><span class="cov8" title="1">{
                                fmt.Fprintf(s, "\n%+v", f)
                        }</span>
                case s.Flag('#'):<span class="cov8" title="1">
                        fmt.Fprintf(s, "%#v", []string(ss))</span>
                default:<span class="cov8" title="1">
                        for _, f := range ss </span><span class="cov8" title="1">{
                                fmt.Fprintf(s, "\n%v", f)
                        }</span>
                }
        case 's':<span class="cov8" title="1">
                for _, f := range ss </span><span class="cov8" title="1">{
                        fmt.Fprintf(s, "\n%v", f)
                }</span>
        }
}

// Strings returns the stack strings as a string slice.
func (ss StackStrings) Strings() []string <span class="cov8" title="1">{
        return []string(ss)
}</span>

//MarshalJSON is a custom json marshaler.
func (ss StackStrings) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return json.Marshal(ss)
}</span>

// Frame represents a program counter inside a stack frame.
type Frame uintptr

// pc returns the program counter for this frame;
// multiple frames may have the same PC value.
func (f Frame) pc() uintptr <span class="cov8" title="1">{ return uintptr(f) - 1 }</span>

// file returns the full path to the file that contains the
// function for this Frame's pc.
func (f Frame) file() string <span class="cov0" title="0">{
        fn := runtime.FuncForPC(f.pc())
        if fn == nil </span><span class="cov0" title="0">{
                return "unknown"
        }</span>
        <span class="cov0" title="0">file, _ := fn.FileLine(f.pc())
        return file</span>
}

// line returns the line number of source code of the
// function for this Frame's pc.
func (f Frame) line() int <span class="cov8" title="1">{
        fn := runtime.FuncForPC(f.pc())
        if fn == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">_, line := fn.FileLine(f.pc())
        return line</span>
}

// Format formats the frame according to the fmt.Formatter interface.
//
//    %s    source file
//    %d    source line
//    %n    function name
//    %v    equivalent to %s:%d
//
// Format accepts flags that alter the printing of some verbs, as follows:
//
//    %+s   path of source file relative to the compile time GOPATH
//    %+v   equivalent to %+s:%d
func (f Frame) Format(s fmt.State, verb rune) <span class="cov8" title="1">{
        switch verb </span>{
        case 's':<span class="cov8" title="1">
                switch </span>{
                case s.Flag('+'):<span class="cov8" title="1">
                        pc := f.pc()
                        fn := runtime.FuncForPC(pc)
                        if fn == nil </span><span class="cov0" title="0">{
                                io.WriteString(s, "unknown")
                        }</span> else<span class="cov8" title="1"> {
                                file, _ := fn.FileLine(pc)
                                fname := fn.Name()
                                fmt.Fprintf(s, "%s\n\t%s", fname, trimGOPATH(fname, file))
                        }</span>
                default:<span class="cov0" title="0">
                        io.WriteString(s, path.Base(f.file()))</span>
                }
        case 'd':<span class="cov8" title="1">
                fmt.Fprintf(s, "%d", f.line())</span>
        case 'n':<span class="cov0" title="0">
                name := runtime.FuncForPC(f.pc()).Name()
                io.WriteString(s, funcname(name))</span>
        case 'v':<span class="cov8" title="1">
                f.Format(s, 's')
                io.WriteString(s, ":")
                f.Format(s, 'd')</span>
        }
}

// funcname removes the path prefix component of a function's name reported by func.Name().
func funcname(name string) string <span class="cov0" title="0">{
        i := strings.LastIndex(name, "/")
        name = name[i+1:]
        i = strings.Index(name, ".")
        return name[i+1:]
}</span>

func trimGOPATH(name, file string) string <span class="cov8" title="1">{
        // Here we want to get the source file path relative to the compile time
        // GOPATH. As of Go 1.6.x there is no direct way to know the compiled
        // GOPATH at runtime, but we can infer the number of path segments in the
        // GOPATH. We note that fn.Name() returns the function name qualified by
        // the import path, which does not include the GOPATH. Thus we can trim
        // segments from the beginning of the file path until the number of path
        // separators remaining is one more than the number of path separators in
        // the function name. For example, given:
        //
        //    GOPATH     /home/user
        //    file       /home/user/src/pkg/sub/file.go
        //    fn.Name()  pkg/sub.Type.Method
        //
        // We want to produce:
        //
        //    pkg/sub/file.go
        //
        // From this we can easily see that fn.Name() has one less path separator
        // than our desired output. We count separators from the end of the file
        // path until it finds two more than in the function name and then move
        // one character forward to preserve the initial path segment without a
        // leading separator.
        const sep = "/"
        goal := strings.Count(name, sep) + 2
        i := len(file)
        for n := 0; n &lt; goal; n++ </span><span class="cov8" title="1">{
                i = strings.LastIndex(file[:i], sep)
                if i == -1 </span><span class="cov0" title="0">{
                        // not enough separators found, set i so that the slice expression
                        // below leaves file unmodified
                        i = -len(sep)
                        break</span>
                }
        }
        // get back to 0 or trim the leading separator
        <span class="cov8" title="1">file = file[i+len(sep):]
        return file</span>
}
</pre>
		
		<pre class="file" id="file43" style="display: none">package exception

// Is is a helper function that returns if an error is an exception.
func Is(err error) bool <span class="cov0" title="0">{
        if _, typedOk := err.(*Ex); typedOk </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

// As is a helper method that returns an error as an exception.
func As(err error) *Ex <span class="cov8" title="1">{
        if typed, typedOk := err.(*Ex); typedOk </span><span class="cov8" title="1">{
                return typed
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">package logger

// AnsiColor represents an ansi color code fragment.
type AnsiColor string

func (acc AnsiColor) escaped() string <span class="cov8" title="1">{
        return "\033[" + string(acc)
}</span>

// Apply returns a string with the color code applied.
func (acc AnsiColor) Apply(text string) string <span class="cov8" title="1">{
        return acc.escaped() + text + ColorReset.escaped()
}</span>

const (
        // RuneSpace is a single rune representing a space.
        RuneSpace rune = ' '

        // RuneNewline is a single rune representing a newline.
        RuneNewline rune = '\n'

        // ColorBlack is the posix escape code fragment for black.
        ColorBlack AnsiColor = "30m"

        // ColorRed is the posix escape code fragment for red.
        ColorRed AnsiColor = "31m"

        // ColorGreen is the posix escape code fragment for green.
        ColorGreen AnsiColor = "32m"

        // ColorYellow is the posix escape code fragment for yellow.
        ColorYellow AnsiColor = "33m"

        // ColorBlue is the posix escape code fragment for blue.
        ColorBlue AnsiColor = "34m"

        // ColorPurple is the posix escape code fragement for magenta (purple)
        ColorPurple AnsiColor = "35m"

        // ColorCyan is the posix escape code fragement for cyan.
        ColorCyan AnsiColor = "36m"

        // ColorWhite is the posix escape code fragment for white.
        ColorWhite AnsiColor = "37m"

        // ColorLightBlack is the posix escape code fragment for black.
        ColorLightBlack AnsiColor = "90m"

        // ColorLightRed is the posix escape code fragment for red.
        ColorLightRed AnsiColor = "91m"

        // ColorLightGreen is the posix escape code fragment for green.
        ColorLightGreen AnsiColor = "92m"

        // ColorLightYellow is the posix escape code fragment for yellow.
        ColorLightYellow AnsiColor = "93m"

        // ColorLightBlue is the posix escape code fragment for blue.
        ColorLightBlue AnsiColor = "94m"

        // ColorLightPurple is the posix escape code fragement for magenta (purple)
        ColorLightPurple AnsiColor = "95m"

        // ColorLightCyan is the posix escape code fragement for cyan.
        ColorLightCyan AnsiColor = "96m"

        // ColorLightWhite is the posix escape code fragment for white.
        ColorLightWhite AnsiColor = "97m"

        // ColorGray is an alias to ColorLightWhite to preserve backwards compatibility.
        ColorGray AnsiColor = ColorLightBlack

        // ColorReset is the posix escape code fragment to reset all formatting.
        ColorReset AnsiColor = "0m"
)

var (
        // DefaultFlagTextColors is the default color for each known flag.
        DefaultFlagTextColors = map[Flag]AnsiColor{
                Info:    ColorLightWhite,
                Silly:   ColorLightBlack,
                Debug:   ColorLightYellow,
                Warning: ColorLightYellow,
                Error:   ColorRed,
                Fatal:   ColorRed,
        }

        // DefaultFlagTextColor is the default flag color.
        DefaultFlagTextColor = ColorLightWhite
)

// GetFlagTextColor returns the color for a flag.
func GetFlagTextColor(flag Flag) AnsiColor <span class="cov8" title="1">{
        if color, hasColor := DefaultFlagTextColors[flag]; hasColor </span><span class="cov8" title="1">{
                return color
        }</span>
        <span class="cov8" title="1">return DefaultFlagTextColor</span>
}
</pre>
		
		<pre class="file" id="file45" style="display: none">package logger

import (
        "bytes"
        "fmt"
        "strings"
        "time"
)

// NewAuditEvent returns a new audit event.
func NewAuditEvent(principal, verb, noun string) *AuditEvent <span class="cov8" title="1">{
        return &amp;AuditEvent{
                ts:        time.Now().UTC(),
                flag:      Audit,
                principal: principal,
                verb:      verb,
                noun:      noun,
        }
}</span>

// NewAuditEventListener returns a new audit event listener.
func NewAuditEventListener(listener func(me *AuditEvent)) Listener <span class="cov8" title="1">{
        return func(e Event) </span><span class="cov8" title="1">{
                if typed, isTyped := e.(*AuditEvent); isTyped </span><span class="cov8" title="1">{
                        listener(typed)
                }</span>
        }
}

// AuditEvent is a common type of event detailing a business action by a subject.
type AuditEvent struct {
        heading       string
        ts            time.Time
        flag          Flag
        principal     string
        verb          string
        noun          string
        subject       string
        property      string
        remoteAddress string
        userAgent     string
        extra         map[string]string

        labels      map[string]string
        annotations map[string]string
}

// WithLabel sets a label on the event for later filtering.
func (ae *AuditEvent) WithLabel(key, value string) *AuditEvent <span class="cov8" title="1">{
        if ae.labels == nil </span><span class="cov8" title="1">{
                ae.labels = map[string]string{}
        }</span>
        <span class="cov8" title="1">ae.labels[key] = value
        return ae</span>
}

// Labels returns a labels collection.
func (ae *AuditEvent) Labels() map[string]string <span class="cov8" title="1">{
        return ae.labels
}</span>

// WithAnnotation adds an annotation to the event.
func (ae *AuditEvent) WithAnnotation(key, value string) *AuditEvent <span class="cov0" title="0">{
        if ae.annotations == nil </span><span class="cov0" title="0">{
                ae.annotations = map[string]string{}
        }</span>
        <span class="cov0" title="0">ae.annotations[key] = value
        return ae</span>
}

// Annotations returns the annotations set.
func (ae *AuditEvent) Annotations() map[string]string <span class="cov0" title="0">{
        return ae.annotations
}</span>

// WithFlag sets the audit event flag
func (ae *AuditEvent) WithFlag(f Flag) *AuditEvent <span class="cov0" title="0">{
        ae.flag = f
        return ae
}</span>

// Flag returns the audit event flag
func (ae AuditEvent) Flag() Flag <span class="cov8" title="1">{
        return ae.flag
}</span>

// WithTimestamp sets the message timestamp.
func (ae *AuditEvent) WithTimestamp(ts time.Time) *AuditEvent <span class="cov0" title="0">{
        ae.ts = ts
        return ae
}</span>

// Timestamp returns the timed message timestamp.
func (ae AuditEvent) Timestamp() time.Time <span class="cov8" title="1">{
        return ae.ts
}</span>

// WithHeading sets the heading.
func (ae *AuditEvent) WithHeading(heading string) *AuditEvent <span class="cov8" title="1">{
        ae.heading = heading
        return ae
}</span>

// Heading returns the heading.
func (ae AuditEvent) Heading() string <span class="cov8" title="1">{
        return ae.heading
}</span>

// WithPrincipal sets the principal.
func (ae *AuditEvent) WithPrincipal(principal string) *AuditEvent <span class="cov0" title="0">{
        ae.principal = principal
        return ae
}</span>

// Principal returns the principal.
func (ae AuditEvent) Principal() string <span class="cov8" title="1">{
        return ae.principal
}</span>

// WithVerb sets the verb.
func (ae *AuditEvent) WithVerb(verb string) *AuditEvent <span class="cov0" title="0">{
        ae.verb = verb
        return ae
}</span>

// Verb returns the verb.
func (ae AuditEvent) Verb() string <span class="cov8" title="1">{
        return ae.verb
}</span>

// WithNoun sets the noun.
func (ae *AuditEvent) WithNoun(noun string) *AuditEvent <span class="cov0" title="0">{
        ae.noun = noun
        return ae
}</span>

// Noun returns the noun.
func (ae AuditEvent) Noun() string <span class="cov0" title="0">{
        return ae.noun
}</span>

// WithSubject sets the subject.
func (ae *AuditEvent) WithSubject(subject string) *AuditEvent <span class="cov0" title="0">{
        ae.subject = subject
        return ae
}</span>

// Subject returns the subject.
func (ae AuditEvent) Subject() string <span class="cov0" title="0">{
        return ae.subject
}</span>

// WithProperty sets the property.
func (ae *AuditEvent) WithProperty(property string) *AuditEvent <span class="cov0" title="0">{
        ae.property = property
        return ae
}</span>

// Property returns the property.
func (ae AuditEvent) Property() string <span class="cov0" title="0">{
        return ae.property
}</span>

// WithRemoteAddr sets the remote address.
func (ae *AuditEvent) WithRemoteAddr(remoteAddr string) *AuditEvent <span class="cov0" title="0">{
        ae.remoteAddress = remoteAddr
        return ae
}</span>

// RemoteAddress returns the remote address.
func (ae AuditEvent) RemoteAddress() string <span class="cov0" title="0">{
        return ae.remoteAddress
}</span>

// WithUserAgent sets the user agent.
func (ae *AuditEvent) WithUserAgent(userAgent string) *AuditEvent <span class="cov0" title="0">{
        ae.userAgent = userAgent
        return ae
}</span>

// UserAgent returns the user agent.
func (ae AuditEvent) UserAgent() string <span class="cov0" title="0">{
        return ae.userAgent
}</span>

// WithExtra sets the extra info.
func (ae *AuditEvent) WithExtra(extra map[string]string) *AuditEvent <span class="cov0" title="0">{
        ae.extra = extra
        return ae
}</span>

// Extra returns the extra information.
func (ae AuditEvent) Extra() map[string]string <span class="cov0" title="0">{
        return ae.extra
}</span>

// WriteText implements TextWritable.
func (ae AuditEvent) WriteText(formatter TextFormatter, buf *bytes.Buffer) <span class="cov0" title="0">{
        if len(ae.principal) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(formatter.Colorize("Principal:", ColorGray))
                buf.WriteString(ae.principal)
                buf.WriteRune(RuneSpace)
        }</span>
        <span class="cov0" title="0">if len(ae.verb) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(formatter.Colorize("Verb:", ColorGray))
                buf.WriteString(ae.verb)
                buf.WriteRune(RuneSpace)
        }</span>
        <span class="cov0" title="0">if len(ae.noun) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(formatter.Colorize("Noun:", ColorGray))
                buf.WriteString(ae.noun)
                buf.WriteRune(RuneSpace)
        }</span>
        <span class="cov0" title="0">if len(ae.subject) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(formatter.Colorize("Subject:", ColorGray))
                buf.WriteString(ae.subject)
                buf.WriteRune(RuneSpace)
        }</span>
        <span class="cov0" title="0">if len(ae.property) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(formatter.Colorize("Property:", ColorGray))
                buf.WriteString(ae.property)
                buf.WriteRune(RuneSpace)
        }</span>
        <span class="cov0" title="0">if len(ae.remoteAddress) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(formatter.Colorize("Remote Addr:", ColorGray))
                buf.WriteString(ae.remoteAddress)
                buf.WriteRune(RuneSpace)
        }</span>
        <span class="cov0" title="0">if len(ae.userAgent) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(formatter.Colorize("UA:", ColorGray))
                buf.WriteString(ae.userAgent)
                buf.WriteRune(RuneSpace)
        }</span>
        <span class="cov0" title="0">if len(ae.extra) &gt; 0 </span><span class="cov0" title="0">{
                var values []string
                for key, value := range ae.extra </span><span class="cov0" title="0">{
                        values = append(values, fmt.Sprintf("%s%s", formatter.Colorize(key+":", ColorGray), value))
                }</span>
                <span class="cov0" title="0">buf.WriteString(strings.Join(values, " "))</span>
        }
}

// WriteJSON implements JSONWritable.
func (ae AuditEvent) WriteJSON() JSONObj <span class="cov0" title="0">{
        return JSONObj{
                "principal":  ae.principal,
                "verb":       ae.verb,
                "noun":       ae.noun,
                "subject":    ae.subject,
                "property":   ae.property,
                "remoteAddr": ae.remoteAddress,
                "ua":         ae.userAgent,
                "extra":      ae.extra,
        }
}</span>
</pre>
		
		<pre class="file" id="file46" style="display: none">package logger

import (
        "bytes"
        "sync"
)

// NewBufferPool returns a new BufferPool.
func NewBufferPool(bufferSize int) *BufferPool <span class="cov8" title="1">{
        return &amp;BufferPool{
                Pool: sync.Pool{New: func() Any </span><span class="cov8" title="1">{
                        b := bytes.NewBuffer(make([]byte, bufferSize))
                        b.Reset()
                        return b
                }</span>},
        }
}

// BufferPool is a sync.Pool of bytes.Buffer.
type BufferPool struct {
        sync.Pool
}

// Get returns a pooled bytes.Buffer instance.
func (bp *BufferPool) Get() *bytes.Buffer <span class="cov8" title="1">{
        return bp.Pool.Get().(*bytes.Buffer)
}</span>

// Put returns the pooled instance.
func (bp *BufferPool) Put(b *bytes.Buffer) <span class="cov8" title="1">{
        b.Reset()
        bp.Pool.Put(b)
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">package logger

import (
        "strings"

        "github.com/blend/go-sdk/env"
)

var (
        // DefaultFlags are the default flags.
        DefaultFlags = []Flag{Fatal, Error, Warning, Info, WebRequest}
        // DefaultFlagSet is the default verbosity for a diagnostics agent inited from the environment.
        DefaultFlagSet = NewFlagSet(DefaultFlags...)

        // DefaultHiddenFlags are the default hidden flags.
        DefaultHiddenFlags []Flag
)

// NewConfigFromEnv returns a new config from the environment.
func NewConfigFromEnv() *Config <span class="cov8" title="1">{
        var config Config
        env.Env().ReadInto(&amp;config)
        return &amp;config
}</span>

// Config is the logger config.
type Config struct {
        Label         string   `json:"label" yaml:"label" env:"LOG_LABEL"`
        OutputFormat  string   `json:"format" yaml:"format" env:"LOG_FORMAT"`
        Flags         []string `json:"flags" yaml:"flags" env:"LOG_EVENTS,csv"`
        HiddenFlags   []string `json:"hidden" yaml:"hidden" env:"LOG_HIDDEN,csv"`
        RecoverPanics *bool    `json:"recoverPanics" yaml:"recoverPanics" env:"LOG_RECOVER"`

        TextOutput TextWriterConfig `json:"textOutput" yaml:"textOutput"`
        JSONOutput JSONWriterConfig `json:"jsonOutput" yaml:"jsonOutput"`
}

// GetLabel returns the writer label.
func (c Config) GetLabel() string <span class="cov0" title="0">{
        if len(c.Label) &gt; 0 </span><span class="cov0" title="0">{
                return c.Label
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// GetOutputFormat returns the output format.
func (c Config) GetOutputFormat() OutputFormat <span class="cov8" title="1">{
        if len(c.OutputFormat) &gt; 0 </span><span class="cov8" title="1">{
                return OutputFormat(strings.ToLower(c.OutputFormat))
        }</span>
        <span class="cov8" title="1">return OutputFormatText</span>
}

// GetFlags returns the enabled logger events.
func (c Config) GetFlags() []string <span class="cov8" title="1">{
        if len(c.Flags) &gt; 0 </span><span class="cov8" title="1">{
                return c.Flags
        }</span>
        <span class="cov8" title="1">return AsStrings(DefaultFlags...)</span>
}

// GetHiddenFlags returns the enabled logger events.
func (c Config) GetHiddenFlags() []string <span class="cov8" title="1">{
        if len(c.HiddenFlags) &gt; 0 </span><span class="cov0" title="0">{
                return c.HiddenFlags
        }</span>
        <span class="cov8" title="1">return AsStrings(DefaultHiddenFlags...)</span>
}

// GetRecoverPanics returns a field value or a default.
func (c Config) GetRecoverPanics(defaults ...bool) bool <span class="cov8" title="1">{
        if c.RecoverPanics != nil </span><span class="cov0" title="0">{
                return *c.RecoverPanics
        }</span>
        <span class="cov8" title="1">if len(defaults) &gt; 0 </span><span class="cov0" title="0">{
                return defaults[0]
        }</span>
        <span class="cov8" title="1">return DefaultRecoverPanics</span>
}

// GetWriters returns the configured writers
func (c Config) GetWriters() []Writer <span class="cov8" title="1">{
        switch c.GetOutputFormat() </span>{
        case OutputFormatJSON:<span class="cov8" title="1">
                return []Writer{NewJSONWriterFromConfig(&amp;c.JSONOutput)}</span>
        case OutputFormatText:<span class="cov8" title="1">
                return []Writer{NewTextWriterFromConfig(&amp;c.TextOutput)}</span>
        default:<span class="cov8" title="1">
                return []Writer{NewTextWriterFromConfig(&amp;c.TextOutput)}</span>
        }
}

// NewTextWriterConfigFromEnv returns a new text writer config from the environment.
func NewTextWriterConfigFromEnv() *TextWriterConfig <span class="cov0" title="0">{
        var config TextWriterConfig
        env.Env().ReadInto(&amp;config)
        return &amp;config
}</span>

// TextWriterConfig is the config for a text writer.
type TextWriterConfig struct {
        ShowLabel  *bool  `json:"showLabel" yaml:"showLabel" env:"LOG_SHOW_LABEL"`
        ShowTime   *bool  `json:"showTime" yaml:"showTime" env:"LOG_SHOW_TIME"`
        UseColor   *bool  `json:"useColor" yaml:"useColor" env:"LOG_USE_COLOR"`
        Label      string `json:"label" yaml:"label" env:"LOG_LABEL"`
        TimeFormat string `json:"timeFormat" yaml:"timeFormat" env:"LOG_TIME_FORMAT"`
}

// GetShowLabel returns a field value or a default.
func (twc TextWriterConfig) GetShowLabel(defaults ...bool) bool <span class="cov8" title="1">{
        if twc.ShowLabel != nil </span><span class="cov0" title="0">{
                return *twc.ShowLabel
        }</span>
        <span class="cov8" title="1">if len(defaults) &gt; 0 </span><span class="cov0" title="0">{
                return defaults[0]
        }</span>
        <span class="cov8" title="1">return DefaultTextWriterShowLabel</span>
}

// GetShowTime returns a field value or a default.
func (twc TextWriterConfig) GetShowTime(defaults ...bool) bool <span class="cov8" title="1">{
        if twc.ShowTime != nil </span><span class="cov0" title="0">{
                return *twc.ShowTime
        }</span>
        <span class="cov8" title="1">if len(defaults) &gt; 0 </span><span class="cov0" title="0">{
                return defaults[0]
        }</span>
        <span class="cov8" title="1">return DefaultTextWriterShowTime</span>
}

// GetUseColor returns a field value or a default.
func (twc TextWriterConfig) GetUseColor(defaults ...bool) bool <span class="cov8" title="1">{
        if twc.UseColor != nil </span><span class="cov0" title="0">{
                return *twc.UseColor
        }</span>
        <span class="cov8" title="1">if len(defaults) &gt; 0 </span><span class="cov0" title="0">{
                return defaults[0]
        }</span>
        <span class="cov8" title="1">return DefaultTextWriterUseColor</span>
}

// GetLabel returns a field value or a default.
func (twc TextWriterConfig) GetLabel(defaults ...string) string <span class="cov8" title="1">{
        if len(twc.Label) &gt; 0 </span><span class="cov8" title="1">{
                return twc.Label
        }</span>
        <span class="cov8" title="1">if len(defaults) &gt; 0 </span><span class="cov0" title="0">{
                return defaults[0]
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// GetTimeFormat returns a field value or a default.
func (twc TextWriterConfig) GetTimeFormat(defaults ...string) string <span class="cov8" title="1">{
        if len(twc.TimeFormat) &gt; 0 </span><span class="cov0" title="0">{
                return twc.TimeFormat
        }</span>
        <span class="cov8" title="1">if len(defaults) &gt; 0 </span><span class="cov0" title="0">{
                return defaults[0]
        }</span>
        <span class="cov8" title="1">return DefaultTextTimeFormat</span>
}

// NewJSONWriterConfigFromEnv returns a new json writer config from the environment.
func NewJSONWriterConfigFromEnv() *JSONWriterConfig <span class="cov0" title="0">{
        var config JSONWriterConfig
        env.Env().ReadInto(&amp;config)
        return &amp;config
}</span>

// JSONWriterConfig is the config for a json writer.
type JSONWriterConfig struct {
        Pretty *bool `json:"pretty" yaml:"pretty" env:"LOG_JSON_PRETTY"`
}

// GetPretty returns a field value or a default.
func (jwc JSONWriterConfig) GetPretty(defaults ...bool) bool <span class="cov8" title="1">{
        if jwc.Pretty != nil </span><span class="cov0" title="0">{
                return *jwc.Pretty
        }</span>
        <span class="cov8" title="1">if len(defaults) &gt; 0 </span><span class="cov0" title="0">{
                return defaults[0]
        }</span>
        <span class="cov8" title="1">return DefaultJSONWriterPretty</span>
}
</pre>
		
		<pre class="file" id="file48" style="display: none">package logger

import "sync"

var (
        _default     *Logger
        _defaultLock sync.Mutex
)

// Default returnes a default Agent singleton.
func Default() *Logger <span class="cov0" title="0">{
        return _default
}</span>

// SetDefault sets the diagnostics singleton.
func SetDefault(log *Logger) <span class="cov0" title="0">{
        _defaultLock.Lock()
        defer _defaultLock.Unlock()
        _default = log
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">package logger

import (
        "bytes"
        "encoding/json"
        "fmt"
        "time"
)

// Errorf returns a new error event based on format and arguments.
func Errorf(flag Flag, format string, args ...Any) *ErrorEvent <span class="cov8" title="1">{
        return &amp;ErrorEvent{
                flag: flag,
                ts:   time.Now().UTC(),
                err:  fmt.Errorf(format, args...),
        }
}</span>

// NewErrorEvent returns a new error event.
func NewErrorEvent(flag Flag, err error) *ErrorEvent <span class="cov8" title="1">{
        return &amp;ErrorEvent{
                flag: flag,
                ts:   time.Now().UTC(),
                err:  err,
        }
}</span>

// NewErrorEventWithState returns a new error event with state.
func NewErrorEventWithState(flag Flag, err error, state Any) *ErrorEvent <span class="cov0" title="0">{
        return &amp;ErrorEvent{
                flag:  flag,
                ts:    time.Now().UTC(),
                err:   err,
                state: state,
        }
}</span>

// NewErrorEventListener returns a new error event listener.
func NewErrorEventListener(listener func(*ErrorEvent)) Listener <span class="cov8" title="1">{
        return func(e Event) </span><span class="cov8" title="1">{
                if typed, isTyped := e.(*ErrorEvent); isTyped </span><span class="cov8" title="1">{
                        listener(typed)
                }</span>
        }
}

// ErrorEvent is an event that wraps an error.
type ErrorEvent struct {
        heading   string
        flag      Flag
        flagColor AnsiColor
        ts        time.Time
        err       error
        state     Any

        labels      map[string]string
        annotations map[string]string
}

// IsError indicates if we should write to the error writer or not.
func (e *ErrorEvent) IsError() bool <span class="cov8" title="1">{
        return true
}</span>

// WithLabel sets a label on the event for later filtering.
func (e *ErrorEvent) WithLabel(key, value string) *ErrorEvent <span class="cov8" title="1">{
        if e.labels == nil </span><span class="cov8" title="1">{
                e.labels = map[string]string{}
        }</span>
        <span class="cov8" title="1">e.labels[key] = value
        return e</span>
}

// Labels returns a labels collection.
func (e *ErrorEvent) Labels() map[string]string <span class="cov8" title="1">{
        return e.labels
}</span>

// WithAnnotation adds an annotation to the event.
func (e *ErrorEvent) WithAnnotation(key, value string) *ErrorEvent <span class="cov0" title="0">{
        if e.annotations == nil </span><span class="cov0" title="0">{
                e.annotations = map[string]string{}
        }</span>
        <span class="cov0" title="0">e.annotations[key] = value
        return e</span>
}

// Annotations returns the annotations set.
func (e *ErrorEvent) Annotations() map[string]string <span class="cov0" title="0">{
        return e.annotations
}</span>

// WithTimestamp sets the event timestamp.
func (e *ErrorEvent) WithTimestamp(ts time.Time) *ErrorEvent <span class="cov0" title="0">{
        e.ts = ts
        return e
}</span>

// Timestamp returns the event timestamp.
func (e *ErrorEvent) Timestamp() time.Time <span class="cov8" title="1">{
        return e.ts
}</span>

// WithFlag sets the event flag.
func (e *ErrorEvent) WithFlag(flag Flag) *ErrorEvent <span class="cov0" title="0">{
        e.flag = flag
        return e
}</span>

// Flag returns the event flag.
func (e *ErrorEvent) Flag() Flag <span class="cov8" title="1">{
        return e.flag
}</span>

// WithHeading sets the heading.
func (e *ErrorEvent) WithHeading(heading string) *ErrorEvent <span class="cov8" title="1">{
        e.heading = heading
        return e
}</span>

// Heading returns the heading.
func (e *ErrorEvent) Heading() string <span class="cov8" title="1">{
        return e.heading
}</span>

// WithErr sets the error.
func (e *ErrorEvent) WithErr(err error) *ErrorEvent <span class="cov0" title="0">{
        e.err = err
        return e
}</span>

// Err returns the underlying error.
func (e *ErrorEvent) Err() error <span class="cov8" title="1">{
        return e.err
}</span>

// WithState sets the state.
func (e *ErrorEvent) WithState(state Any) *ErrorEvent <span class="cov0" title="0">{
        e.state = state
        return e
}</span>

// State returns underlying state, typically an http.Request.
func (e *ErrorEvent) State() Any <span class="cov0" title="0">{
        return e.state
}</span>

// WithFlagTextColor sets the flag text color.
func (e *ErrorEvent) WithFlagTextColor(color AnsiColor) *ErrorEvent <span class="cov0" title="0">{
        e.flagColor = color
        return e
}</span>

// FlagTextColor returns a custom color for the flag.
func (e *ErrorEvent) FlagTextColor() AnsiColor <span class="cov8" title="1">{
        return e.flagColor
}</span>

// WriteText implements TextWritable.
func (e *ErrorEvent) WriteText(formatter TextFormatter, buf *bytes.Buffer) <span class="cov8" title="1">{
        buf.WriteString(fmt.Sprintf("%+v", e.err))
}</span>

// WriteJSON implements JSONWritable.
func (e *ErrorEvent) WriteJSON() JSONObj <span class="cov8" title="1">{
        var errorJSON Any
        if _, ok := e.err.(json.Marshaler); ok </span><span class="cov8" title="1">{
                errorJSON = e.err
        }</span> else<span class="cov8" title="1"> {
                errorJSON = e.err.Error()
        }</span>
        <span class="cov8" title="1">return JSONObj{
                JSONFieldErr: errorJSON,
        }</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">package logger

import (
        "time"
)

// Event is an interface representing methods necessary to trigger listeners.
type Event interface {
        Flag() Flag
        Timestamp() time.Time
}

// EventHeading determines if we should add another output field, `event-heading` to output.
type EventHeading interface {
        Heading() string
}

// EventMeta determines if we should pull extra meta fields off the event.
type EventMeta interface {
        Labels() map[string]string
        Annotations() map[string]string
}

// EventEnabled determines if we should allow an event to be triggered or not.
type EventEnabled interface {
        IsEnabled() bool
}

// EventWritable lets us disable implicit writing for some events.
type EventWritable interface {
        IsWritable() bool
}

// EventError determines if we should write the event to the error stream.
type EventError interface {
        IsError() bool
}

// --------------------------------------------------------------------------------
// testing helpers
// --------------------------------------------------------------------------------

func marshalEvent(obj interface{}) (Event, bool) <span class="cov8" title="1">{
        typed, isTyped := obj.(Event)
        return typed, isTyped
}</span>

func marshalEventHeading(obj interface{}) (EventHeading, bool) <span class="cov8" title="1">{
        typed, isTyped := obj.(EventHeading)
        return typed, isTyped
}</span>

func marshalEventEnabled(obj interface{}) (EventEnabled, bool) <span class="cov0" title="0">{
        typed, isTyped := obj.(EventEnabled)
        return typed, isTyped
}</span>

func marshalEventWritable(obj interface{}) (EventWritable, bool) <span class="cov0" title="0">{
        typed, isTyped := obj.(EventWritable)
        return typed, isTyped
}</span>

func marshalEventMeta(obj interface{}) (EventMeta, bool) <span class="cov8" title="1">{
        typed, isTyped := obj.(EventMeta)
        return typed, isTyped
}</span>
</pre>
		
		<pre class="file" id="file51" style="display: none">package logger

const (
        // FlagAll is a special flag that allows all events to fire.
        FlagAll Flag = "all"
        // FlagNone is a special flag that allows no events to fire.
        FlagNone Flag = "none"

        // Fatal fires for fatal errors and is an alias to `Fatal`.
        Fatal Flag = "fatal"
        // Error fires for errors that are severe enough to log but not so severe as to abort a process.
        Error Flag = "error"
        // Warning fires for warnings.
        Warning Flag = "warning"
        // Debug fires for debug messages.
        Debug Flag = "debug"
        // Info fires for informational messages (app startup etc.)
        Info Flag = "info"
        // Silly is for when you just need to log something weird.
        Silly Flag = "silly"

        // WebRequestStart is an event flag.
        WebRequestStart Flag = "web.request.start"
        // WebRequest is an event flag.
        WebRequest Flag = "web.request"

        // Audit is an event flag.
        Audit Flag = "audit"
)

// Flag represents an event type that can be enabled or disabled.
type Flag string

// AsFlags casts a variadic list of strings to an array of Flag.
func AsFlags(values ...string) (output []Flag) <span class="cov0" title="0">{
        for _, v := range values </span><span class="cov0" title="0">{
                output = append(output, Flag(v))
        }</span>
        <span class="cov0" title="0">return</span>
}

// AsStrings casts a variadic list of flags to an array of strings.
func AsStrings(values ...Flag) (output []string) <span class="cov8" title="1">{
        for _, v := range values </span><span class="cov8" title="1">{
                output = append(output, string(v))
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file52" style="display: none">package logger

import (
        "strings"

        "github.com/blend/go-sdk/env"
)

// NewFlagSet returns a new FlagSet with the given flags enabled.
func NewFlagSet(flags ...Flag) *FlagSet <span class="cov8" title="1">{
        efs := &amp;FlagSet{
                flags: make(map[Flag]bool),
        }
        for _, flag := range flags </span><span class="cov8" title="1">{
                efs.Enable(flag)
        }</span>
        <span class="cov8" title="1">return efs</span>
}

// NewFlagSetAll returns a new FlagSet with all flags enabled.
func NewFlagSetAll() *FlagSet <span class="cov8" title="1">{
        return &amp;FlagSet{
                flags: make(map[Flag]bool),
                all:   true,
        }
}</span>

// AllFlags is an alias to NewFlagSetAll()
func AllFlags() *FlagSet <span class="cov8" title="1">{
        return NewFlagSetAll()
}</span>

// NewFlagSetNone returns a new FlagSet with no flags enabled.
func NewFlagSetNone() *FlagSet <span class="cov8" title="1">{
        return &amp;FlagSet{
                flags: make(map[Flag]bool),
                none:  true,
        }
}</span>

// NoneFlags is an alias to NewFlagSetNone.
func NoneFlags() *FlagSet <span class="cov0" title="0">{
        return NewFlagSetNone()
}</span>

// NewHiddenFlagSetFromEnv returns the hidden FlagSet from the environment.
func NewHiddenFlagSetFromEnv() *FlagSet <span class="cov0" title="0">{
        return NewFlagSetFromValues(env.Env().CSV(EnvVarHiddenEventFlags)...)
}</span>

// NewFlagSetFromEnv returns a the enabled FlagSet from the environment.
func NewFlagSetFromEnv() *FlagSet <span class="cov8" title="1">{
        return NewFlagSetFromValues(env.Env().CSV(EnvVarEventFlags)...)
}</span>

// NewFlagSetFromValues returns a new event flag set from an array of flag values.
func NewFlagSetFromValues(flags ...string) *FlagSet <span class="cov8" title="1">{
        flagSet := &amp;FlagSet{
                flags: map[Flag]bool{},
        }

        for _, flag := range flags </span><span class="cov8" title="1">{
                parsedFlag := Flag(strings.Trim(strings.ToLower(flag), " \t\n"))
                if string(parsedFlag) == string(FlagAll) </span><span class="cov8" title="1">{
                        flagSet.all = true
                }</span>

                <span class="cov8" title="1">if string(parsedFlag) == string(FlagNone) </span><span class="cov8" title="1">{
                        flagSet.none = true
                        return flagSet
                }</span>

                <span class="cov8" title="1">if strings.HasPrefix(string(parsedFlag), "-") </span><span class="cov8" title="1">{
                        flag := Flag(strings.TrimPrefix(string(parsedFlag), "-"))
                        flagSet.flags[flag] = false
                }</span> else<span class="cov8" title="1"> {
                        flagSet.flags[parsedFlag] = true
                }</span>
        }

        <span class="cov8" title="1">return flagSet</span>
}

// FlagSet is a set of event flags.
type FlagSet struct {
        flags map[Flag]bool
        all   bool
        none  bool
}

// Enable enables an event flag.
func (efs *FlagSet) Enable(flag Flag) <span class="cov8" title="1">{
        efs.none = false
        efs.flags[flag] = true
}</span>

// Disable disabled an event flag.
func (efs *FlagSet) Disable(flag Flag) <span class="cov8" title="1">{
        efs.flags[flag] = false
}</span>

// SetAll flips the `all` bit on the flag set.
func (efs *FlagSet) SetAll() <span class="cov8" title="1">{
        efs.all = true
        efs.none = false
}</span>

// All returns if the all bit is flipped on.
func (efs *FlagSet) All() bool <span class="cov8" title="1">{
        return efs.all
}</span>

// SetNone flips the `none` bit on the flag set.
func (efs *FlagSet) SetNone() <span class="cov8" title="1">{
        efs.all = false
        efs.flags = map[Flag]bool{}
        efs.none = true
}</span>

// None returns if the none bit is flipped on.
func (efs *FlagSet) None() bool <span class="cov8" title="1">{
        return efs.none
}</span>

// IsEnabled checks to see if an event is enabled.
func (efs FlagSet) IsEnabled(flag Flag) bool <span class="cov8" title="1">{
        if efs.all </span><span class="cov8" title="1">{
                // figure out if we explicitly disabled the flag.
                if enabled, hasEvent := efs.flags[flag]; hasEvent &amp;&amp; !enabled </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">return true</span>
        }
        <span class="cov8" title="1">if efs.none </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if efs.flags != nil </span><span class="cov8" title="1">{
                if enabled, hasFlag := efs.flags[flag]; hasFlag </span><span class="cov8" title="1">{
                        return enabled
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (efs FlagSet) String() string <span class="cov0" title="0">{
        if efs.none </span><span class="cov0" title="0">{
                return string(FlagNone)
        }</span>

        <span class="cov0" title="0">var flags []string
        if efs.all </span><span class="cov0" title="0">{
                flags = []string{string(FlagAll)}
        }</span>
        <span class="cov0" title="0">for key, enabled := range efs.flags </span><span class="cov0" title="0">{
                if key != FlagAll </span><span class="cov0" title="0">{
                        if enabled </span><span class="cov0" title="0">{
                                if !efs.all </span><span class="cov0" title="0">{
                                        flags = append(flags, string(key))
                                }</span>
                        } else<span class="cov0" title="0"> {
                                flags = append(flags, "-"+string(key))
                        }</span>
                }
        }
        <span class="cov0" title="0">return strings.Join(flags, ", ")</span>
}

// CoalesceWith sets the set from another, with the other taking precedence.
func (efs *FlagSet) CoalesceWith(other *FlagSet) <span class="cov8" title="1">{
        if other.all </span><span class="cov0" title="0">{
                efs.all = true
        }</span>
        <span class="cov8" title="1">if other.none </span><span class="cov0" title="0">{
                efs.none = true
        }</span>
        <span class="cov8" title="1">for key, value := range other.flags </span><span class="cov8" title="1">{
                efs.flags[key] = value
        }</span>
}
</pre>
		
		<pre class="file" id="file53" style="display: none">package logger

import (
        "io"
        "sync"
)

// NewInterlockedWriter returns a new interlocked writer.
func NewInterlockedWriter(output io.Writer) io.Writer <span class="cov8" title="1">{
        return &amp;InterlockedWriter{
                output:   output,
                syncRoot: sync.Mutex{},
        }
}</span>

// InterlockedWriter is a writer that serializes access to the Write() method.
type InterlockedWriter struct {
        output   io.Writer
        syncRoot sync.Mutex
}

// Write writes the given bytes to the inner writer.
func (iw *InterlockedWriter) Write(buffer []byte) (count int, err error) <span class="cov8" title="1">{
        iw.syncRoot.Lock()

        count, err = iw.output.Write(buffer)
        if err != nil </span><span class="cov0" title="0">{
                iw.syncRoot.Unlock()
                return
        }</span>
        <span class="cov8" title="1">iw.syncRoot.Unlock()
        return</span>
}

// Close closes any outputs that are io.WriteCloser's.
func (iw *InterlockedWriter) Close() (err error) <span class="cov0" title="0">{
        iw.syncRoot.Lock()
        defer iw.syncRoot.Unlock()

        if typed, isTyped := iw.output.(io.WriteCloser); isTyped </span><span class="cov0" title="0">{
                err = typed.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file54" style="display: none">package logger

import (
        "encoding/json"
        "io"
        "os"
)

const (
        // JSONFieldLabel is a common json field.
        JSONFieldLabel = "label"
        // JSONFieldFlag is a common json field.
        JSONFieldFlag = "flag"
        // JSONFieldTimestamp is a common json field.
        JSONFieldTimestamp = "ts"
        // JSONFieldMessage is a common json field.
        JSONFieldMessage = "message"
        // JSONFieldElapsed is a common json field.
        JSONFieldElapsed = "elapsed"
        // JSONFieldErr is a common json field.
        JSONFieldErr = "err"
        // JSONFieldEventHeading is a common json field.
        JSONFieldEventHeading = "event-heading"

        // DefaultJSONWriterPretty is a default.
        DefaultJSONWriterPretty = false
)

// JSONObj is a type alias for map[string]Any
type JSONObj = map[string]Any

// JSONWritable is a type with a custom formater for json writing.
type JSONWritable interface {
        WriteJSON() JSONObj
}

// NewJSONWriter returns a json writer with defaults.
func NewJSONWriter() *JSONWriter <span class="cov0" title="0">{
        return &amp;JSONWriter{
                output:      NewInterlockedWriter(os.Stdout),
                errorOutput: NewInterlockedWriter(os.Stderr),
                pretty:      DefaultJSONWriterPretty,
        }
}</span>

// NewJSONWriterForOutput returns a new json writer for a given output.
func NewJSONWriterForOutput(output io.Writer) *JSONWriter <span class="cov8" title="1">{
        return &amp;JSONWriter{
                output: NewInterlockedWriter(output),
                pretty: DefaultJSONWriterPretty,
        }
}</span>

// NewJSONWriterFromEnv returns a new json writer from the environment.
func NewJSONWriterFromEnv() *JSONWriter <span class="cov0" title="0">{
        return NewJSONWriterFromConfig(NewJSONWriterConfigFromEnv())
}</span>

// NewJSONWriterFromConfig returns a new json writer from a config.
func NewJSONWriterFromConfig(cfg *JSONWriterConfig) *JSONWriter <span class="cov8" title="1">{
        return &amp;JSONWriter{
                output:      NewInterlockedWriter(os.Stdout),
                errorOutput: NewInterlockedWriter(os.Stderr),
                pretty:      cfg.GetPretty(),
        }
}</span>

// JSONWriter is a json output format.
type JSONWriter struct {
        output      io.Writer
        errorOutput io.Writer
        label       string
        pretty      bool
}

// OutputFormat returns the output format.
func (jw *JSONWriter) OutputFormat() OutputFormat <span class="cov8" title="1">{
        return OutputFormatJSON
}</span>

// WithOutput sets the primary output.
func (jw *JSONWriter) WithOutput(output io.Writer) *JSONWriter <span class="cov0" title="0">{
        jw.output = NewInterlockedWriter(output)
        return jw
}</span>

// WithErrorOutput sets the error output.
func (jw *JSONWriter) WithErrorOutput(errorOutput io.Writer) *JSONWriter <span class="cov0" title="0">{
        jw.errorOutput = NewInterlockedWriter(errorOutput)
        return jw
}</span>

// Label returns a descriptive label for the writer.
func (jw *JSONWriter) Label() string <span class="cov0" title="0">{
        return jw.label
}</span>

// WithLabel sets the writer label.
func (jw *JSONWriter) WithLabel(label string) Writer <span class="cov0" title="0">{
        jw.label = label
        return jw
}</span>

// Output returns an io.Writer for the ouptut stream.
func (jw *JSONWriter) Output() io.Writer <span class="cov0" title="0">{
        return jw.output
}</span>

// ErrorOutput returns an io.Writer for the error stream.
func (jw *JSONWriter) ErrorOutput() io.Writer <span class="cov8" title="1">{
        if jw.errorOutput != nil </span><span class="cov0" title="0">{
                return jw.errorOutput
        }</span>
        <span class="cov8" title="1">return jw.output</span>
}

// Write writes to stdout.
func (jw *JSONWriter) Write(e Event) error <span class="cov0" title="0">{
        return jw.write(jw.output, e)
}</span>

// WriteError writes to stderr (or stdout if .errorOutput is unset).
func (jw *JSONWriter) WriteError(e Event) error <span class="cov8" title="1">{
        return jw.write(jw.ErrorOutput(), e)
}</span>

func (jw *JSONWriter) write(output io.Writer, e Event) error <span class="cov8" title="1">{
        encoder := json.NewEncoder(output)
        if jw.pretty </span><span class="cov0" title="0">{
                encoder.SetIndent("", "\t")
        }</span>

        <span class="cov8" title="1">if typed, isTyped := e.(JSONWritable); isTyped </span><span class="cov8" title="1">{
                fields := typed.WriteJSON()
                if len(jw.label) &gt; 0 </span><span class="cov0" title="0">{
                        fields[JSONFieldLabel] = jw.label
                }</span>
                <span class="cov8" title="1">if typed, isTyped := e.(EventHeading); isTyped &amp;&amp; len(typed.Heading()) &gt; 0 </span><span class="cov0" title="0">{
                        fields[JSONFieldEventHeading] = typed.Heading()
                }</span>
                <span class="cov8" title="1">fields[JSONFieldFlag] = e.Flag()
                fields[JSONFieldTimestamp] = e.Timestamp()
                return encoder.Encode(fields)</span>
        }

        <span class="cov0" title="0">return encoder.Encode(e)</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">package logger

import (
        "fmt"
        "net/http"
        "os"
        "runtime"
        "sync"
)

const (

        // DefaultListenerName is a default.
        DefaultListenerName = "default"

        // DefaultRecoverPanics is a default.
        DefaultRecoverPanics = true
)

var (
        // DefaultListenerWorkers is the default number of workers per listener.
        DefaultListenerWorkers = runtime.NumCPU()
)

// FatalExit creates a logger and calls `SyncFatalExit` on it.
func FatalExit(err error) <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">All().SyncFatalExit(err)</span>
}

// New returns a new logger with a given set of enabled flags, without a writer provisioned.
func New(flags ...Flag) *Logger <span class="cov8" title="1">{
        return &amp;Logger{
                recoverPanics: DefaultRecoverPanics,
                flags:         NewFlagSet(flags...),
        }
}</span>

// NewFromConfig returns a new logger from a config.
func NewFromConfig(cfg *Config) *Logger <span class="cov8" title="1">{
        return &amp;Logger{
                recoverPanics: cfg.GetRecoverPanics(),
                flags:         NewFlagSetFromValues(cfg.GetFlags()...),
                hiddenFlags:   NewFlagSetFromValues(cfg.GetHiddenFlags()...),
                writers:       cfg.GetWriters(),
        }
}</span>

// NewFromEnv returns a new agent with settings read from the environment,
// including the underlying writer.
func NewFromEnv() *Logger <span class="cov8" title="1">{
        return NewFromConfig(NewConfigFromEnv())
}</span>

// All returns a valid logger that fires any and all events, and includes a writer.
// It is effectively an alias to:
//         New().WithFlags(NewFlagSetAll()).WithWriter(NewWriterFromEnv())
func All() *Logger <span class="cov0" title="0">{
        return New().WithFlags(NewFlagSetAll()).WithWriter(NewWriterFromEnv())
}</span>

// None returns a valid agent that won't fire any events.
func None() *Logger <span class="cov0" title="0">{
        return &amp;Logger{
                flags: NewFlagSetNone(),
        }
}</span>

// NewText returns a new text logger.
func NewText() *Logger <span class="cov0" title="0">{
        return NewFromEnv().WithWriter(NewTextWriterFromEnv())
}</span>

// NewJSON returns a new json logger.
func NewJSON() *Logger <span class="cov0" title="0">{
        return NewFromEnv().WithWriter(NewJSONWriterFromEnv())
}</span>

// Logger is a handler for various logging events with descendent handlers.
type Logger struct {
        writers []Writer

        flagsLock sync.Mutex
        flags     *FlagSet

        hiddenFlagsLock sync.Mutex
        hiddenFlags     *FlagSet

        workersLock sync.Mutex
        workers     map[Flag]map[string]*Worker

        recoverPanics bool

        writeWorkerLock      sync.Mutex
        writeWorker          *Worker
        writeErrorWorkerLock sync.Mutex
        writeErrorWorker     *Worker
}

// WithLabel sets the writer label for any configured writers.
func (l *Logger) WithLabel(label string) *Logger <span class="cov0" title="0">{
        if len(l.writers) &gt; 0 </span><span class="cov0" title="0">{
                for _, w := range l.writers </span><span class="cov0" title="0">{
                        w.WithLabel(label)
                }</span>
        }
        <span class="cov0" title="0">return l</span>
}

// Writers returns the output writers for events.
func (l *Logger) Writers() []Writer <span class="cov8" title="1">{
        return l.writers
}</span>

// WithWriters sets the logger writers, overwriting any existing writers.
func (l *Logger) WithWriters(writers ...Writer) *Logger <span class="cov0" title="0">{
        l.writers = writers
        return l
}</span>

// WithWriter adds a logger writer.
func (l *Logger) WithWriter(writer Writer) *Logger <span class="cov8" title="1">{
        l.writers = append(l.writers, writer)
        return l
}</span>

// RecoversPanics returns if we should recover panics in logger listeners.
func (l *Logger) RecoversPanics() bool <span class="cov0" title="0">{
        return l.recoverPanics
}</span>

// WithRecoverPanics sets the recoverPanics sets if the logger should trap panics in event handlers.
func (l *Logger) WithRecoverPanics(value bool) *Logger <span class="cov0" title="0">{
        l.recoverPanics = value
        return l
}</span>

// Flags returns the logger flag set.
func (l *Logger) Flags() *FlagSet <span class="cov8" title="1">{
        return l.flags
}</span>

// WithFlags sets the logger flag set.
func (l *Logger) WithFlags(flags *FlagSet) *Logger <span class="cov8" title="1">{
        l.flagsLock.Lock()
        l.flags = flags
        l.flagsLock.Unlock()
        return l
}</span>

// WithHiddenFlags sets the hidden flag set.
// These flags mark events as to be omitted from output.
func (l *Logger) WithHiddenFlags(flags *FlagSet) *Logger <span class="cov8" title="1">{
        l.hiddenFlagsLock.Lock()
        l.hiddenFlags = flags
        l.hiddenFlagsLock.Unlock()
        return l
}</span>

// WithFlagsFromEnv adds flags from the environment.
func (l *Logger) WithFlagsFromEnv() *Logger <span class="cov0" title="0">{
        l.flagsLock.Lock()
        defer l.flagsLock.Unlock()

        l.hiddenFlagsLock.Lock()
        defer l.hiddenFlagsLock.Unlock()

        if l.flags != nil </span><span class="cov0" title="0">{
                l.flags.CoalesceWith(NewFlagSetFromEnv())
        }</span> else<span class="cov0" title="0"> {
                l.flags = NewFlagSetFromEnv()
        }</span>

        <span class="cov0" title="0">if l.hiddenFlags != nil </span><span class="cov0" title="0">{
                l.hiddenFlags.CoalesceWith(NewHiddenFlagSetFromEnv())
        }</span> else<span class="cov0" title="0"> {
                l.hiddenFlags = NewHiddenFlagSetFromEnv()
        }</span>
        <span class="cov0" title="0">return l</span>
}

// WithEnabled flips the bit flag for a given set of events.
func (l *Logger) WithEnabled(flags ...Flag) *Logger <span class="cov8" title="1">{
        l.Enable(flags...)
        return l
}</span>

// Enable flips the bit flag for a given set of events.
func (l *Logger) Enable(flags ...Flag) <span class="cov8" title="1">{
        l.flagsLock.Lock()
        defer l.flagsLock.Unlock()

        if l.flags != nil </span><span class="cov8" title="1">{
                for _, flag := range flags </span><span class="cov8" title="1">{
                        l.flags.Enable(flag)
                }</span>
        } else<span class="cov0" title="0"> {
                l.flags = NewFlagSet(flags...)
        }</span>
}

// WithDisabled flips the bit flag for a given set of events.
func (l *Logger) WithDisabled(flags ...Flag) *Logger <span class="cov8" title="1">{
        l.Disable(flags...)
        return l
}</span>

// Disable flips the bit flag for a given set of events.
func (l *Logger) Disable(flags ...Flag) <span class="cov8" title="1">{
        if l.flags == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">l.flagsLock.Lock()
        defer l.flagsLock.Unlock()
        for _, flag := range flags </span><span class="cov8" title="1">{
                l.flags.Disable(flag)
        }</span>
}

// IsEnabled asserts if a flag value is set or not.
func (l *Logger) IsEnabled(flag Flag) bool <span class="cov8" title="1">{
        if l.flags == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return l.flags.IsEnabled(flag)</span>
}

// Hide disallows automatic logging for each event emitted under the provided list of flags.
func (l *Logger) Hide(flags ...Flag) <span class="cov0" title="0">{
        l.hiddenFlagsLock.Lock()
        defer l.hiddenFlagsLock.Unlock()

        if l.hiddenFlags != nil </span><span class="cov0" title="0">{
                for _, flag := range flags </span><span class="cov0" title="0">{
                        l.hiddenFlags.Enable(flag)
                }</span>
        } else<span class="cov0" title="0"> {
                l.hiddenFlags = NewFlagSet(flags...)
        }</span>
}

// IsHidden asserts if a flag is hidden or not.
func (l *Logger) IsHidden(flag Flag) bool <span class="cov8" title="1">{
        if l.hiddenFlags == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return l.hiddenFlags.IsEnabled(flag)</span>
}

// WithHidden hides a set of flags and returns logger
func (l *Logger) WithHidden(flags ...Flag) *Logger <span class="cov0" title="0">{
        l.Hide(flags...)
        return l
}</span>

// Show allows automatic logging for each event emitted under the provided list of flags.
func (l *Logger) Show(flags ...Flag) <span class="cov0" title="0">{
        if l.hiddenFlags == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">l.hiddenFlagsLock.Lock()
        defer l.hiddenFlagsLock.Unlock()
        for _, flag := range flags </span><span class="cov0" title="0">{
                l.hiddenFlags.Disable(flag)
        }</span>
}

// HasListeners returns if there are registered listener for an event.
func (l *Logger) HasListeners(flag Flag) bool <span class="cov8" title="1">{
        if l == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if l.workers == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">workers, hasWorkers := l.workers[flag]
        if !hasWorkers </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return len(workers) &gt; 0</span>
}

// HasListener returns if a specific listener is registerd for a flag.
func (l *Logger) HasListener(flag Flag, listenerName string) bool <span class="cov8" title="1">{
        if l == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if l.workers == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">workers, hasWorkers := l.workers[flag]
        if !hasWorkers </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">_, hasWorker := workers[listenerName]
        return hasWorker</span>
}

// Listen adds a listener for a given flag.
func (l *Logger) Listen(flag Flag, listenerName string, listener Listener) <span class="cov8" title="1">{
        l.workersLock.Lock()
        defer l.workersLock.Unlock()

        if l.workers == nil </span><span class="cov8" title="1">{
                l.workers = map[Flag]map[string]*Worker{}
        }</span>

        <span class="cov8" title="1">w := NewWorker(l, listener).WithRecoverPanics(l.recoverPanics)
        if listeners, hasListeners := l.workers[flag]; hasListeners </span><span class="cov8" title="1">{
                listeners[listenerName] = w
        }</span> else<span class="cov8" title="1"> {
                l.workers[flag] = map[string]*Worker{
                        listenerName: w,
                }
        }</span>
        <span class="cov8" title="1">w.Start()</span>
}

// RemoveListeners clears *all* listeners for a Flag.
func (l *Logger) RemoveListeners(flag Flag) <span class="cov8" title="1">{
        if l.workers == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">l.workersLock.Lock()
        defer l.workersLock.Unlock()

        listeners, hasListeners := l.workers[flag]
        if !hasListeners </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">for _, w := range listeners </span><span class="cov8" title="1">{
                w.Close()
        }</span>

        <span class="cov8" title="1">delete(l.workers, flag)</span>
}

// RemoveListener clears a specific listener for a Flag.
func (l *Logger) RemoveListener(flag Flag, listenerName string) <span class="cov0" title="0">{
        if l.workers == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">l.workersLock.Lock()
        defer l.workersLock.Unlock()

        listeners, hasListeners := l.workers[flag]
        if !hasListeners </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">worker, hasWorker := listeners[listenerName]
        if !hasWorker </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">worker.Close()
        delete(listeners, listenerName)

        if len(listeners) == 0 </span><span class="cov0" title="0">{
                delete(l.workers, flag)
        }</span>
}

// Trigger fires the listeners for a given event asynchronously.
// The invocations will be queued in a work queue and processed by a fixed worker count.
// There are no order guarantees on when these events will be processed.
// This call will not block on the event listeners.
func (l *Logger) Trigger(e Event) <span class="cov8" title="1">{
        l.trigger(true, e)
}</span>

// SyncTrigger fires the listeners for a given event synchronously.
// The invocations will be triggered immediately, blocking the call.
func (l *Logger) SyncTrigger(e Event) <span class="cov8" title="1">{
        l.trigger(false, e)
}</span>

func (l *Logger) trigger(async bool, e Event) <span class="cov8" title="1">{
        if l == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if e == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if l.flags == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if async </span><span class="cov8" title="1">{
                l.ensureInitialized()
        }</span>

        <span class="cov8" title="1">if typed, isTyped := e.(EventEnabled); isTyped &amp;&amp; !typed.IsEnabled() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">flag := e.Flag()
        if l.IsEnabled(flag) </span><span class="cov8" title="1">{
                if l.workers != nil </span><span class="cov8" title="1">{
                        if workers, hasWorkers := l.workers[flag]; hasWorkers </span><span class="cov8" title="1">{
                                for _, worker := range workers </span><span class="cov8" title="1">{
                                        if async </span><span class="cov8" title="1">{
                                                worker.Work &lt;- e
                                        }</span> else<span class="cov8" title="1"> {
                                                worker.Listener(e)
                                        }</span>
                                }
                        }
                }

                // check if the flag is globally hidden from output.
                <span class="cov8" title="1">if l.IsHidden(flag) </span><span class="cov0" title="0">{
                        return
                }</span>

                // check if the event controls if it should be written or not.
                <span class="cov8" title="1">if typed, isTyped := e.(EventWritable); isTyped &amp;&amp; !typed.IsWritable() </span><span class="cov8" title="1">{
                        return
                }</span>

                // check if the event should be handled by the error outputs
                <span class="cov8" title="1">if typed, isTyped := e.(EventError); isTyped &amp;&amp; typed.IsError() </span><span class="cov8" title="1">{
                        if async </span><span class="cov8" title="1">{
                                l.writeErrorWorker.Work &lt;- e
                        }</span> else<span class="cov8" title="1"> {
                                l.WriteError(e)
                        }</span>
                } else<span class="cov8" title="1"> {
                        if async </span><span class="cov8" title="1">{
                                l.writeWorker.Work &lt;- e
                        }</span> else<span class="cov8" title="1"> {
                                l.Write(e)
                        }</span>
                }
        }
}

// --------------------------------------------------------------------------------
// Builtin Flag Handlers (infof, debugf etc.)
// --------------------------------------------------------------------------------

// Sillyf logs an incredibly verbose message to the output stream.
func (l *Logger) Sillyf(format string, args ...interface{}) <span class="cov8" title="1">{
        if l == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">l.Trigger(Messagef(Silly, format, args...))</span>
}

// SyncSillyf logs an incredibly verbose message to the output stream synchronously.
func (l *Logger) SyncSillyf(format string, args ...interface{}) <span class="cov8" title="1">{
        if l == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">l.SyncTrigger(Messagef(Silly, format, args...))</span>
}

// Infof logs an informational message to the output stream.
func (l *Logger) Infof(format string, args ...interface{}) <span class="cov8" title="1">{
        if l == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">l.Trigger(Messagef(Info, format, args...))</span>
}

// SyncInfof logs an informational message to the output stream synchronously.
func (l *Logger) SyncInfof(format string, args ...interface{}) <span class="cov8" title="1">{
        if l == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">l.SyncTrigger(Messagef(Info, format, args...))</span>
}

// Debugf logs a debug message to the output stream.
func (l *Logger) Debugf(format string, args ...interface{}) <span class="cov8" title="1">{
        if l == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">l.Trigger(Messagef(Debug, format, args...))</span>
}

// SyncDebugf logs an debug message to the output stream synchronously.
func (l *Logger) SyncDebugf(format string, args ...interface{}) <span class="cov8" title="1">{
        if l == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">l.SyncTrigger(Messagef(Debug, format, args...))</span>
}

// Warningf logs a debug message to the output stream.
func (l *Logger) Warningf(format string, args ...interface{}) error <span class="cov8" title="1">{
        if l == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return l.Warning(fmt.Errorf(format, args...))</span>
}

// SyncWarningf logs an warning message to the output stream synchronously.
func (l *Logger) SyncWarningf(format string, args ...interface{}) <span class="cov8" title="1">{
        if l == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">l.SyncTrigger(Errorf(Warning, format, args...))</span>
}

// Warning logs a warning error to std err.
func (l *Logger) Warning(err error) error <span class="cov8" title="1">{
        if l != nil </span><span class="cov8" title="1">{
                l.Trigger(NewErrorEvent(Warning, err))
        }</span>
        <span class="cov8" title="1">return err</span>
}

// SyncWarning synchronously logs a warning to std err.
func (l *Logger) SyncWarning(err error) error <span class="cov0" title="0">{
        if l != nil </span><span class="cov0" title="0">{
                l.SyncTrigger(NewErrorEvent(Warning, err))
        }</span>
        <span class="cov0" title="0">return err</span>
}

// WarningWithReq logs a warning error to std err with a request.
func (l *Logger) WarningWithReq(err error, req *http.Request) error <span class="cov0" title="0">{
        if l != nil </span><span class="cov0" title="0">{
                l.Trigger(NewErrorEventWithState(Warning, err, req))
        }</span>
        <span class="cov0" title="0">return err</span>
}

// Errorf writes an event to the log and triggers event listeners.
func (l *Logger) Errorf(format string, args ...interface{}) error <span class="cov8" title="1">{
        if l == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return l.Error(fmt.Errorf(format, args...))</span>
}

// SyncErrorf synchronously triggers a error.
func (l *Logger) SyncErrorf(format string, args ...interface{}) <span class="cov8" title="1">{
        if l == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">l.SyncTrigger(Errorf(Error, format, args...))</span>
}

// Error logs an error to std err.
func (l *Logger) Error(err error) error <span class="cov8" title="1">{
        if l != nil </span><span class="cov8" title="1">{
                l.Trigger(NewErrorEvent(Error, err))
        }</span>
        <span class="cov8" title="1">return err</span>
}

// SyncError synchronously logs an error to std err.
func (l *Logger) SyncError(err error) error <span class="cov0" title="0">{
        if l != nil </span><span class="cov0" title="0">{
                l.SyncTrigger(NewErrorEvent(Error, err))
        }</span>
        <span class="cov0" title="0">return err</span>
}

// ErrorWithReq logs an error to std err with a request.
func (l *Logger) ErrorWithReq(err error, req *http.Request) error <span class="cov0" title="0">{
        if l != nil </span><span class="cov0" title="0">{
                l.Trigger(NewErrorEventWithState(Error, err, req))
        }</span>
        <span class="cov0" title="0">return err</span>
}

// Fatalf writes an event to the log and triggers event listeners.
func (l *Logger) Fatalf(format string, args ...interface{}) error <span class="cov8" title="1">{
        if l == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return l.Fatal(fmt.Errorf(format, args...))</span>
}

// SyncFatalf synchronously triggers a fatal.
func (l *Logger) SyncFatalf(format string, args ...interface{}) <span class="cov8" title="1">{
        if l == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">l.SyncTrigger(Errorf(Fatal, format, args...))</span>
}

// Fatal logs the result of a panic to std err.
func (l *Logger) Fatal(err error) error <span class="cov8" title="1">{
        if l != nil </span><span class="cov8" title="1">{
                l.Trigger(NewErrorEvent(Fatal, err))
        }</span>
        <span class="cov8" title="1">return err</span>
}

// SyncFatal synchronously logs a fatal to std err.
func (l *Logger) SyncFatal(err error) error <span class="cov0" title="0">{
        if l != nil </span><span class="cov0" title="0">{
                l.SyncTrigger(NewErrorEvent(Fatal, err))
        }</span>
        <span class="cov0" title="0">return err</span>
}

// FatalWithReq logs the result of a fatal error to std err with a request.
func (l *Logger) FatalWithReq(err error, req *http.Request) error <span class="cov0" title="0">{
        if l != nil </span><span class="cov0" title="0">{
                l.Trigger(NewErrorEventWithState(Fatal, err, req))
        }</span>
        <span class="cov0" title="0">return err</span>
}

// SyncFatalExit logs the result of a fatal error to std err and calls `exit(1)`
func (l *Logger) SyncFatalExit(err error) <span class="cov0" title="0">{
        if l == nil || l.flags == nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">l.Fatal(err)
        l.Drain()
        os.Exit(1)</span>
}

// --------------------------------------------------------------------------------
// finalizers
// --------------------------------------------------------------------------------

// Close releases shared resources for the agent.
func (l *Logger) Close() (err error) <span class="cov8" title="1">{
        if l == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">l.flagsLock.Lock()
        defer l.flagsLock.Unlock()

        if l.flags != nil </span><span class="cov8" title="1">{
                l.flags.SetNone()
        }</span>

        <span class="cov8" title="1">l.workersLock.Lock()
        defer l.workersLock.Unlock()

        for _, workers := range l.workers </span><span class="cov8" title="1">{
                for _, worker := range workers </span><span class="cov8" title="1">{
                        worker.Close()
                }</span>
        }

        <span class="cov8" title="1">if l.writeWorker != nil </span><span class="cov8" title="1">{
                l.writeWorkerLock.Lock()
                defer l.writeWorkerLock.Unlock()
                l.writeWorker.Close()
        }</span>

        <span class="cov8" title="1">if l.writeErrorWorker != nil </span><span class="cov8" title="1">{
                l.writeErrorWorkerLock.Lock()
                defer l.writeErrorWorkerLock.Unlock()
                l.writeErrorWorker.Close()
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Drain waits for the agent to finish its queue of events before closing.
func (l *Logger) Drain() error <span class="cov8" title="1">{
        if l == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">l.workersLock.Lock()
        defer l.workersLock.Unlock()

        for _, workers := range l.workers </span><span class="cov8" title="1">{
                for _, worker := range workers </span><span class="cov8" title="1">{
                        worker.Drain()
                }</span>
        }

        <span class="cov8" title="1">if l.writeWorker != nil </span><span class="cov8" title="1">{
                l.writeWorkerLock.Lock()
                defer l.writeWorkerLock.Unlock()
                l.writeWorker.Drain()
        }</span>

        <span class="cov8" title="1">if l.writeErrorWorker != nil </span><span class="cov8" title="1">{
                l.writeErrorWorkerLock.Lock()
                defer l.writeErrorWorkerLock.Unlock()
                l.writeErrorWorker.Drain()
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// --------------------------------------------------------------------------------
// write helpers
// --------------------------------------------------------------------------------

func (l *Logger) ensureInitialized() <span class="cov8" title="1">{
        if l.writeWorker == nil </span><span class="cov8" title="1">{
                l.writeWorkerLock.Lock()
                defer l.writeWorkerLock.Unlock()
                if l.writeWorker == nil </span><span class="cov8" title="1">{
                        l.writeWorker = NewWorker(l, l.Write)
                        l.writeWorker.Start()
                }</span>
        }
        <span class="cov8" title="1">if l.writeErrorWorker == nil </span><span class="cov8" title="1">{
                l.writeErrorWorkerLock.Lock()
                defer l.writeErrorWorkerLock.Unlock()
                if l.writeErrorWorker == nil </span><span class="cov8" title="1">{
                        l.writeErrorWorker = NewWorker(l, l.WriteError)
                        l.writeErrorWorker.Start()
                }</span>
        }
}

// Write writes to the writer.
func (l *Logger) Write(e Event) <span class="cov8" title="1">{
        if len(l.writers) &gt; 0 </span><span class="cov8" title="1">{
                for _, writer := range l.writers </span><span class="cov8" title="1">{
                        writer.Write(e)
                }</span>
        }
}

// WriteError writes to the error writer.
func (l *Logger) WriteError(e Event) <span class="cov8" title="1">{
        if len(l.writers) &gt; 0 </span><span class="cov8" title="1">{
                for _, writer := range l.writers </span><span class="cov8" title="1">{
                        writer.WriteError(e)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file56" style="display: none">package logger

import (
        "bytes"
        "fmt"
        "time"
)

// Messagef returns a new Message Event.
func Messagef(flag Flag, format string, args ...Any) *MessageEvent <span class="cov8" title="1">{
        return &amp;MessageEvent{
                flag:    flag,
                ts:      time.Now().UTC(),
                message: fmt.Sprintf(format, args...),
        }
}</span>

// MessagefWithFlagTextColor returns a new Message Event with a given flag text color.
func MessagefWithFlagTextColor(flag Flag, flagColor AnsiColor, format string, args ...Any) *MessageEvent <span class="cov0" title="0">{
        return &amp;MessageEvent{
                flag:      flag,
                flagColor: flagColor,
                ts:        time.Now().UTC(),
                message:   fmt.Sprintf(format, args...),
        }
}</span>

// NewMessageEventListener returns a new message event listener.
func NewMessageEventListener(listener func(*MessageEvent)) Listener <span class="cov8" title="1">{
        return func(e Event) </span><span class="cov8" title="1">{
                if typed, isTyped := e.(*MessageEvent); isTyped </span><span class="cov8" title="1">{
                        listener(typed)
                }</span>
        }
}

// MessageEvent is a common type of message.
type MessageEvent struct {
        heading   string
        flag      Flag
        flagColor AnsiColor
        ts        time.Time
        message   string

        labels      map[string]string
        annotations map[string]string
}

// WithLabel sets a label on the event for later filtering.
func (e *MessageEvent) WithLabel(key, value string) *MessageEvent <span class="cov8" title="1">{
        if e.labels == nil </span><span class="cov8" title="1">{
                e.labels = map[string]string{}
        }</span>
        <span class="cov8" title="1">e.labels[key] = value
        return e</span>
}

// Labels returns a labels collection.
func (e *MessageEvent) Labels() map[string]string <span class="cov8" title="1">{
        return e.labels
}</span>

// WithAnnotation adds an annotation to the event.
func (e *MessageEvent) WithAnnotation(key, value string) *MessageEvent <span class="cov0" title="0">{
        if e.annotations == nil </span><span class="cov0" title="0">{
                e.annotations = map[string]string{}
        }</span>
        <span class="cov0" title="0">e.annotations[key] = value
        return e</span>
}

// Annotations returns the annotations set.
func (e *MessageEvent) Annotations() map[string]string <span class="cov0" title="0">{
        return e.annotations
}</span>

// WithFlag sets the message flag.
func (e *MessageEvent) WithFlag(flag Flag) *MessageEvent <span class="cov0" title="0">{
        e.flag = flag
        return e
}</span>

// Flag returns the message flag.
func (e *MessageEvent) Flag() Flag <span class="cov8" title="1">{
        return e.flag
}</span>

// WithTimestamp sets the message timestamp.
func (e *MessageEvent) WithTimestamp(ts time.Time) *MessageEvent <span class="cov0" title="0">{
        e.ts = ts
        return e
}</span>

// Timestamp returns the message timestamp.
func (e *MessageEvent) Timestamp() time.Time <span class="cov8" title="1">{
        return e.ts
}</span>

// WithMessage sets the message.
func (e *MessageEvent) WithMessage(message string) *MessageEvent <span class="cov0" title="0">{
        e.message = message
        return e
}</span>

// Message returns the message.
func (e *MessageEvent) Message() string <span class="cov8" title="1">{
        return e.message
}</span>

// WithHeading sets the heading.
func (e *MessageEvent) WithHeading(heading string) *MessageEvent <span class="cov8" title="1">{
        e.heading = heading
        return e
}</span>

// Heading returns the heading.
func (e *MessageEvent) Heading() string <span class="cov8" title="1">{
        return e.heading
}</span>

// WithFlagTextColor sets the message flag text color.
func (e *MessageEvent) WithFlagTextColor(color AnsiColor) *MessageEvent <span class="cov0" title="0">{
        e.flagColor = color
        return e
}</span>

// FlagTextColor returns a custom color for the flag.
func (e *MessageEvent) FlagTextColor() AnsiColor <span class="cov8" title="1">{
        return e.flagColor
}</span>

// WriteText implements TextWritable.
func (e *MessageEvent) WriteText(formatter TextFormatter, buf *bytes.Buffer) <span class="cov8" title="1">{
        buf.WriteString(e.message)
}</span>

// WriteJSON implements JSONWriteable.
func (e *MessageEvent) WriteJSON() JSONObj <span class="cov0" title="0">{
        return JSONObj{
                JSONFieldMessage: e.message,
        }
}</span>

// String returns the message event body.
func (e *MessageEvent) String() string <span class="cov8" title="1">{
        return e.message
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">package logger

import (
        "bytes"
        "fmt"
        "strings"
        "time"
)

const (
        // Query is a logging flag.
        Query Flag = "db.query"
)

// NewQueryEvent creates a new query event.
func NewQueryEvent(body string, elapsed time.Duration) *QueryEvent <span class="cov8" title="1">{
        return &amp;QueryEvent{
                flag:    Query,
                ts:      time.Now().UTC(),
                body:    body,
                elapsed: elapsed,
        }
}</span>

// NewQueryEventListener returns a new listener for spiffy events.
func NewQueryEventListener(listener func(e *QueryEvent)) Listener <span class="cov8" title="1">{
        return func(e Event) </span><span class="cov8" title="1">{
                if typed, isTyped := e.(*QueryEvent); isTyped </span><span class="cov8" title="1">{
                        listener(typed)
                }</span>
        }
}

// QueryEvent represents a database query.
type QueryEvent struct {
        heading string

        flag       Flag
        ts         time.Time
        engine     string
        queryLabel string
        body       string
        database   string
        elapsed    time.Duration

        labels      map[string]string
        annotations map[string]string
}

// WithHeading sets the event heading.
func (e *QueryEvent) WithHeading(heading string) *QueryEvent <span class="cov8" title="1">{
        e.heading = heading
        return e
}</span>

// Heading returns the event heading.
func (e *QueryEvent) Heading() string <span class="cov8" title="1">{
        return e.heading
}</span>

// WithLabel sets a label on the event for later filtering.
func (e *QueryEvent) WithLabel(key, value string) *QueryEvent <span class="cov8" title="1">{
        if e.labels == nil </span><span class="cov8" title="1">{
                e.labels = map[string]string{}
        }</span>
        <span class="cov8" title="1">e.labels[key] = value
        return e</span>
}

// Labels returns a labels collection.
func (e *QueryEvent) Labels() map[string]string <span class="cov8" title="1">{
        return e.labels
}</span>

// WithAnnotation adds an annotation to the event.
func (e *QueryEvent) WithAnnotation(key, value string) *QueryEvent <span class="cov0" title="0">{
        if e.annotations == nil </span><span class="cov0" title="0">{
                e.annotations = map[string]string{}
        }</span>
        <span class="cov0" title="0">e.annotations[key] = value
        return e</span>
}

// Annotations returns the annotations set.
func (e *QueryEvent) Annotations() map[string]string <span class="cov0" title="0">{
        return e.annotations
}</span>

// WithFlag sets the flag.
func (e *QueryEvent) WithFlag(flag Flag) *QueryEvent <span class="cov0" title="0">{
        e.flag = flag
        return e
}</span>

// Flag returns the event flag.
func (e QueryEvent) Flag() Flag <span class="cov8" title="1">{
        return e.flag
}</span>

// WithTimestamp sets the timestamp.
func (e *QueryEvent) WithTimestamp(ts time.Time) *QueryEvent <span class="cov0" title="0">{
        e.ts = ts
        return e
}</span>

// Timestamp returns the event timestamp.
func (e QueryEvent) Timestamp() time.Time <span class="cov8" title="1">{
        return e.ts
}</span>

// WithEngine sets the engine.
func (e *QueryEvent) WithEngine(engine string) *QueryEvent <span class="cov0" title="0">{
        e.engine = engine
        return e
}</span>

// Engine returns the engine.
func (e QueryEvent) Engine() string <span class="cov0" title="0">{
        return e.engine
}</span>

// WithDatabase sets the database.
func (e *QueryEvent) WithDatabase(db string) *QueryEvent <span class="cov0" title="0">{
        e.database = db
        return e
}</span>

// Database returns the event database.
func (e QueryEvent) Database() string <span class="cov0" title="0">{
        return e.database
}</span>

// WithQueryLabel sets the query label.
func (e *QueryEvent) WithQueryLabel(queryLabel string) *QueryEvent <span class="cov8" title="1">{
        e.queryLabel = queryLabel
        return e
}</span>

// QueryLabel returns the query label.
func (e QueryEvent) QueryLabel() string <span class="cov8" title="1">{
        return e.queryLabel
}</span>

// WithBody sets the body.
func (e *QueryEvent) WithBody(body string) *QueryEvent <span class="cov0" title="0">{
        e.body = body
        return e
}</span>

// Body returns the query body.
func (e QueryEvent) Body() string <span class="cov8" title="1">{
        return e.body
}</span>

// WithElapsed sets the elapsed time.
func (e *QueryEvent) WithElapsed(elapsed time.Duration) *QueryEvent <span class="cov0" title="0">{
        e.elapsed = elapsed
        return e
}</span>

// Elapsed returns the elapsed time.
func (e QueryEvent) Elapsed() time.Duration <span class="cov0" title="0">{
        return e.elapsed
}</span>

// WriteText writes the event text to the output.
func (e QueryEvent) WriteText(tf TextFormatter, buf *bytes.Buffer) <span class="cov0" title="0">{
        buf.WriteString(fmt.Sprintf("[%s] (%v)", tf.Colorize(e.database, ColorBlue), e.elapsed))
        if len(e.queryLabel) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteRune(RuneSpace)
                buf.WriteString(e.queryLabel)
        }</span>
        <span class="cov0" title="0">if len(e.body) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteRune(RuneSpace)
                buf.WriteString(strings.TrimSpace(e.body))
        }</span>
}

// WriteJSON implements JSONWritable.
func (e QueryEvent) WriteJSON() JSONObj <span class="cov0" title="0">{
        return JSONObj{
                "engine":         e.engine,
                "database":       e.database,
                "queryLabel":     e.queryLabel,
                "body":           e.body,
                JSONFieldElapsed: Milliseconds(e.elapsed),
        }
}</span>
</pre>
		
		<pre class="file" id="file58" style="display: none">package logger

import "net/http"

// ResponseWrapper is a type that wraps a response.
type ResponseWrapper interface {
        InnerResponse() http.ResponseWriter
}

// NewResponseWriter creates a new response writer.
func NewResponseWriter(w http.ResponseWriter) *ResponseWriter <span class="cov0" title="0">{
        return &amp;ResponseWriter{
                innerResponse: w,
        }
}</span>

// ResponseWriter a better response writer
type ResponseWriter struct {
        innerResponse http.ResponseWriter
        statusCode    int
        contentLength int
}

// Write writes the data to the response.
func (rw *ResponseWriter) Write(b []byte) (int, error) <span class="cov0" title="0">{
        bytesWritten, err := rw.innerResponse.Write(b)
        rw.contentLength = rw.contentLength + bytesWritten
        return bytesWritten, err
}</span>

// Header accesses the response header collection.
func (rw *ResponseWriter) Header() http.Header <span class="cov0" title="0">{
        return rw.innerResponse.Header()
}</span>

// WriteHeader is actually a terrible name and this writes the status code.
func (rw *ResponseWriter) WriteHeader(code int) <span class="cov0" title="0">{
        rw.statusCode = code
        rw.innerResponse.WriteHeader(code)
}</span>

// InnerWriter returns the backing writer.
func (rw *ResponseWriter) InnerWriter() http.ResponseWriter <span class="cov0" title="0">{
        return rw.innerResponse
}</span>

// Flush is a no op on raw response writers.
func (rw *ResponseWriter) Flush() error <span class="cov0" title="0">{
        return nil
}</span>

// StatusCode returns the status code.
func (rw *ResponseWriter) StatusCode() int <span class="cov0" title="0">{
        return rw.statusCode
}</span>

// ContentLength returns the content length
func (rw *ResponseWriter) ContentLength() int <span class="cov0" title="0">{
        return rw.contentLength
}</span>
</pre>
		
		<pre class="file" id="file59" style="display: none">package logger

import (
        "bytes"
        "fmt"
        "io"
        "os"
        "strconv"
        "time"
)

const (
        // DefaultBufferPoolSize is the default buffer pool size.
        DefaultBufferPoolSize = 1 &lt;&lt; 8 // 256

        // DefaultTextTimeFormat is the default time format.
        DefaultTextTimeFormat = time.RFC3339

        // DefaultTextWriterUseColor is a default setting for writers.
        DefaultTextWriterUseColor = true
        // DefaultTextWriterShowTime is a default setting for writers.
        DefaultTextWriterShowTime = true
        // DefaultTextWriterShowLabel is a default setting for writers.
        DefaultTextWriterShowLabel = true
)

// TextWritable is a type with a custom formater for text writing.
type TextWritable interface {
        WriteText(formatter TextFormatter, buf *bytes.Buffer)
}

// FlagTextColorProvider is a function types can implement to provide a color.
type FlagTextColorProvider interface {
        FlagTextColor() AnsiColor
}

// TextFormatter formats text.
type TextFormatter interface {
        Colorize(value string, color AnsiColor) string
        ColorizeStatusCode(code int) string
        ColorizeByStatusCode(code int, value string) string
}

// NewTextWriter returns a new text writer for a given output.
func NewTextWriter(output io.Writer) *TextWriter <span class="cov8" title="1">{
        return &amp;TextWriter{
                output:     NewInterlockedWriter(output),
                bufferPool: NewBufferPool(DefaultBufferPoolSize),
                showLabel:  DefaultTextWriterShowLabel,
                showTime:   DefaultTextWriterShowTime,
                useColor:   DefaultTextWriterUseColor,
                timeFormat: DefaultTextTimeFormat,
        }
}</span>

// NewTextWriterStdout returns a new text writer to stdout/stderr.
func NewTextWriterStdout() *TextWriter <span class="cov0" title="0">{
        return NewTextWriter(os.Stdout).WithErrorOutput(os.Stderr)
}</span>

// NewTextWriterFromEnv returns a new text writer from the environment.
func NewTextWriterFromEnv() *TextWriter <span class="cov0" title="0">{
        return NewTextWriterFromConfig(NewTextWriterConfigFromEnv())
}</span>

// NewTextWriterFromConfig creates a new text writer from a given config.
func NewTextWriterFromConfig(cfg *TextWriterConfig) *TextWriter <span class="cov8" title="1">{
        return &amp;TextWriter{
                output:      NewInterlockedWriter(os.Stdout),
                errorOutput: NewInterlockedWriter(os.Stderr),
                bufferPool:  NewBufferPool(DefaultBufferPoolSize),
                showTime:    cfg.GetShowTime(),
                showLabel:   cfg.GetShowLabel(),
                useColor:    cfg.GetUseColor(),
                label:       cfg.GetLabel(),
                timeFormat:  cfg.GetTimeFormat(),
        }
}</span>

// TextWriter handles outputting logging events to given writer streams as textual columns.
type TextWriter struct {
        output      io.Writer
        errorOutput io.Writer

        showTime  bool
        showLabel bool
        useColor  bool

        timeFormat string
        label      string

        bufferPool *BufferPool
}

// OutputFormat returns the output format.
func (wr *TextWriter) OutputFormat() OutputFormat <span class="cov8" title="1">{
        return OutputFormatText
}</span>

// UseColor is a formatting option.
func (wr *TextWriter) UseColor() bool <span class="cov0" title="0">{
        return wr.useColor
}</span>

// WithUseColor sets a formatting option.
func (wr *TextWriter) WithUseColor(useColor bool) *TextWriter <span class="cov8" title="1">{
        wr.useColor = useColor
        return wr
}</span>

// ShowTime is a formatting option.
func (wr *TextWriter) ShowTime() bool <span class="cov0" title="0">{
        return wr.showTime
}</span>

// WithShowTimestamp sets a formatting option.
func (wr *TextWriter) WithShowTimestamp(showTime bool) *TextWriter <span class="cov8" title="1">{
        wr.showTime = showTime
        return wr
}</span>

// ShowLabel is a formatting option.
func (wr *TextWriter) ShowLabel() bool <span class="cov0" title="0">{
        return wr.showLabel
}</span>

// WithShowLabel sets a formatting option.
func (wr *TextWriter) WithShowLabel(showLabel bool) *TextWriter <span class="cov0" title="0">{
        wr.showLabel = showLabel
        return wr
}</span>

// Label is a formatting option.
func (wr *TextWriter) Label() string <span class="cov8" title="1">{
        return wr.label
}</span>

// WithLabel sets a formatting option.
func (wr *TextWriter) WithLabel(label string) Writer <span class="cov0" title="0">{
        wr.label = label
        return wr
}</span>

// TimeFormat is a formatting option.
func (wr *TextWriter) TimeFormat() string <span class="cov0" title="0">{
        return wr.timeFormat
}</span>

// WithTimeFormat sets a formatting option.
func (wr *TextWriter) WithTimeFormat(timeFormat string) *TextWriter <span class="cov0" title="0">{
        wr.timeFormat = timeFormat
        return wr
}</span>

// Output returns the output.
func (wr *TextWriter) Output() io.Writer <span class="cov8" title="1">{
        return wr.output
}</span>

// WithOutput sets the primary output.
func (wr *TextWriter) WithOutput(output io.Writer) *TextWriter <span class="cov0" title="0">{
        wr.output = NewInterlockedWriter(output)
        return wr
}</span>

// ErrorOutput returns an io.Writer for the error stream.
func (wr *TextWriter) ErrorOutput() io.Writer <span class="cov8" title="1">{
        if wr.errorOutput != nil </span><span class="cov8" title="1">{
                return wr.errorOutput
        }</span>
        <span class="cov8" title="1">return wr.output</span>
}

// WithErrorOutput sets the error output.
func (wr *TextWriter) WithErrorOutput(errorOutput io.Writer) *TextWriter <span class="cov8" title="1">{
        wr.errorOutput = NewInterlockedWriter(errorOutput)
        return wr
}</span>

// Colorize (optionally) applies a color to a string.
func (wr *TextWriter) Colorize(value string, color AnsiColor) string <span class="cov8" title="1">{
        if wr.useColor </span><span class="cov8" title="1">{
                return color.Apply(value)
        }</span>
        <span class="cov8" title="1">return value</span>
}

// ColorizeStatusCode adds color to a status code.
func (wr *TextWriter) ColorizeStatusCode(statusCode int) string <span class="cov0" title="0">{
        if wr.useColor </span><span class="cov0" title="0">{
                return ColorizeStatusCode(statusCode)
        }</span>
        <span class="cov0" title="0">return strconv.Itoa(statusCode)</span>
}

// ColorizeByStatusCode colorizes a string by a status code (green, yellow, red).
func (wr *TextWriter) ColorizeByStatusCode(statusCode int, value string) string <span class="cov0" title="0">{
        if wr.useColor </span><span class="cov0" title="0">{
                return ColorizeByStatusCode(statusCode, value)
        }</span>
        <span class="cov0" title="0">return value</span>
}

// FormatFlag formats an event flag.
func (wr *TextWriter) FormatFlag(flag Flag, color AnsiColor) string <span class="cov8" title="1">{
        return fmt.Sprintf("[%s]", wr.Colorize(string(flag), color))
}</span>

// FormatLabel returns the app name.
func (wr *TextWriter) FormatLabel(contents string) string <span class="cov8" title="1">{
        return fmt.Sprintf("[%s]", wr.Colorize(contents, ColorBlue))
}</span>

// FormatTimestamp returns a new timestamp string.
func (wr *TextWriter) FormatTimestamp(optionalTime ...time.Time) string <span class="cov8" title="1">{
        timeFormat := DefaultTextTimeFormat
        if len(wr.timeFormat) &gt; 0 </span><span class="cov8" title="1">{
                timeFormat = wr.timeFormat
        }</span>
        <span class="cov8" title="1">if len(optionalTime) &gt; 0 </span><span class="cov8" title="1">{
                return wr.Colorize(optionalTime[0].Format(timeFormat), ColorGray)
        }</span>
        <span class="cov0" title="0">return wr.Colorize(time.Now().UTC().Format(timeFormat), ColorGray)</span>
}

// GetBuffer returns a leased buffer from the buffer pool.
func (wr *TextWriter) GetBuffer() *bytes.Buffer <span class="cov0" title="0">{
        return wr.bufferPool.Get()
}</span>

// PutBuffer adds the leased buffer back to the pool.
// It Should be called in conjunction with `GetBuffer`.
func (wr *TextWriter) PutBuffer(buffer *bytes.Buffer) <span class="cov0" title="0">{
        wr.bufferPool.Put(buffer)
}</span>

// Write writes to stdout.
func (wr *TextWriter) Write(e Event) error <span class="cov8" title="1">{
        return wr.write(wr.Output(), e)
}</span>

// WriteError writes to stderr (or stdout if .errorOutput is unset).
func (wr *TextWriter) WriteError(e Event) error <span class="cov8" title="1">{
        return wr.write(wr.ErrorOutput(), e)
}</span>

func (wr *TextWriter) write(output io.Writer, e Event) error <span class="cov8" title="1">{
        buf := wr.bufferPool.Get()
        defer wr.bufferPool.Put(buf)

        if wr.showTime </span><span class="cov8" title="1">{
                buf.WriteString(wr.FormatTimestamp(e.Timestamp()))
                buf.WriteRune(RuneSpace)
        }</span>

        <span class="cov8" title="1">if wr.showLabel &amp;&amp; len(wr.label) &gt; 0 </span><span class="cov8" title="1">{
                buf.WriteString(wr.FormatLabel(wr.label))
                buf.WriteRune(RuneSpace)
        }</span>

        <span class="cov8" title="1">if typed, isTyped := e.(EventHeading); isTyped &amp;&amp; len(typed.Heading()) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString(wr.FormatLabel(typed.Heading()))
                buf.WriteRune(RuneSpace)
        }</span>

        <span class="cov8" title="1">if typed, isTyped := e.(FlagTextColorProvider); isTyped </span><span class="cov8" title="1">{
                if flagColor := typed.FlagTextColor(); len(flagColor) &gt; 0 </span><span class="cov0" title="0">{
                        buf.WriteString(wr.FormatFlag(e.Flag(), flagColor))
                }</span> else<span class="cov8" title="1"> {
                        buf.WriteString(wr.FormatFlag(e.Flag(), GetFlagTextColor(e.Flag())))
                }</span>
        } else<span class="cov8" title="1"> {
                buf.WriteString(wr.FormatFlag(e.Flag(), GetFlagTextColor(e.Flag())))
        }</span>
        <span class="cov8" title="1">buf.WriteRune(RuneSpace)

        if typed, isTyped := e.(TextWritable); isTyped </span><span class="cov8" title="1">{
                typed.WriteText(wr, buf)
        }</span> else<span class="cov8" title="1"> if typed, isTyped := e.(fmt.Stringer); isTyped </span><span class="cov8" title="1">{
                buf.WriteString(typed.String())
        }</span>

        <span class="cov8" title="1">if typed, isTyped := e.(EventMeta); isTyped </span><span class="cov8" title="1">{
                if len(typed.Labels()) &gt; 0 </span><span class="cov8" title="1">{
                        buf.WriteRune(RuneNewline)
                        for key, value := range typed.Labels() </span><span class="cov8" title="1">{
                                buf.WriteString(fmt.Sprintf("%s=%s", key, value))
                                buf.WriteRune(RuneSpace)
                        }</span>
                }
        }

        <span class="cov8" title="1">buf.WriteRune(RuneNewline)
        _, err := buf.WriteTo(output)
        return err</span>
}
</pre>
		
		<pre class="file" id="file60" style="display: none">package logger

import "time"

const (
        // NanosecondsPerSecond is the number of nanoseconds in a second.
        NanosecondsPerSecond = time.Second / time.Nanosecond
)

// Seconds returns a duration as seconds.
func Seconds(d time.Duration) float64 <span class="cov8" title="1">{
        return float64(d) / float64(time.Second)
}</span>

// Milliseconds returns a duration as milliseconds.
func Milliseconds(d time.Duration) float64 <span class="cov8" title="1">{
        return float64(d) / float64(time.Millisecond)
}</span>

// Microseconds returns a duration as microseconds.
func Microseconds(d time.Duration) float64 <span class="cov8" title="1">{
        return float64(d) / float64(time.Microsecond)
}</span>

// UnixNano returns both the unix timestamp (in seconds), and the
// nanosecond remainder.
func UnixNano(t time.Time) (int64, int64) <span class="cov8" title="1">{
        unix := t.Unix() //seconds
        unixSecondsAsNanoseconds := int64(time.Duration(unix) * NanosecondsPerSecond)
        nano := t.UnixNano() - unixSecondsAsNanoseconds
        return unix, nano
}</span>

// SumOfDuration adds all the values of a slice together
func SumOfDuration(values []time.Duration) time.Duration <span class="cov0" title="0">{
        total := time.Duration(0)
        for x := 0; x &lt; len(values); x++ </span><span class="cov0" title="0">{
                total += values[x]
        }</span>

        <span class="cov0" title="0">return total</span>
}

// MeanOfDuration gets the average of a slice of numbers
func MeanOfDuration(input []time.Duration) time.Duration <span class="cov0" title="0">{
        if len(input) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">sum := SumOfDuration(input)
        mean := uint64(sum) / uint64(len(input))
        return time.Duration(mean)</span>
}
</pre>
		
		<pre class="file" id="file61" style="display: none">package logger

import (
        "bytes"
        "fmt"
        "time"
)

// Timedf returns a timed message event.
func Timedf(flag Flag, elapsed time.Duration, format string, args ...Any) *TimedEvent <span class="cov8" title="1">{
        return &amp;TimedEvent{
                flag:    flag,
                ts:      time.Now().UTC(),
                message: fmt.Sprintf(format, args...),
                elapsed: elapsed,
        }
}</span>

// NewTimedEventListener returns a new timed event listener.
func NewTimedEventListener(listener func(e *TimedEvent)) Listener <span class="cov8" title="1">{
        return func(e Event) </span><span class="cov8" title="1">{
                if typed, isTyped := e.(*TimedEvent); isTyped </span><span class="cov8" title="1">{
                        listener(typed)
                }</span>
        }
}

// TimedEvent is a message event with an elapsed time.
type TimedEvent struct {
        heading string
        flag    Flag
        ts      time.Time
        message string
        elapsed time.Duration

        labels      map[string]string
        annotations map[string]string
}

// WithLabel sets a label on the event for later filtering.
func (e *TimedEvent) WithLabel(key, value string) *TimedEvent <span class="cov8" title="1">{
        if e.labels == nil </span><span class="cov8" title="1">{
                e.labels = map[string]string{}
        }</span>
        <span class="cov8" title="1">e.labels[key] = value
        return e</span>
}

// Labels returns a labels collection.
func (e *TimedEvent) Labels() map[string]string <span class="cov8" title="1">{
        return e.labels
}</span>

// WithAnnotation adds an annotation to the event.
func (e *TimedEvent) WithAnnotation(key, value string) *TimedEvent <span class="cov0" title="0">{
        if e.annotations == nil </span><span class="cov0" title="0">{
                e.annotations = map[string]string{}
        }</span>
        <span class="cov0" title="0">e.annotations[key] = value
        return e</span>
}

// Annotations returns the annotations set.
func (e *TimedEvent) Annotations() map[string]string <span class="cov0" title="0">{
        return e.annotations
}</span>

// WithFlag sets the timed message flag.
func (e *TimedEvent) WithFlag(flag Flag) *TimedEvent <span class="cov0" title="0">{
        e.flag = flag
        return e
}</span>

// Flag returns the timed message flag.
func (e TimedEvent) Flag() Flag <span class="cov8" title="1">{
        return e.flag
}</span>

// WithTimestamp sets the message timestamp.
func (e *TimedEvent) WithTimestamp(ts time.Time) *TimedEvent <span class="cov0" title="0">{
        e.ts = ts
        return e
}</span>

// Timestamp returns the timed message timestamp.
func (e TimedEvent) Timestamp() time.Time <span class="cov8" title="1">{
        return e.ts
}</span>

// WithMessage sets the message.
func (e *TimedEvent) WithMessage(message string) *TimedEvent <span class="cov0" title="0">{
        e.message = message
        return e
}</span>

// Message returns the string message.
func (e TimedEvent) Message() string <span class="cov8" title="1">{
        return e.message
}</span>

// WithHeading sets the event heading.
func (e *TimedEvent) WithHeading(heading string) *TimedEvent <span class="cov8" title="1">{
        e.heading = heading
        return e
}</span>

// Heading returns the event heading.
func (e *TimedEvent) Heading() string <span class="cov8" title="1">{
        return e.heading
}</span>

// WithElapsed sets the elapsed time.
func (e *TimedEvent) WithElapsed(elapsed time.Duration) *TimedEvent <span class="cov0" title="0">{
        e.elapsed = elapsed
        return e
}</span>

// Elapsed returns the elapsed time.
func (e TimedEvent) Elapsed() time.Duration <span class="cov8" title="1">{
        return e.elapsed
}</span>

// String implements fmt.Stringer
func (e TimedEvent) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s (%v)", e.message, e.elapsed)
}</span>

// WriteText implements TextWritable.
func (e TimedEvent) WriteText(tf TextFormatter, buf *bytes.Buffer) <span class="cov0" title="0">{
        buf.WriteString(e.String())
}</span>

// WriteJSON implements JSONWritable.
func (e TimedEvent) WriteJSON() JSONObj <span class="cov0" title="0">{
        return JSONObj{
                JSONFieldMessage: e.message,
                JSONFieldElapsed: Milliseconds(e.elapsed),
        }
}</span>
</pre>
		
		<pre class="file" id="file62" style="display: none">package logger

import (
        "crypto/rand"
        "fmt"
        "net"
        "net/http"
        "strconv"
        "strings"
)

const (
        // Gigabyte is an SI unit.
        Gigabyte = 1 &lt;&lt; 30
        // Megabyte is an SI unit.
        Megabyte = 1 &lt;&lt; 20
        // Kilobyte is an SI unit.
        Kilobyte = 1 &lt;&lt; 10
)

// Any is a helper alias to interface{}
type Any = interface{}

// GetIP gets the origin/client ip for a request.
// X-FORWARDED-FOR is checked. If multiple IPs are included the first one is returned
// X-REAL-IP is checked. If multiple IPs are included the first one is returned
// Finally r.RemoteAddr is used
// Only benevolent services will allow access to the real IP.
func GetIP(r *http.Request) string <span class="cov8" title="1">{
        if r == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">tryHeader := func(key string) (string, bool) </span><span class="cov8" title="1">{
                if headerVal := r.Header.Get(key); len(headerVal) &gt; 0 </span><span class="cov8" title="1">{
                        if !strings.ContainsRune(headerVal, ',') </span><span class="cov8" title="1">{
                                return headerVal, true
                        }</span>
                        <span class="cov8" title="1">return strings.SplitN(headerVal, ",", 2)[0], true</span>
                }
                <span class="cov8" title="1">return "", false</span>
        }

        <span class="cov8" title="1">for _, header := range []string{"X-FORWARDED-FOR", "X-REAL-IP"} </span><span class="cov8" title="1">{
                if headerVal, ok := tryHeader(header); ok </span><span class="cov8" title="1">{
                        return headerVal
                }</span>
        }

        <span class="cov8" title="1">ip, _, _ := net.SplitHostPort(r.RemoteAddr)
        return ip</span>
}

// UUIDv4 returns a v4 uuid short string.
func UUIDv4() string <span class="cov0" title="0">{
        uuid := make([]byte, 16)
        rand.Read(uuid)
        uuid[6] = (uuid[6] &amp; 0x0f) | 0x40 // set version 4
        uuid[8] = (uuid[8] &amp; 0x3f) | 0x80 // set variant 10
        return fmt.Sprintf("%x", uuid[:])
}</span>

// ColorizeByStatusCode returns a value colored by an http status code.
func ColorizeByStatusCode(statusCode int, value string) string <span class="cov0" title="0">{
        if statusCode &gt;= http.StatusOK &amp;&amp; statusCode &lt; 300 </span><span class="cov0" title="0">{ //the http 2xx range is ok
                return ColorGreen.Apply(value)
        }</span> else<span class="cov0" title="0"> if statusCode == http.StatusInternalServerError </span><span class="cov0" title="0">{
                return ColorRed.Apply(value)
        }</span>
        <span class="cov0" title="0">return ColorYellow.Apply(value)</span>
}

// ColorizeStatusCode colorizes a status code.
func ColorizeStatusCode(statusCode int) string <span class="cov0" title="0">{
        return ColorizeByStatusCode(statusCode, strconv.Itoa(statusCode))
}</span>

// ParseFileSize returns a filesize.
func ParseFileSize(fileSizeValue string) (int64, error) <span class="cov0" title="0">{
        if len(fileSizeValue) == 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("empty filesize value")
        }</span>

        <span class="cov0" title="0">units := strings.ToLower(fileSizeValue[len(fileSizeValue)-2:])
        value, err := strconv.ParseInt(fileSizeValue[:len(fileSizeValue)-2], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">switch units </span>{
        case "gb":<span class="cov0" title="0">
                return value * Gigabyte, nil</span>
        case "mb":<span class="cov0" title="0">
                return value * Megabyte, nil</span>
        case "kb":<span class="cov0" title="0">
                return value * Kilobyte, nil</span>
        }
        <span class="cov0" title="0">fullValue, err := strconv.ParseInt(fileSizeValue, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return fullValue, nil</span>
}

// FormatFileSize returns a string representation of a file size in bytes.
func FormatFileSize(sizeBytes int64) string <span class="cov0" title="0">{
        if sizeBytes &gt;= 1&lt;&lt;30 </span><span class="cov0" title="0">{
                return strconv.FormatInt(sizeBytes/Gigabyte, 10) + "gb"
        }</span> else<span class="cov0" title="0"> if sizeBytes &gt;= 1&lt;&lt;20 </span><span class="cov0" title="0">{
                return strconv.FormatInt(sizeBytes/Megabyte, 10) + "mb"
        }</span> else<span class="cov0" title="0"> if sizeBytes &gt;= 1&lt;&lt;10 </span><span class="cov0" title="0">{
                return strconv.FormatInt(sizeBytes/Kilobyte, 10) + "kb"
        }</span>
        <span class="cov0" title="0">return strconv.FormatInt(sizeBytes, 10)</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">package logger

import (
        "bytes"
        "net/http"
        "time"
)

// NewWebRequestEvent creates a new web request event.
func NewWebRequestEvent(req *http.Request) *WebRequestEvent <span class="cov8" title="1">{
        return &amp;WebRequestEvent{
                flag: WebRequest,
                ts:   time.Now().UTC(),
                req:  req,
        }
}</span>

// NewWebRequestStartEvent creates a new web request start event.
func NewWebRequestStartEvent(req *http.Request) *WebRequestEvent <span class="cov0" title="0">{
        return &amp;WebRequestEvent{
                flag: WebRequestStart,
                ts:   time.Now().UTC(),
                req:  req,
        }
}</span>

// NewWebRequestEventListener returns a new web request event listener.
func NewWebRequestEventListener(listener func(*WebRequestEvent)) Listener <span class="cov8" title="1">{
        return func(e Event) </span><span class="cov8" title="1">{
                if typed, isTyped := e.(*WebRequestEvent); isTyped </span><span class="cov8" title="1">{
                        listener(typed)
                }</span>
        }
}

// WebRequestEvent is an event type for http responses.
type WebRequestEvent struct {
        heading string
        flag    Flag
        ts      time.Time
        req     *http.Request

        route           string
        statusCode      int
        contentLength   int64
        contentType     string
        contentEncoding string
        elapsed         time.Duration
        state           map[string]interface{}

        labels      map[string]string
        annotations map[string]string
}

// WithLabel sets a label on the event for later filtering.
func (e *WebRequestEvent) WithLabel(key, value string) *WebRequestEvent <span class="cov8" title="1">{
        if e.labels == nil </span><span class="cov8" title="1">{
                e.labels = map[string]string{}
        }</span>
        <span class="cov8" title="1">e.labels[key] = value
        return e</span>
}

// Labels returns a labels collection.
func (e *WebRequestEvent) Labels() map[string]string <span class="cov8" title="1">{
        return e.labels
}</span>

// WithAnnotation adds an annotation to the event.
func (e *WebRequestEvent) WithAnnotation(key, value string) *WebRequestEvent <span class="cov0" title="0">{
        if e.annotations == nil </span><span class="cov0" title="0">{
                e.annotations = map[string]string{}
        }</span>
        <span class="cov0" title="0">e.annotations[key] = value
        return e</span>
}

// Annotations returns the annotations set.
func (e *WebRequestEvent) Annotations() map[string]string <span class="cov0" title="0">{
        return e.annotations
}</span>

// WithFlag sets the event flag.
func (e *WebRequestEvent) WithFlag(flag Flag) *WebRequestEvent <span class="cov0" title="0">{
        e.flag = flag
        return e
}</span>

// Flag returns the event flag.
func (e *WebRequestEvent) Flag() Flag <span class="cov8" title="1">{
        return e.flag
}</span>

// WithTimestamp sets the timestamp.
func (e *WebRequestEvent) WithTimestamp(ts time.Time) *WebRequestEvent <span class="cov0" title="0">{
        e.ts = ts
        return e
}</span>

// Timestamp returns the event timestamp.
func (e *WebRequestEvent) Timestamp() time.Time <span class="cov8" title="1">{
        return e.ts
}</span>

// WithHeading sets the event heading.
func (e *WebRequestEvent) WithHeading(heading string) *WebRequestEvent <span class="cov8" title="1">{
        e.heading = heading
        return e
}</span>

// Heading returns the event heading.
func (e *WebRequestEvent) Heading() string <span class="cov8" title="1">{
        return e.heading
}</span>

// WithRequest sets the request metadata.
func (e *WebRequestEvent) WithRequest(req *http.Request) *WebRequestEvent <span class="cov0" title="0">{
        e.req = req
        return e
}</span>

// Request returns the request metadata.
func (e *WebRequestEvent) Request() *http.Request <span class="cov8" title="1">{
        return e.req
}</span>

// WithStatusCode sets the status code.
func (e *WebRequestEvent) WithStatusCode(statusCode int) *WebRequestEvent <span class="cov0" title="0">{
        e.statusCode = statusCode
        return e
}</span>

// StatusCode is the HTTP status code of the response.
func (e *WebRequestEvent) StatusCode() int <span class="cov0" title="0">{
        return e.statusCode
}</span>

// WithContentLength sets the content length.
func (e *WebRequestEvent) WithContentLength(contentLength int64) *WebRequestEvent <span class="cov0" title="0">{
        e.contentLength = contentLength
        return e
}</span>

// ContentLength is the size of the response.
func (e *WebRequestEvent) ContentLength() int64 <span class="cov0" title="0">{
        return e.contentLength
}</span>

// WithContentType sets the content type.
func (e *WebRequestEvent) WithContentType(contentType string) *WebRequestEvent <span class="cov0" title="0">{
        e.contentType = contentType
        return e
}</span>

// ContentType is the type of the response.
func (e *WebRequestEvent) ContentType() string <span class="cov0" title="0">{
        return e.contentType
}</span>

// WithContentEncoding sets the content encoding.
func (e *WebRequestEvent) WithContentEncoding(contentEncoding string) *WebRequestEvent <span class="cov0" title="0">{
        e.contentEncoding = contentEncoding
        return e
}</span>

// ContentEncoding is the encoding of the response.
func (e *WebRequestEvent) ContentEncoding() string <span class="cov0" title="0">{
        return e.contentEncoding
}</span>

// WithRoute sets the mux route.
func (e *WebRequestEvent) WithRoute(route string) *WebRequestEvent <span class="cov0" title="0">{
        e.route = route
        return e
}</span>

// Route is the mux route of the request.
func (e *WebRequestEvent) Route() string <span class="cov0" title="0">{
        return e.route
}</span>

// WithElapsed sets the elapsed time.
func (e *WebRequestEvent) WithElapsed(elapsed time.Duration) *WebRequestEvent <span class="cov8" title="1">{
        e.elapsed = elapsed
        return e
}</span>

// Elapsed is the duration of the request.
func (e *WebRequestEvent) Elapsed() time.Duration <span class="cov8" title="1">{
        return e.elapsed
}</span>

// WithState sets the request state.
func (e *WebRequestEvent) WithState(state map[string]interface{}) *WebRequestEvent <span class="cov0" title="0">{
        e.state = state
        return e
}</span>

// State returns the state of the request.
func (e *WebRequestEvent) State() time.Duration <span class="cov0" title="0">{
        return e.elapsed
}</span>

// WriteText implements TextWritable.
func (e *WebRequestEvent) WriteText(formatter TextFormatter, buf *bytes.Buffer) <span class="cov0" title="0">{
        if e.flag == WebRequestStart </span><span class="cov0" title="0">{
                TextWriteRequestStart(formatter, buf, e.req)
        }</span> else<span class="cov0" title="0"> {
                TextWriteRequest(formatter, buf, e.req, e.statusCode, e.contentLength, e.contentType, e.elapsed)
        }</span>
}

// WriteJSON implements JSONWritable.
func (e *WebRequestEvent) WriteJSON() JSONObj <span class="cov0" title="0">{
        if e.flag == WebRequestStart </span><span class="cov0" title="0">{
                return JSONWriteRequestStart(e.req)
        }</span>
        <span class="cov0" title="0">return JSONWriteRequest(e.req, e.statusCode, e.contentLength, e.contentType, e.contentEncoding, e.elapsed)</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">package logger

import (
        "sync"
)

const (
        // DefaultWorkerQueueDepth is the default depth per listener to queue work.
        DefaultWorkerQueueDepth = 1 &lt;&lt; 20
)

// NewWorker returns a new worker.
func NewWorker(parent *Logger, listener Listener) *Worker <span class="cov8" title="1">{
        return &amp;Worker{
                Parent:        parent,
                Listener:      listener,
                Work:          make(chan Event, DefaultWorkerQueueDepth),
                Abort:         make(chan bool),
                Aborted:       make(chan bool),
                RecoverPanics: true,
        }
}</span>

// Worker is an agent that processes a listener.
type Worker struct {
        Parent        *Logger
        Listener      Listener
        Abort         chan bool
        Aborted       chan bool
        Drained       chan bool
        Work          chan Event
        SyncRoot      sync.Mutex
        RecoverPanics bool
}

// WithRecoverPanics sets the recover panics field.
func (w *Worker) WithRecoverPanics(value bool) *Worker <span class="cov8" title="1">{
        w.RecoverPanics = value
        return w
}</span>

// Start starts the worker.
func (w *Worker) Start() <span class="cov8" title="1">{
        go w.ProcessLoop()
}</span>

// ProcessLoop is the for/select loop.
func (w *Worker) ProcessLoop() <span class="cov8" title="1">{
        var e Event
        for </span><span class="cov8" title="1">{
                select </span>{
                case e = &lt;-w.Work:<span class="cov8" title="1">
                        w.Process(e)</span>
                case &lt;-w.Abort:<span class="cov8" title="1">
                        w.Aborted &lt;- true
                        return</span>
                }
        }
}

// Process calls the listener for an event.
func (w *Worker) Process(e Event) <span class="cov8" title="1">{
        if w.RecoverPanics </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if r := recover(); r != nil </span><span class="cov8" title="1">{
                                if w.Parent != nil </span><span class="cov8" title="1">{
                                        w.Parent.SyncFatalf("%v", r)
                                }</span>
                        }
                }()
        }
        <span class="cov8" title="1">w.Listener(e)</span>
}

// Stop stops the worker.
func (w *Worker) Stop() <span class="cov8" title="1">{
        w.Abort &lt;- true
        &lt;-w.Aborted
}</span>

// Drain stops the worker and synchronously processes any remaining work.
// It then restarts the worker.
func (w *Worker) Drain() <span class="cov8" title="1">{
        w.SyncRoot.Lock()
        defer w.SyncRoot.Unlock()

        w.Stop()
        for len(w.Work) &gt; 0 </span><span class="cov8" title="1">{
                w.Process(&lt;-w.Work)
        }</span>
        <span class="cov8" title="1">w.Start()</span>
}

// Close closes the worker.
func (w *Worker) Close() error <span class="cov8" title="1">{
        w.SyncRoot.Lock()
        defer w.SyncRoot.Unlock()

        w.Stop()

        close(w.Work)
        close(w.Abort)
        close(w.Aborted)

        return nil
}</span>
</pre>
		
		<pre class="file" id="file65" style="display: none">package logger

import (
        "bytes"
        "net/http"
        "strconv"
        "time"
)

// TextWriteRequestStart is a helper method to write request start events to a writer.
func TextWriteRequestStart(tf TextFormatter, buf *bytes.Buffer, req *http.Request) <span class="cov0" title="0">{
        buf.WriteString(GetIP(req))
        buf.WriteRune(RuneSpace)
        buf.WriteString(tf.Colorize(req.Method, ColorBlue))
        buf.WriteRune(RuneSpace)
        buf.WriteString(req.URL.Path)
}</span>

// TextWriteRequest is a helper method to write request complete events to a writer.
func TextWriteRequest(tf TextFormatter, buf *bytes.Buffer, req *http.Request, statusCode int, contentLength int64, contentType string, elapsed time.Duration) <span class="cov0" title="0">{
        buf.WriteString(GetIP(req))
        buf.WriteRune(RuneSpace)
        buf.WriteString(tf.Colorize(req.Method, ColorBlue))
        buf.WriteRune(RuneSpace)
        buf.WriteString(req.URL.Path)
        buf.WriteRune(RuneSpace)
        buf.WriteString(tf.ColorizeByStatusCode(statusCode, strconv.Itoa(statusCode)))
        buf.WriteRune(RuneSpace)
        buf.WriteString(elapsed.String())
        buf.WriteRune(RuneSpace)
        buf.WriteString(contentType)
        buf.WriteRune(RuneSpace)
        buf.WriteString(FormatFileSize(contentLength))
}</span>

// JSONWriteRequestStart marshals a request start as json.
func JSONWriteRequestStart(req *http.Request) JSONObj <span class="cov0" title="0">{
        return JSONObj{
                "ip":   GetIP(req),
                "verb": req.Method,
                "path": req.URL.Path,
                "host": req.Host,
        }
}</span>

// JSONWriteRequest marshals a request as json.
func JSONWriteRequest(req *http.Request, statusCode int, contentLength int64, contentType, contentEncoding string, elapsed time.Duration) JSONObj <span class="cov0" title="0">{
        return JSONObj{
                "ip":              GetIP(req),
                "verb":            req.Method,
                "path":            req.URL.Path,
                "host":            req.Host,
                "contentLength":   contentLength,
                "contentType":     contentType,
                "contentEncoding": contentEncoding,
                "statusCode":      statusCode,
                JSONFieldElapsed:  Milliseconds(elapsed),
        }
}</span>
</pre>
		
		<pre class="file" id="file66" style="display: none">package logger

import (
        "io"
        "strings"

        "github.com/blend/go-sdk/env"
)

// OutputFormat is a writer output format.
type OutputFormat string

const (
        // OutputFormatJSON is an output format.
        OutputFormatJSON OutputFormat = "json"
        // OutputFormatText is an output format.
        OutputFormatText OutputFormat = "text"
        // Sometime in the future ...
        // OutputFormatProtobuf = "protobuf"
)

// Writer is a type that can consume events.
type Writer interface {
        Label() string
        WithLabel(string) Writer
        Write(Event) error
        WriteError(Event) error
        Output() io.Writer
        ErrorOutput() io.Writer
        OutputFormat() OutputFormat
}

// NewWriter creates a new writer based on a given format.
// It reads the writer settings from the environment.
func NewWriter(format OutputFormat) Writer <span class="cov0" title="0">{
        switch OutputFormat(strings.ToLower(string(format))) </span>{
        case OutputFormatJSON:<span class="cov0" title="0">
                return NewJSONWriterFromEnv()</span>
        case OutputFormatText:<span class="cov0" title="0">
                return NewTextWriterFromEnv()</span>
        }

        <span class="cov0" title="0">panic("invalid writer output format")</span>
}

// NewWriterFromEnv returns a new writer based on the environment variable `LOG_FORMAT`.
func NewWriterFromEnv() Writer <span class="cov0" title="0">{
        if format := env.Env().String(EnvVarFormat); len(format) &gt; 0 </span><span class="cov0" title="0">{
                return NewWriter(OutputFormat(format))
        }</span>
        <span class="cov0" title="0">return NewTextWriterFromEnv()</span>
}
</pre>
		
		<pre class="file" id="file67" style="display: none">package oauth

import (
        "time"

        "github.com/blend/go-sdk/env"
        "github.com/blend/go-sdk/util"
)

const (
        // DefaultNonceTimeout is the default timeout before nonces are no longer honored.
        DefaultNonceTimeout = 3 * time.Hour
)

// NewConfigFromEnv creates a new config from the environment.
func NewConfigFromEnv() *Config <span class="cov8" title="1">{
        var cfg Config
        err := env.Env().ReadInto(&amp;cfg)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return &amp;cfg</span>
}

// Config is the config options.
type Config struct {
        // Secret is a base64 encoded secret
        // It is used when hashing nonces and other cryptographic functions.
        // If unset, a secret will be generated for the manager.
        Secret string `json:"secret" yaml:"secret" env:"GOOGLE_SECRET"`

        SkipDomainValidation bool     `json:"skipDomainValidation" yaml:"skipDomainValidation" env:"GOOGLE_SKIP_DOMAIN_VALIDATION"`
        RedirectURI          string   `json:"redirectURI" yaml:"redirectURI" env:"GOOGLE_REDIRECT_URI"`
        ValidDomains         []string `json:"validDomains" yaml:"validDomains" env:"GOOGLE_VALID_DOMAINS,csv"`
        HostedDomain         string   `json:"hostedDomain" yaml:"hostedDomain" env:"GOOGLE_HOSTED_DOMAIN"`

        ClientID     string `json:"clientID" yaml:"clientID" env:"GOOGLE_CLIENT_ID"`
        ClientSecret string `json:"clientSecret" yaml:"clientSecret" env:"GOOGLE_CLIENT_SECRET"`

        NonceTimeout time.Duration `json:"nonceTimeout" yaml:"nonceTimeout" env:"GOOGLE_NONCE_TIMEOUT"`
}

// IsZero returns if the config is set or not.
func (c Config) IsZero() bool <span class="cov8" title="1">{
        return len(c.ClientID) == 0 || len(c.ClientSecret) == 0
}</span>

// GetSecret gets the secret if set or a default.
func (c Config) GetSecret(defaults ...[]byte) ([]byte, error) <span class="cov8" title="1">{
        if len(c.Secret) &gt; 0 </span><span class="cov8" title="1">{
                decoded, err := Base64Decode(c.Secret)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return decoded, nil</span>
        }
        <span class="cov8" title="1">if len(defaults) &gt; 0 </span><span class="cov0" title="0">{
                return defaults[0], nil
        }</span>
        <span class="cov8" title="1">return nil, nil</span>
}

// GetSkipDomainValidation returns if we should skip domain validation.
func (c Config) GetSkipDomainValidation() bool <span class="cov8" title="1">{
        return c.SkipDomainValidation
}</span>

// GetRedirectURI returns a property or a default.
func (c Config) GetRedirectURI(inherited ...string) string <span class="cov8" title="1">{
        return util.Coalesce.String(c.RedirectURI, "", inherited...)
}</span>

// GetValidDomains returns a property or a default.
func (c Config) GetValidDomains(inherited ...[]string) []string <span class="cov8" title="1">{
        return util.Coalesce.Strings(c.ValidDomains, nil, inherited...)
}</span>

// GetHostedDomain returns a property or a default.
func (c Config) GetHostedDomain(inherited ...string) string <span class="cov8" title="1">{
        return util.Coalesce.String(c.HostedDomain, "", inherited...)
}</span>

// GetClientID returns a property or a default.
func (c Config) GetClientID(inherited ...string) string <span class="cov8" title="1">{
        return util.Coalesce.String(c.ClientID, "", inherited...)
}</span>

// GetClientSecret returns a property or a default.
func (c Config) GetClientSecret(inherited ...string) string <span class="cov8" title="1">{
        return util.Coalesce.String(c.ClientSecret, "", inherited...)
}</span>

// GetNonceTimeout returns the nonce timeout or a default.
func (c Config) GetNonceTimeout(inherited ...time.Duration) time.Duration <span class="cov8" title="1">{
        return util.Coalesce.Duration(c.NonceTimeout, DefaultNonceTimeout, inherited...)
}</span>
</pre>
		
		<pre class="file" id="file68" style="display: none">package oauth

const (
        // ErrCodeMissing is returned if the code was missing from an oauth return request.
        ErrCodeMissing Error = "state missing from request"
        // ErrStateMissing is returned if the state was missing from an oauth return request.
        ErrStateMissing Error = "state missing from request"
        // ErrNoValidDomains is an error that occurs during profile validation if the manager
        // doesn't have any valid domains configured.
        ErrNoValidDomains Error = "domain validation enabled and no valid domains provided"
        // ErrInvalidEmailDomain is an error that occurs during profile validation if the
        // profile email doesn't match the valid domain list.
        ErrInvalidEmailDomain Error = "domain validation failed; doesn't match valid domain list"
        // ErrInvalidHostedDomain is an error returned if the JWT hosted zone doesn't match any of the whitelisted domains.
        ErrInvalidHostedDomain Error = "hosted domain validation failed"
        // ErrInvalidAUD is an error returned during jwt validation.
        ErrInvalidAUD Error = "invalid JWT AUD"

        // ErrInvalidAntiforgeryToken is an error that occurs during oauth finish if the forgery token is required
        // and missing or invalid.
        ErrInvalidAntiforgeryToken Error = "invalid anti-forgery token"
        // ErrGoogleResponseStatus is an error that can occur when querying the google apis.
        ErrGoogleResponseStatus Error = "google returned a non 2xx response"

        // ErrSecretRequired is a configuration error indicating we did not provide a secret.
        ErrSecretRequired Error = "manager secret required"
        // ErrClientIDRequired is a self validation error.
        ErrClientIDRequired Error = "clientID is required"
        // ErrClientSecretRequired is a self validation error.
        ErrClientSecretRequired Error = "clientSecret is required"
        // ErrRedirectURIRequired is a self validation error.
        ErrRedirectURIRequired Error = "redirectURI is required"
        // ErrInvalidRedirectURI is an error in validating the redirect uri.
        ErrInvalidRedirectURI Error = "invalid redirectURI"
        // ErrInvalidJWT is an error that occurs when deserializing the jwt.
        ErrInvalidJWT Error = "invalid jwt"
        // ErrInvalidNonce is an error that occurs when checking the jwt nonce.
        ErrInvalidNonce Error = "invalid nonce"
)

// Error is an error string.
type Error string

// Error implements error.
func (e Error) Error() string <span class="cov0" title="0">{
        return string(e)
}</span>
</pre>
		
		<pre class="file" id="file69" style="display: none">package oauth

import (
        "encoding/base64"
        "encoding/json"
        "fmt"
        "strings"

        "github.com/blend/go-sdk/exception"
        "github.com/blend/go-sdk/util"
)

const (
        // TypeJWT is a field value in the jwt header.
        TypeJWT = "jwt"

        // AlgorithmHS512 is a hashing algorithm.
        AlgorithmHS512 = "HS512"
)

// DeserializeJWT deserializes a jwt token.
func DeserializeJWT(corpus string) (*JWT, error) <span class="cov8" title="1">{
        parts := strings.Split(corpus, ".")
        if len(parts) &lt; 3 </span><span class="cov0" title="0">{
                return nil, ErrInvalidJWT
        }</span>

        <span class="cov8" title="1">headerContents, err := decodeJWTSegment(parts[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>
        <span class="cov8" title="1">var header JWTHeader
        if err = json.Unmarshal(headerContents, &amp;header); err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>

        <span class="cov8" title="1">payloadContents, err := decodeJWTSegment(parts[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>
        <span class="cov8" title="1">var payload JWTPayload
        if err = json.Unmarshal(payloadContents, &amp;payload); err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>

        <span class="cov8" title="1">signature, err := decodeJWTSegment(parts[2])
        if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>

        <span class="cov8" title="1">return &amp;JWT{
                Header:    header,
                Payload:   payload,
                Signature: signature,
        }, nil</span>
}

// SerializeJWT serializes a jwt.
func SerializeJWT(key []byte, token *JWTPayload) (string, error) <span class="cov8" title="1">{
        headerSerialized, err := json.Marshal(JWTHeader{
                Algorithm: AlgorithmHS512,
                Type:      TypeJWT,
        })
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">header := encodeJWTSegment(headerSerialized)

        payloadSerialized, err := json.Marshal(token)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">payload := encodeJWTSegment(payloadSerialized)

        signatureSerialized := util.Crypto.Hash(key, []byte(header+payload))
        signature := encodeJWTSegment(signatureSerialized)

        return fmt.Sprintf("%s.%s.%s",
                header,
                payload,
                signature,
        ), nil</span>
}

func encodeJWTSegment(corpus []byte) string <span class="cov8" title="1">{
        return base64.URLEncoding.EncodeToString(corpus)
}</span>

func decodeJWTSegment(corpus string) ([]byte, error) <span class="cov8" title="1">{
        if l := len(corpus) % 4; l &gt; 0 </span><span class="cov0" title="0">{
                corpus += strings.Repeat("=", 4-l)
        }</span>
        // note this *has* to be url encoding because that's in the
        // jwt spec.
        <span class="cov8" title="1">contents, err := base64.URLEncoding.DecodeString(corpus)
        if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>
        <span class="cov8" title="1">return contents, nil</span>
}

// JWT is a full jwt.
type JWT struct {
        Header    JWTHeader
        Payload   JWTPayload
        Signature []byte
}

// JWTHeader is the header of a jwt.
type JWTHeader struct {
        Algorithm string `json:"alg"`
        Type      string `json:"typ"`
}

// JWTPayload is the oauth JWT token.
type JWTPayload struct {
        ISS           string  `json:"iss"`
        ATHash        string  `json:"at_hash"`
        EmailVerified bool    `json:"email_verified"`
        Sub           string  `json:"sub"` //actual user identifier
        AZP           string  `json:"azp"`
        Email         string  `json:"email"`
        AUD           string  `json:"aud"`
        IAT           float64 `json:"iat"`
        EXP           float64 `json:"exp"`
        Nonce         string  `json:"nonce"`
        HostedDomain  string  `json:"hd"`
}
</pre>
		
		<pre class="file" id="file70" style="display: none">package oauth

import (
        "crypto/hmac"
        "fmt"
        "net/http"
        "net/url"
        "strings"
        "time"

        "github.com/blend/go-sdk/exception"
        "github.com/blend/go-sdk/request"
        "github.com/blend/go-sdk/util"
        "github.com/blend/go-sdk/uuid"
)

// New returns a new manager.
// By default it will error if you try and validate a profile.
// You must either enable `SkipDomainvalidation` or provide valid domains.
func New() *Manager <span class="cov8" title="1">{
        return &amp;Manager{
                secret:       util.Crypto.MustCreateKey(32),
                nonceTimeout: DefaultNonceTimeout,
        }
}</span>

// NewFromEnv returns a new manager from the environment.
func NewFromEnv() (*Manager, error) <span class="cov0" title="0">{
        return NewFromConfig(NewConfigFromEnv())
}</span>

// NewFromConfig returns a new oauth manager from a config.
func NewFromConfig(cfg *Config) (*Manager, error) <span class="cov8" title="1">{
        secret, err := cfg.GetSecret()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(secret) == 0 </span><span class="cov8" title="1">{
                secret = util.Crypto.MustCreateKey(32)
        }</span>
        <span class="cov8" title="1">return &amp;Manager{
                secret:               secret,
                skipDomainValidation: cfg.GetSkipDomainValidation(),
                redirectURI:          cfg.GetRedirectURI(),
                validDomains:         cfg.GetValidDomains(),
                clientID:             cfg.GetClientID(),
                clientSecret:         cfg.GetClientSecret(),
                hostedDomain:         cfg.GetHostedDomain(),
                nonceTimeout:         cfg.GetNonceTimeout(),
        }, nil</span>
}

// Manager is the oauth manager.
type Manager struct {
        secret               []byte
        audience             string
        redirectURI          string
        skipDomainValidation bool
        hostedDomain         string
        validDomains         []string
        clientID             string
        clientSecret         string
        nonceTimeout         time.Duration
}

// WithSecret sets the secret used to create state tokens.
func (m *Manager) WithSecret(secret []byte) *Manager <span class="cov8" title="1">{
        m.secret = secret
        return m
}</span>

// Secret returns a property
func (m *Manager) Secret() []byte <span class="cov8" title="1">{
        return m.secret
}</span>

// WithRedirectURI sets the return url.
func (m *Manager) WithRedirectURI(redirectURI string) *Manager <span class="cov8" title="1">{
        m.redirectURI = redirectURI
        return m
}</span>

// RedirectURI returns a property.
func (m *Manager) RedirectURI() string <span class="cov8" title="1">{
        return m.redirectURI
}</span>

// WithSkipDomainValidation sets if we should skip domain validation.
// It defaults to false, meaning we must supply valid domains.
func (m *Manager) WithSkipDomainValidation(value bool) *Manager <span class="cov8" title="1">{
        m.skipDomainValidation = value
        return m
}</span>

// SkipDomainValidation returns a property.
func (m *Manager) SkipDomainValidation() bool <span class="cov0" title="0">{
        return m.skipDomainValidation
}</span>

// WithHostedDomain returns the hosted domain.
func (m *Manager) WithHostedDomain(hostedDomain string) *Manager <span class="cov8" title="1">{
        m.hostedDomain = hostedDomain
        return m
}</span>

// HostedDomain returns the hosted domain.
func (m *Manager) HostedDomain() string <span class="cov0" title="0">{
        return m.hostedDomain
}</span>

// WithValidDomains sets the valid domains.
// If values are not prefixed with `@`, they will be prefixed when testing email domains.
func (m *Manager) WithValidDomains(validDomains ...string) *Manager <span class="cov8" title="1">{
        m.validDomains = validDomains
        return m
}</span>

// ValidDomains returns all valid domains. This includes the hosted domain in configured.
func (m *Manager) ValidDomains() []string <span class="cov8" title="1">{
        all := map[string]bool{}
        for _, domain := range m.validDomains </span><span class="cov8" title="1">{
                all[domain] = true
        }</span>
        <span class="cov8" title="1">if len(m.hostedDomain) &gt; 0 </span><span class="cov8" title="1">{
                all[m.hostedDomain] = true
        }</span>
        <span class="cov8" title="1">var final []string
        for domain := range all </span><span class="cov8" title="1">{
                final = append(final, domain)
        }</span>
        <span class="cov8" title="1">return final</span>
}

// WithClientID sets the client id.
func (m *Manager) WithClientID(clientID string) *Manager <span class="cov8" title="1">{
        m.clientID = clientID
        return m
}</span>

// ClientID returns a property.
func (m *Manager) ClientID() string <span class="cov8" title="1">{
        return m.clientID
}</span>

// WithClientSecret sets the client id.
func (m *Manager) WithClientSecret(clientSecret string) *Manager <span class="cov0" title="0">{
        m.clientSecret = clientSecret
        return m
}</span>

// ClientSecret returns a client secret.
func (m *Manager) ClientSecret() string <span class="cov8" title="1">{
        return m.clientSecret
}</span>

// WithNonceTimeout sets the nonce timeout.
func (m *Manager) WithNonceTimeout(timeout time.Duration) *Manager <span class="cov8" title="1">{
        m.nonceTimeout = timeout
        return m
}</span>

// NonceTimeout returns the nonce timeout.
func (m *Manager) NonceTimeout() time.Duration <span class="cov8" title="1">{
        return m.nonceTimeout
}</span>

// OAuthURL is the auth url for google with a given clientID.
// This is typically the link that a user will click on to start the auth process.
func (m *Manager) OAuthURL(redirect ...string) (string, error) <span class="cov8" title="1">{
        u := &amp;url.URL{
                Scheme: "https",
                Host:   "accounts.google.com",
                Path:   "/o/oauth2/auth",
        }

        query := &amp;url.Values{}
        query.Add("response_type", "code")
        query.Add("client_id", m.clientID)
        query.Add("scope", "openid email profile")
        query.Add("redirect_uri", m.redirectURI)

        state, err := m.State(redirect...)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">if len(state) &gt; 0 </span><span class="cov8" title="1">{
                query.Add("state", state)
        }</span>

        <span class="cov8" title="1">nonce, err := m.CreateNonce(time.Now().UTC())
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">query.Add("nonce", nonce)

        if len(m.hostedDomain) &gt; 0 </span><span class="cov8" title="1">{
                query.Add("hd", m.hostedDomain)
        }</span>

        <span class="cov8" title="1">u.ForceQuery = true
        u.RawQuery = query.Encode()
        return u.String(), nil</span>
}

// Finish processes the returned code, exchanging for an access token, and fetches the user profile.
func (m *Manager) Finish(r *http.Request) (*Result, error) <span class="cov0" title="0">{
        result := Result{}

        // grab the code off the request.
        code := r.URL.Query().Get("code")
        if len(code) == 0 </span><span class="cov0" title="0">{
                return nil, ErrCodeMissing
        }</span>

        // fetch the state
        <span class="cov0" title="0">state := r.URL.Query().Get("state")
        if len(state) &gt; 0 </span><span class="cov0" title="0">{
                deserialized, err := DeserializeState(state)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">result.State = deserialized</span>
        }

        // if we need to check the anti-forgery token
        <span class="cov0" title="0">if result.State == nil || len(result.State.Secure) == 0 </span><span class="cov0" title="0">{
                return nil, ErrStateMissing
        }</span>

        <span class="cov0" title="0">err := m.ValidateOAuthState(result.State)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // exchange the code for an access token.
        <span class="cov0" title="0">res, err := m.TokenExchange(code)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;result, err
        }</span>

        <span class="cov0" title="0">result.Response = res
        jwt, err := DeserializeJWT(res.IDToken)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;result, err
        }</span>

        <span class="cov0" title="0">if err := m.ValidateJWT(jwt); err != nil </span><span class="cov0" title="0">{
                return &amp;result, err
        }</span>

        // fetch the user profile
        <span class="cov0" title="0">profile, err := m.FetchProfile(res.AccessToken)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;result, err
        }</span>

        // validate the profile
        <span class="cov0" title="0">if err := m.ValidateProfile(profile); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // this is (supposed to be) the actual unique id for the user.
        <span class="cov0" title="0">result.UniqueID = jwt.Payload.Sub
        result.IDToken = &amp;jwt.Payload
        result.Profile = profile

        return &amp;result, nil</span>
}

// State returns the serialized auth state.
func (m *Manager) State(redirect ...string) (string, error) <span class="cov8" title="1">{
        if len(m.secret) == 0 </span><span class="cov0" title="0">{
                return "", ErrSecretRequired
        }</span>
        <span class="cov8" title="1">return SerializeOAuthState(m.CreateState(redirect...))</span>
}

// CreateState creates auth state.
func (m *Manager) CreateState(redirect ...string) *State <span class="cov8" title="1">{
        token, secure := m.CreateAntiForgeryTokenPair()
        state := &amp;State{
                Token:  token,
                Secure: secure,
        }

        if len(redirect) &gt; 0 &amp;&amp; len(redirect[0]) &gt; 0 </span><span class="cov8" title="1">{
                if state == nil </span><span class="cov0" title="0">{
                        state = &amp;State{}
                }</span>
                <span class="cov8" title="1">state.RedirectURL = redirect[0]</span>
        }

        <span class="cov8" title="1">return state</span>
}

// TokenExchange performs the second phase of the oauth 2.0 flow with google.
func (m *Manager) TokenExchange(code string) (*Response, error) <span class="cov0" title="0">{
        var oar Response
        meta, err := request.New().
                AsPost().
                WithScheme("https").
                WithHost("accounts.google.com").
                WithPath("o/oauth2/token").
                WithPostData("client_id", m.clientID).
                WithPostData("client_secret", m.clientSecret).
                WithPostData("grant_type", "authorization_code").
                WithPostData("redirect_uri", m.redirectURI).
                WithPostData("code", code).
                WithMockProvider(request.MockedResponseInjector).
                JSONWithMeta(&amp;oar)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if meta.StatusCode &gt; 299 </span><span class="cov0" title="0">{
                return nil, exception.NewFromErr(ErrGoogleResponseStatus).WithMessagef("status code; %d", meta.StatusCode)
        }</span>
        <span class="cov0" title="0">return &amp;oar, err</span>
}

// FetchProfile gets a google proflile for an access token.
func (m *Manager) FetchProfile(accessToken string) (*Profile, error) <span class="cov0" title="0">{
        var profile Profile
        meta, err := request.New().AsGet().
                WithURL("https://www.googleapis.com/oauth2/v1/userinfo").
                WithQueryString("alt", "json").
                WithQueryString("access_token", accessToken).
                WithMockProvider(request.MockedResponseInjector).
                JSONWithMeta(&amp;profile)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if meta.StatusCode &gt; 299 </span><span class="cov0" title="0">{
                return nil, exception.NewFromErr(ErrGoogleResponseStatus).WithMessagef("status code; %d", meta.StatusCode)
        }</span>
        <span class="cov0" title="0">return &amp;profile, err</span>
}

// ValidateConfig validates the manager configuration.
// This should be used on start to ensure that the manager has everything it needs.
func (m *Manager) ValidateConfig() error <span class="cov0" title="0">{
        if len(m.secret) == 0 </span><span class="cov0" title="0">{
                return ErrSecretRequired
        }</span>
        <span class="cov0" title="0">if len(m.clientID) == 0 </span><span class="cov0" title="0">{
                return ErrClientIDRequired
        }</span>
        <span class="cov0" title="0">if len(m.clientSecret) == 0 </span><span class="cov0" title="0">{
                return ErrClientSecretRequired
        }</span>
        <span class="cov0" title="0">if len(m.redirectURI) == 0 </span><span class="cov0" title="0">{
                return ErrRedirectURIRequired
        }</span>

        <span class="cov0" title="0">u, err := url.Parse(m.redirectURI)
        if err != nil </span><span class="cov0" title="0">{
                return ErrInvalidRedirectURI
        }</span>

        <span class="cov0" title="0">if len(u.Scheme) == 0 </span><span class="cov0" title="0">{
                return ErrInvalidRedirectURI
        }</span>

        <span class="cov0" title="0">if len(u.Host) == 0 </span><span class="cov0" title="0">{
                return ErrInvalidRedirectURI
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateJWT validates a jwt.
func (m *Manager) ValidateJWT(jwt *JWT) error <span class="cov8" title="1">{
        if len(m.clientID) &gt; 0 &amp;&amp; !hmac.Equal([]byte(jwt.Payload.AUD), []byte(m.clientID)) </span><span class="cov8" title="1">{
                return ErrInvalidAUD
        }</span>

        <span class="cov8" title="1">if m.skipDomainValidation </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if len(jwt.Payload.HostedDomain) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">validDomains := m.ValidDomains()
        if len(validDomains) == 0 </span><span class="cov0" title="0">{
                return ErrNoValidDomains
        }</span>

        <span class="cov0" title="0">valid := false
        for _, domain := range m.ValidDomains() </span><span class="cov0" title="0">{
                valid = valid || util.String.CaseInsensitiveEquals(domain, jwt.Payload.HostedDomain)
                if valid </span><span class="cov0" title="0">{
                        break</span>
                }
        }

        <span class="cov0" title="0">if !valid </span><span class="cov0" title="0">{
                return ErrInvalidHostedDomain
        }</span>

        // check the nonce ...
        <span class="cov0" title="0">return m.ValidateNonce(jwt.Payload.Nonce)</span>
}

// ValidateProfile validates a profile.
func (m *Manager) ValidateProfile(p *Profile) error <span class="cov8" title="1">{
        if m.skipDomainValidation </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if len(m.ValidDomains()) == 0 </span><span class="cov8" title="1">{
                return ErrNoValidDomains
        }</span>

        <span class="cov8" title="1">valid := false
        for _, domain := range m.ValidDomains() </span><span class="cov8" title="1">{
                workingDomain := domain
                if !strings.HasPrefix(workingDomain, "@") </span><span class="cov8" title="1">{
                        workingDomain = fmt.Sprintf("@%s", workingDomain)
                }</span>
                <span class="cov8" title="1">valid = valid || util.String.HasSuffixCaseInsensitive(p.Email, workingDomain)
                if valid </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">if !valid </span><span class="cov8" title="1">{
                return ErrInvalidEmailDomain
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ValidateOAuthState validates oauth state.
func (m *Manager) ValidateOAuthState(s *State) error <span class="cov8" title="1">{
        expected := m.hash(s.Token)
        actual := s.Secure
        if !hmac.Equal([]byte(expected), []byte(actual)) </span><span class="cov0" title="0">{
                return ErrInvalidAntiforgeryToken
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// CreateAntiForgeryTokenPair generates an anti-forgery token.
func (m *Manager) CreateAntiForgeryTokenPair() (plaintext, ciphertext string) <span class="cov8" title="1">{
        plaintext = uuid.V4().String()
        ciphertext = m.hash(plaintext)
        return
}</span>

// CreateNonce creates a nonce.
func (m *Manager) CreateNonce(t time.Time) (string, error) <span class="cov8" title="1">{
        tv := t.Format(time.RFC3339)
        cipherText, err := util.Crypto.Encrypt(m.secret, []byte(tv))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return url.QueryEscape(Base64Encode([]byte(cipherText))), nil</span>
}

// ValidateNonce validates a nonce.
func (m *Manager) ValidateNonce(nonce string) error <span class="cov8" title="1">{
        unescaped, err := url.QueryUnescape(nonce)
        if err != nil </span><span class="cov0" title="0">{
                return exception.Wrap(err)
        }</span>
        <span class="cov8" title="1">ciphertext, err := Base64Decode(unescaped)
        if err != nil </span><span class="cov0" title="0">{
                return exception.Wrap(err)
        }</span>
        <span class="cov8" title="1">plaintext, err := util.Crypto.Decrypt(m.secret, ciphertext)
        if err != nil </span><span class="cov0" title="0">{
                return exception.Wrap(err)
        }</span>
        <span class="cov8" title="1">nonceTimestamp, err := time.Parse(time.RFC3339, string(plaintext))
        if err != nil </span><span class="cov0" title="0">{
                return exception.Wrap(err)
        }</span>

        <span class="cov8" title="1">if time.Now().UTC().Sub(nonceTimestamp) &gt; m.NonceTimeout() </span><span class="cov8" title="1">{
                return ErrInvalidNonce
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *Manager) hash(plaintext string) string <span class="cov8" title="1">{
        return Base64Encode(util.Crypto.Hash(m.secret, []byte(plaintext)))
}</span>
</pre>
		
		<pre class="file" id="file71" style="display: none">package oauth

import (
        "bytes"
        "encoding/base64"
        "encoding/gob"

        "github.com/blend/go-sdk/exception"
)

// DeserializeState deserializes the oauth state.
func DeserializeState(raw string) (*State, error) <span class="cov8" title="1">{
        corpus, err := base64.StdEncoding.DecodeString(raw)
        if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>
        <span class="cov8" title="1">buffer := bytes.NewBuffer(corpus)
        var state State
        if err := gob.NewDecoder(buffer).Decode(&amp;state); err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>

        <span class="cov8" title="1">return &amp;state, nil</span>
}

// SerializeOAuthState serializes the oauth state.
func SerializeOAuthState(state *State) (output string, err error) <span class="cov8" title="1">{
        buffer := bytes.NewBuffer(nil)
        err = gob.NewEncoder(buffer).Encode(state)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">output = base64.StdEncoding.EncodeToString(buffer.Bytes())
        return</span>
}

// State is the oauth state.
type State struct {
        Token       string
        Secure      string
        RedirectURL string
}
</pre>
		
		<pre class="file" id="file72" style="display: none">package oauth

import "strings"

// Profile is a profile with google.
type Profile struct {
        ID            string `json:"id"`
        Email         string `json:"email"`
        VerifiedEmail bool   `json:"verified_email"`
        Name          string `json:"name"`
        GivenName     string `json:"given_name"`
        FamilyName    string `json:"family_name"`
        Link          string `json:"link"`
        Gender        string `json:"gender"`
        Locale        string `json:"locale"`
        PictureURL    string `json:"picture"`
}

// Username returns the &lt;username&gt;@fqdn component
// of the email address.
func (p Profile) Username() string <span class="cov8" title="1">{
        if len(p.Email) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">if !strings.Contains(p.Email, "@") </span><span class="cov0" title="0">{
                return p.Email
        }</span>

        <span class="cov8" title="1">parts := strings.SplitN(p.Email, "@", 2)
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return parts[0]</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">package oauth

import (
        "encoding/base64"

        "github.com/blend/go-sdk/util"
)

// GenerateSecret is a helper to create secret keys.
func GenerateSecret() string <span class="cov0" title="0">{
        return Base64Encode(util.Crypto.MustCreateKey(32))
}</span>

// Base64Decode decodes a string as base64.
func Base64Decode(corpus string) ([]byte, error) <span class="cov8" title="1">{
        return base64.StdEncoding.DecodeString(corpus)
}</span>

// MustBase64Decode decodes a string as base64 and panics if there is an error.
func MustBase64Decode(corpus string) []byte <span class="cov0" title="0">{
        contents, err := Base64Decode(corpus)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return contents</span>
}

// Base64Encode encodes binary as a base64 string.
func Base64Encode(corpus []byte) string <span class="cov8" title="1">{
        return base64.StdEncoding.EncodeToString(corpus)
}</span>
</pre>
		
		<pre class="file" id="file74" style="display: none">package proxy

import "sync"

// A BufferPool is an interface for getting and returning temporary
// byte slices for use by io.CopyBuffer.
type BufferPool interface {
        Get() []byte
        Put([]byte)
}

// NewBufferPool returns a new buffer pool.
func NewBufferPool() BufferPool <span class="cov0" title="0">{
        return &amp;localBufferPool{
                pool: &amp;sync.Pool{
                        New: func() interface{} </span><span class="cov0" title="0">{
                                return []byte{}
                        }</span>,
                },
        }
}

type localBufferPool struct {
        pool *sync.Pool
}

func (lbp *localBufferPool) Get() []byte <span class="cov0" title="0">{
        return lbp.pool.Get().([]byte)
}</span>

func (lbp *localBufferPool) Put(buf []byte) <span class="cov0" title="0">{
        lbp.pool.Put(buf)
}</span>
</pre>
		
		<pre class="file" id="file75" style="display: none">package proxy

import (
        "fmt"
        "net/http"
        "os"

        "github.com/blend/go-sdk/logger"
)

const (
        // FlagProxyRequest is a logger flag.
        FlagProxyRequest logger.Flag = "proxy.request"
)

// New returns a new proxy.
func New() *Proxy <span class="cov8" title="1">{
        return &amp;Proxy{}
}</span>

// Proxy is a factory for a simple reverse proxy.
type Proxy struct {
        BaseServer
        upstreams []*Upstream
        resolver  Resolver
}

// WithLogger sets a property and returns the proxy reference.
func (p *Proxy) WithLogger(log *logger.Logger) *Proxy <span class="cov0" title="0">{
        p.log = log
        return p
}</span>

// WithUpstream adds an upstream by URL.
func (p *Proxy) WithUpstream(upstream *Upstream) *Proxy <span class="cov8" title="1">{
        p.upstreams = append(p.upstreams, upstream)
        return p
}</span>

// WithResolver sets a property and returns the proxy reference.
func (p *Proxy) WithResolver(resolver Resolver) *Proxy <span class="cov0" title="0">{
        p.resolver = resolver
        return p
}</span>

// ServeHTTP is the http entrypoint.
func (p *Proxy) ServeHTTP(rw http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        if p.log != nil </span><span class="cov0" title="0">{
                                p.log.Fatalf("%v", r)
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Fprintf(os.Stderr, "%v\n", r)
                        }</span>
                }
        }()

        // set the default resolver if unset.
        <span class="cov8" title="1">if p.resolver == nil </span><span class="cov8" title="1">{
                p.resolver = RoundRobinResolver(p.upstreams)
        }</span>

        <span class="cov8" title="1">upstream, err := p.resolver(req, p.upstreams)

        if err != nil </span><span class="cov0" title="0">{
                p.log.Error(err)
                rw.WriteHeader(http.StatusBadGateway)
                return
        }</span>

        <span class="cov8" title="1">if upstream == nil </span><span class="cov0" title="0">{
                rw.WriteHeader(http.StatusNotFound)
                return
        }</span>

        <span class="cov8" title="1">upstream.ServeHTTP(rw, req)</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package proxy

import (
        "net/http"
)

const (
        schemeHTTPS = "https"
)

// NewHTTPRedirect returns a new HTTPRedirect which redirects HTTP to HTTPS
func NewHTTPRedirect() *HTTPRedirect <span class="cov8" title="1">{
        return &amp;HTTPRedirect{}
}</span>

// HTTPRedirect redirects HTTP to HTTPS
type HTTPRedirect struct {
        BaseServer
}

// ServeHTTP redirects HTTP to HTTPS
func (hr *HTTPRedirect) ServeHTTP(rw http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        req.URL.Scheme = schemeHTTPS // upgrade to https. TODO: validation on the original value?
        if req.URL.Host == "" </span><span class="cov8" title="1">{
                req.URL.Host = req.Host
        }</span>

        <span class="cov8" title="1">http.Redirect(rw, req, req.URL.String(), http.StatusMovedPermanently)</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">package proxy

import "net/http"

// Resolver is a function that takes a request and produces a destination `url.URL`.
type Resolver func(*http.Request, []*Upstream) (*Upstream, error)

// RoundRobinResolver returns a closure based resolver that rotates through upstreams uniformly.
func RoundRobinResolver(upstreams []*Upstream) Resolver <span class="cov8" title="1">{
        current, total := 0, len(upstreams)
        return func(req *http.Request, upstreams []*Upstream) (*Upstream, error) </span><span class="cov8" title="1">{
                upstream := upstreams[current]
                current = (current + 1) % total
                return upstream, nil
        }</span>
}
</pre>
		
		<pre class="file" id="file78" style="display: none">package proxy

import (
        "context"
        "crypto/tls"
        "io"
        "net"
        "net/http"
        "net/url"
        "strings"
        "sync"
        "time"

        "github.com/blend/go-sdk/logger"
)

// NewUpstream returns a new upstram.
func NewUpstream(target *url.URL) *Upstream <span class="cov8" title="1">{
        return &amp;Upstream{
                URL: target,
                // Hop-by-hop headers. These are removed when sent to the backend.
                // http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html
                HopHeaders: []string{
                        "Connection",
                        "Proxy-Connection", // non-standard but still sent by libcurl and rejected by e.g. google
                        "Keep-Alive",
                        "Proxy-Authenticate",
                        "Proxy-Authorization",
                        "Te",      // canonicalized version of "TE"
                        "Trailer", // not Trailers per URL above; http://www.rfc-editor.org/errata_search.php?eid=4522
                        "Transfer-Encoding",
                        "Upgrade",
                },
        }
}</span>

// Upstream represents a proxyable server.
type Upstream struct {
        // Name is the name of the upstream.
        Name string
        // Log is a logger agent.
        Log *logger.Logger
        // URL represents the target of the upstream.
        URL *url.URL
        // Transport represents the underlying connection to the upstream.
        Transport *http.Transport

        // TLSInsecureSkipVerify skips tls cert ferification on upstreams.
        // It is typically used in debugging.
        TLSInsecureSkipVerify bool
        // Close closes the connections on completion.
        Close bool
        // FlushInterval defines the buffer flush interval for the default transports.
        FlushInterval time.Duration

        // BufferPool allows re-use of data buffers between requests.
        BufferPool BufferPool

        // HopHeaders indicate headers we should strip from upstream requests.
        HopHeaders []string

        // StaticDestination prevents forwarding of url or querystring params to the upstream.
        StaticDestination bool
}

// WithName sets the name field of the upstream.
func (u *Upstream) WithName(name string) *Upstream <span class="cov0" title="0">{
        u.Name = name
        return u
}</span>

// WithLogger sets the logger agent for the upstream.
func (u *Upstream) WithLogger(log *logger.Logger) *Upstream <span class="cov0" title="0">{
        u.Log = log
        return u
}</span>

// WithTLSInsecureSkipVerify sets a property and returns the upstream reference.
func (u *Upstream) WithTLSInsecureSkipVerify(insecureSkipVerify bool) *Upstream <span class="cov0" title="0">{
        u.TLSInsecureSkipVerify = insecureSkipVerify
        return u
}</span>

// WithClose sets a property and returns the upstream reference.
func (u *Upstream) WithClose(close bool) *Upstream <span class="cov0" title="0">{
        u.Close = close
        return u
}</span>

// WithFlushInterval sets a property and returns the upstream reference.
func (u *Upstream) WithFlushInterval(interval time.Duration) *Upstream <span class="cov0" title="0">{
        u.FlushInterval = interval
        return u
}</span>

// WithStaticDestination sets a property and returns the upstream reference.
func (u *Upstream) WithStaticDestination(value bool) *Upstream <span class="cov0" title="0">{
        u.StaticDestination = value
        return u
}</span>

// WithBufferPool sets a property and returns the upstream reference.
func (u *Upstream) WithBufferPool(bufferPool BufferPool) *Upstream <span class="cov0" title="0">{
        u.BufferPool = bufferPool
        return u
}</span>

// WithHopHeaders sets a property and returns the upstream reference.
func (u *Upstream) WithHopHeaders(headers ...string) *Upstream <span class="cov0" title="0">{
        u.HopHeaders = append(u.HopHeaders, headers...)
        return u
}</span>

// WithoutHopHeaders sets a property and returns the upstream reference.
func (u *Upstream) WithoutHopHeaders(headers ...string) *Upstream <span class="cov8" title="1">{
        var included []string
        for _, h := range u.HopHeaders </span><span class="cov8" title="1">{
                include := true
                for _, strike := range headers </span><span class="cov8" title="1">{
                        include = include &amp;&amp; strike != h
                }</span>
                <span class="cov8" title="1">if include </span><span class="cov8" title="1">{
                        included = append(included, h)
                }</span>
        }
        <span class="cov8" title="1">u.HopHeaders = included
        return u</span>
}

func (u *Upstream) setDestination(req *http.Request) error <span class="cov8" title="1">{
        req.URL.Scheme = u.URL.Scheme
        req.URL.Host = u.URL.Host
        if u.StaticDestination </span><span class="cov0" title="0">{
                req.Host = u.URL.Host
                req.URL.Path = u.URL.Path
                req.URL.RawQuery = u.URL.RawQuery
        }</span> else<span class="cov8" title="1"> {
                req.URL.Path = singleJoiningSlash(u.URL.Path, req.URL.Path)
                if u.URL.RawQuery == "" || req.URL.RawQuery == "" </span><span class="cov8" title="1">{
                        req.URL.RawQuery = u.URL.RawQuery + req.URL.RawQuery
                }</span> else<span class="cov0" title="0"> {
                        req.URL.RawQuery = u.URL.RawQuery + "&amp;" + req.URL.RawQuery
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// ServeHTTP
func (u *Upstream) ServeHTTP(rw http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        var statusCode int
        var contentLength int64

        if u.Log != nil </span><span class="cov0" title="0">{
                // log the start event
                u.Log.Trigger(logger.NewWebRequestStartEvent(req))
        }</span>

        <span class="cov8" title="1">start := time.Now()

        // create the transport if it doesn't exist.
        if u.Transport == nil </span><span class="cov8" title="1">{
                u.Transport = &amp;http.Transport{
                        TLSClientConfig: &amp;tls.Config{
                                InsecureSkipVerify: u.TLSInsecureSkipVerify,
                        },
                }
        }</span>

        <span class="cov8" title="1">ctx := req.Context()
        if cn, ok := rw.(http.CloseNotifier); ok </span><span class="cov8" title="1">{
                var cancel context.CancelFunc
                ctx, cancel = context.WithCancel(ctx)
                defer cancel()
                notifyChan := cn.CloseNotify()
                go func() </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-notifyChan:<span class="cov0" title="0">
                                statusCode = http.StatusRequestTimeout
                                cancel()</span>
                        case &lt;-ctx.Done():</span><span class="cov8" title="1">
                        }
                }()
        }

        <span class="cov8" title="1">if u.Log != nil </span><span class="cov0" title="0">{
                // log events.
                defer func() </span><span class="cov0" title="0">{
                        wre := logger.NewWebRequestEvent(req).WithStatusCode(statusCode).WithContentLength(contentLength).WithElapsed(time.Since(start))
                        if value := rw.Header().Get("Content-Type"); len(value) &gt; 0 </span><span class="cov0" title="0">{
                                wre = wre.WithContentType(value)
                        }</span>
                        <span class="cov0" title="0">if value := rw.Header().Get("Content-Encoding"); len(value) &gt; 0 </span><span class="cov0" title="0">{
                                wre = wre.WithContentEncoding(value)
                        }</span>
                        <span class="cov0" title="0">u.Log.Trigger(wre)</span>
                }()
        }

        <span class="cov8" title="1">outreq := new(http.Request)
        *outreq = *req // includes shallow copies of maps, but okay
        if req.ContentLength == 0 </span><span class="cov8" title="1">{
                outreq.Body = nil // Issue 16036: nil Body for http.Transport retries
        }</span>

        <span class="cov8" title="1">u.setDestination(outreq)
        outreq = outreq.WithContext(ctx)
        outreq.Close = u.Close

        // We are modifying the same underlying map from req (shallow
        // copied above) so we only copy it if necessary.
        copiedHeaders := false

        // Remove hop-by-hop headers listed in the "Connection" header.
        // See RFC 2616, section 14.10.
        if c := outreq.Header.Get("Connection"); c != "" </span><span class="cov0" title="0">{
                for _, f := range strings.Split(c, ",") </span><span class="cov0" title="0">{
                        if f = strings.TrimSpace(f); f != "" </span><span class="cov0" title="0">{
                                if !copiedHeaders </span><span class="cov0" title="0">{
                                        outreq.Header = make(http.Header)
                                        copyHeader(outreq.Header, req.Header)
                                        copiedHeaders = true
                                }</span>
                                <span class="cov0" title="0">outreq.Header.Del(f)</span>
                        }
                }
        }

        // Remove hop-by-hop headers to the backend. Especially
        // important is "Connection" because we want a persistent
        // connection, regardless of what the client sent to us.
        <span class="cov8" title="1">for _, h := range u.HopHeaders </span><span class="cov8" title="1">{
                if outreq.Header.Get(h) != "" </span><span class="cov0" title="0">{
                        if !copiedHeaders </span><span class="cov0" title="0">{
                                outreq.Header = make(http.Header)
                                copyHeader(outreq.Header, req.Header)
                                copiedHeaders = true
                        }</span>
                        <span class="cov0" title="0">outreq.Header.Del(h)</span>
                }
        }

        <span class="cov8" title="1">if clientIP, _, err := net.SplitHostPort(req.RemoteAddr); err == nil </span><span class="cov8" title="1">{
                // If we aren't the first proxy retain prior
                // X-Forwarded-For information as a comma+space
                // separated list and fold multiple headers into one.
                if prior, ok := outreq.Header["X-Forwarded-For"]; ok </span><span class="cov0" title="0">{
                        clientIP = strings.Join(prior, ", ") + ", " + clientIP
                }</span>
                <span class="cov8" title="1">outreq.Header.Set("X-Forwarded-For", clientIP)</span>
        }

        // Add the forwarded proto if it doesn't exist.
        <span class="cov8" title="1">if _, ok := outreq.Header["X-Forwarded-Proto"]; !ok </span><span class="cov8" title="1">{
                outreq.Header.Set("X-Forwarded-Proto", req.URL.Scheme)
        }</span>

        <span class="cov8" title="1">res, err := u.Transport.RoundTrip(outreq)
        if err != nil </span><span class="cov0" title="0">{
                statusCode = http.StatusBadGateway
                if u.Log != nil </span><span class="cov0" title="0">{
                        u.Log.Error(err)
                }</span>
                <span class="cov0" title="0">rw.WriteHeader(statusCode)
                return</span>
        }

        // Remove hop-by-hop headers listed in the
        // "Connection" header of the response.
        <span class="cov8" title="1">if c := res.Header.Get("Connection"); c != "" </span><span class="cov0" title="0">{
                for _, f := range strings.Split(c, ",") </span><span class="cov0" title="0">{
                        if f = strings.TrimSpace(f); f != "" </span><span class="cov0" title="0">{
                                res.Header.Del(f)
                        }</span>
                }
        }

        <span class="cov8" title="1">for _, h := range u.HopHeaders </span><span class="cov8" title="1">{
                res.Header.Del(h)
        }</span>

        <span class="cov8" title="1">copyHeader(rw.Header(), res.Header)

        // The "Trailer" header isn't included in the Transport's response,
        // at least for *http.Transport. Build it up from Trailer.
        if len(res.Trailer) &gt; 0 </span><span class="cov0" title="0">{
                trailerKeys := make([]string, 0, len(res.Trailer))
                for k := range res.Trailer </span><span class="cov0" title="0">{
                        trailerKeys = append(trailerKeys, k)
                }</span>
                <span class="cov0" title="0">rw.Header().Add("Trailer", strings.Join(trailerKeys, ", "))</span>
        }

        <span class="cov8" title="1">statusCode = res.StatusCode
        rw.WriteHeader(res.StatusCode)
        if len(res.Trailer) &gt; 0 </span><span class="cov0" title="0">{
                // Force chunking if we saw a response trailer.
                // This prevents net/http from calculating the length for short
                // bodies and adding a Content-Length.
                if fl, ok := rw.(http.Flusher); ok </span><span class="cov0" title="0">{
                        fl.Flush()
                }</span>
        }
        <span class="cov8" title="1">contentLength, err = u.copyResponse(rw, res.Body)
        if err != nil &amp;&amp; err != io.EOF &amp;&amp; u.Log != nil </span><span class="cov0" title="0">{
                u.Log.Error(err)
        }</span>
        <span class="cov8" title="1">res.Body.Close() // close now, instead of defer, to populate res.Trailer
        copyHeader(rw.Header(), res.Trailer)</span>
}

func (u *Upstream) copyResponse(dst io.Writer, src io.Reader) (contentLength int64, err error) <span class="cov8" title="1">{
        if u.FlushInterval != 0 </span><span class="cov0" title="0">{
                if wf, ok := dst.(writeFlusher); ok </span><span class="cov0" title="0">{
                        mlw := &amp;maxLatencyWriter{
                                dst:     wf,
                                latency: u.FlushInterval,
                                done:    make(chan bool),
                        }
                        go mlw.flushLoop()
                        defer mlw.stop()
                        dst = mlw
                }</span>
        }

        <span class="cov8" title="1">var buf []byte
        if u.BufferPool != nil </span><span class="cov0" title="0">{
                buf = u.BufferPool.Get()
        }</span>
        <span class="cov8" title="1">contentLength, err = u.copyBuffer(dst, src, buf)
        if u.BufferPool != nil </span><span class="cov0" title="0">{
                u.BufferPool.Put(buf)
        }</span>
        <span class="cov8" title="1">return</span>
}

func (u *Upstream) copyBuffer(dst io.Writer, src io.Reader, buf []byte) (int64, error) <span class="cov8" title="1">{
        if len(buf) == 0 </span><span class="cov8" title="1">{
                buf = make([]byte, 32*1024)
        }</span>
        <span class="cov8" title="1">var written int64
        for </span><span class="cov8" title="1">{
                nr, rerr := src.Read(buf)
                if rerr != nil &amp;&amp; rerr != io.EOF </span><span class="cov0" title="0">{
                        return written, rerr
                }</span>
                <span class="cov8" title="1">if nr &gt; 0 </span><span class="cov8" title="1">{
                        nw, werr := dst.Write(buf[:nr])
                        if nw &gt; 0 </span><span class="cov8" title="1">{
                                written += int64(nw)
                        }</span>
                        <span class="cov8" title="1">if werr != nil </span><span class="cov0" title="0">{
                                return written, werr
                        }</span>
                        <span class="cov8" title="1">if nr != nw </span><span class="cov0" title="0">{
                                return written, io.ErrShortWrite
                        }</span>
                }
                <span class="cov8" title="1">if rerr != nil </span><span class="cov8" title="1">{
                        return written, rerr
                }</span>
        }
}

func singleJoiningSlash(a, b string) string <span class="cov8" title="1">{
        aslash := strings.HasSuffix(a, "/")
        bslash := strings.HasPrefix(b, "/")
        switch </span>{
        case aslash &amp;&amp; bslash:<span class="cov0" title="0">
                return a + b[1:]</span>
        case !aslash &amp;&amp; !bslash:<span class="cov0" title="0">
                return a + "/" + b</span>
        }
        <span class="cov8" title="1">return a + b</span>
}

func copyHeader(dst, src http.Header) <span class="cov8" title="1">{
        for k, vv := range src </span><span class="cov8" title="1">{
                for _, v := range vv </span><span class="cov8" title="1">{
                        dst.Add(k, v)
                }</span>
        }
}

type writeFlusher interface {
        io.Writer
        http.Flusher
}

type maxLatencyWriter struct {
        dst     writeFlusher
        latency time.Duration

        mu   sync.Mutex // protects Write + Flush
        done chan bool
}

func (m *maxLatencyWriter) Write(p []byte) (int, error) <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()
        return m.dst.Write(p)
}</span>

func (m *maxLatencyWriter) flushLoop() <span class="cov0" title="0">{
        t := time.NewTicker(m.latency)
        defer t.Stop()
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-m.done:<span class="cov0" title="0">
                        return</span>
                case &lt;-t.C:<span class="cov0" title="0">
                        m.mu.Lock()
                        m.dst.Flush()
                        m.mu.Unlock()</span>
                }
        }
}

func (m *maxLatencyWriter) stop() <span class="cov0" title="0">{ m.done &lt;- true }</span>
</pre>
		
		<pre class="file" id="file79" style="display: none">package proxy

import "net/url"

// MustParseURL parses a url and panics if it's bad.
func MustParseURL(rawURL string) *url.URL <span class="cov0" title="0">{
        u, err := url.Parse(rawURL)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return u</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">package request

import (
        "bytes"
        "fmt"
        "time"

        "github.com/blend/go-sdk/logger"
)

const (
        // Flag is a logger event flag.
        Flag logger.Flag = "request"
        // FlagResponse is a logger event flag.
        FlagResponse logger.Flag = "request.response"
)

// NewRequestListener creates a new request listener.
func NewRequestListener(listener func(Event)) logger.Listener <span class="cov0" title="0">{
        return func(e logger.Event) </span><span class="cov0" title="0">{
                if typed, isTyped := e.(Event); isTyped </span><span class="cov0" title="0">{
                        listener(typed)
                }</span>
        }
}

// Event is a logger event for outgoing requests.
type Event struct {
        ts  time.Time
        req *Meta
}

// Flag returns the event flag.
func (re Event) Flag() logger.Flag <span class="cov8" title="1">{
        return Flag
}</span>

// Timestamp returns the event timestamp.
func (re Event) Timestamp() time.Time <span class="cov0" title="0">{
        return re.ts
}</span>

// Request returns the request meta.
func (re Event) Request() *Meta <span class="cov0" title="0">{
        return re.req
}</span>

// WriteText writes an outgoing request as text to a given buffer.
func (re Event) WriteText(tf logger.TextFormatter, buf *bytes.Buffer) <span class="cov8" title="1">{
        buf.WriteString(fmt.Sprintf("%s %s", re.req.Verb, re.req.URL.String()))
        if len(re.req.Body) &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteRune(logger.RuneNewline)
                buf.WriteString("request body")
                buf.WriteRune(logger.RuneNewline)
                buf.Write(re.req.Body)
        }</span>
}

// WriteJSON implements logger.JSONWritable.
func (re Event) WriteJSON() logger.JSONObj <span class="cov0" title="0">{
        return logger.JSONObj{
                "req": re.req,
        }
}</span>

// ResponseEvent is a response to outgoing requests.
type ResponseEvent struct {
        ts   time.Time
        req  *Meta
        res  *ResponseMeta
        body []byte
}

// Flag returns the event flag.
func (re ResponseEvent) Flag() logger.Flag <span class="cov8" title="1">{
        return FlagResponse
}</span>

// Timestamp returns the event timestamp.
func (re ResponseEvent) Timestamp() time.Time <span class="cov0" title="0">{
        return re.ts
}</span>

// Request returns the request meta.
func (re ResponseEvent) Request() *Meta <span class="cov0" title="0">{
        return re.req
}</span>

// Response returns the response meta.
func (re ResponseEvent) Response() *ResponseMeta <span class="cov0" title="0">{
        return re.res
}</span>

// Body returns the outgoing request body.
func (re ResponseEvent) Body() []byte <span class="cov0" title="0">{
        return re.body
}</span>

// WriteText writes the event to a text writer.
func (re ResponseEvent) WriteText(tf logger.TextFormatter, buf *bytes.Buffer) <span class="cov8" title="1">{
        buf.WriteString(fmt.Sprintf("%s %s %s", re.req.Verb, re.req.URL.String(), tf.ColorizeStatusCode(re.res.StatusCode)))
        if len(re.body) &gt; 0 </span><span class="cov8" title="1">{
                buf.WriteRune(logger.RuneNewline)
                buf.Write(re.body)
        }</span>
}

// WriteJSON implements logger.JSONWritable.
func (re ResponseEvent) WriteJSON() logger.JSONObj <span class="cov0" title="0">{
        return logger.JSONObj{
                "req":  re.req,
                "res":  re.res,
                "body": re.body,
        }
}</span>
</pre>
		
		<pre class="file" id="file81" style="display: none">package request

import (
        "fmt"
        "io"
        "io/ioutil"
        "net/http"
        "net/url"
        "strings"
        "time"
)

//--------------------------------------------------------------------------------
// RequestMeta
//--------------------------------------------------------------------------------

// NewMeta returns a new meta object for a request.
func NewMeta(req *http.Request) *Meta <span class="cov0" title="0">{
        return &amp;Meta{
                Verb:    req.Method,
                URL:     req.URL,
                Headers: req.Header,
        }
}</span>

// NewMetaWithBody returns a new meta object for a request and reads the body.
func NewMetaWithBody(req *http.Request) (*Meta, error) <span class="cov0" title="0">{
        body, err := ioutil.ReadAll(req.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer req.Body.Close()
        return &amp;Meta{
                Verb:    req.Method,
                URL:     req.URL,
                Headers: req.Header,
                Body:    body,
        }, nil</span>
}

// Meta is a summary of the request meta useful for logging.
type Meta struct {
        StartTime time.Time
        Verb      string
        URL       *url.URL
        Headers   http.Header
        Body      []byte
}

//--------------------------------------------------------------------------------
// HttpResponseMeta
//--------------------------------------------------------------------------------

// NewResponseMeta returns a new meta object for a response.
func NewResponseMeta(res *http.Response) *ResponseMeta <span class="cov8" title="1">{
        meta := &amp;ResponseMeta{}

        if res == nil </span><span class="cov0" title="0">{
                return meta
        }</span>

        <span class="cov8" title="1">meta.CompleteTime = time.Now().UTC()
        meta.StatusCode = res.StatusCode
        meta.ContentLength = res.ContentLength

        meta.ContentType = tryHeader(res.Header, "Content-Type", "content-type")
        meta.ContentEncoding = tryHeader(res.Header, "Content-Encoding", "content-encoding")

        meta.Headers = res.Header
        meta.Cert = NewCertInfo(res)
        return meta</span>
}

func tryHeader(headers http.Header, keys ...string) string <span class="cov8" title="1">{
        for _, key := range keys </span><span class="cov8" title="1">{
                if values, hasValues := headers[key]; hasValues </span><span class="cov8" title="1">{
                        return strings.Join(values, ";")
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

// ResponseMeta is just the meta information for an http response.
type ResponseMeta struct {
        Cert            *CertInfo
        CompleteTime    time.Time
        StatusCode      int
        ContentLength   int64
        ContentEncoding string
        ContentType     string
        Headers         http.Header
}

// CreateTransportHandler is a receiver for `OnCreateTransport`.
type CreateTransportHandler func(host *url.URL, transport *http.Transport)

// ResponseHandler is a receiver for `OnResponse`.
type ResponseHandler func(req *Meta, meta *ResponseMeta, content []byte)

// StatefulResponseHandler is a receiver for `OnResponse` that includes a state object.
type StatefulResponseHandler func(req *Meta, res *ResponseMeta, content []byte, state interface{})

// OutgoingRequestHandler is a receiver for `OnRequest`.
type OutgoingRequestHandler func(req *Meta)

// MockedResponseProvider is a mocked response provider.
type MockedResponseProvider func(*Request) *MockedResponse

// Deserializer is a function that does things with the response body.
type Deserializer func(body []byte) error

// Serializer is a function that turns an object into raw data.
type Serializer func(value interface{}) ([]byte, error)

//--------------------------------------------------------------------------------
// PostedFile
//--------------------------------------------------------------------------------

// PostedFile represents a file to post with the request.
type PostedFile struct {
        Key          string
        FileName     string
        FileContents io.Reader
}

//--------------------------------------------------------------------------------
// Buffer
//--------------------------------------------------------------------------------

// Buffer is a type that supplies two methods found on bytes.Buffer.
type Buffer interface {
        Write([]byte) (int, error)
        Len() int64
        ReadFrom(io.ReadCloser) (int64, error)
        Bytes() []byte
}

// NewCertInfo returns a new cert info from a response.
func NewCertInfo(res *http.Response) *CertInfo <span class="cov8" title="1">{
        if res.TLS != nil &amp;&amp; len(res.TLS.PeerCertificates) &gt; 0 </span><span class="cov0" title="0">{
                var earliestExpiration time.Time
                var latestNotBefore time.Time
                for _, cert := range res.TLS.PeerCertificates </span><span class="cov0" title="0">{
                        if earliestExpiration.IsZero() || earliestExpiration.After(cert.NotAfter) </span><span class="cov0" title="0">{
                                earliestExpiration = cert.NotAfter
                        }</span>
                        <span class="cov0" title="0">if latestNotBefore.IsZero() || latestNotBefore.Before(cert.NotBefore) </span><span class="cov0" title="0">{
                                latestNotBefore = cert.NotBefore
                        }</span>
                }

                <span class="cov0" title="0">firstCert := res.TLS.PeerCertificates[0]

                var issuerCommonName string
                if len(firstCert.Issuer.CommonName) &gt; 0 </span><span class="cov0" title="0">{
                        issuerCommonName = firstCert.Issuer.CommonName
                }</span> else<span class="cov0" title="0"> {
                        for _, name := range firstCert.Issuer.Names </span><span class="cov0" title="0">{
                                if name.Type.String() == "2.5.4.3" </span><span class="cov0" title="0">{
                                        issuerCommonName = fmt.Sprintf("%v", name.Value)
                                }</span>
                        }
                }

                <span class="cov0" title="0">return &amp;CertInfo{
                        DNSNames:         firstCert.DNSNames,
                        NotAfter:         earliestExpiration,
                        NotBefore:        latestNotBefore,
                        IssuerCommonName: issuerCommonName,
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// CertInfo is the information for a certificate.
type CertInfo struct {
        IssuerCommonName string
        DNSNames         []string
        NotAfter         time.Time
        NotBefore        time.Time
}
</pre>
		
		<pre class="file" id="file82" style="display: none">package request

import (
        "bytes"
        "fmt"
        "io/ioutil"
        "net/http"
        "os"
        "time"
)

var (
        isMocked bool
        mocks    = map[uint32]MockedResponseGenerator{}
        catchAll MockedResponseGenerator
)

// MockedResponse is the metadata and response body for a response
type MockedResponse struct {
        Meta ResponseMeta
        Res  []byte
        Err  error
}

// Response returns a response object for the mock response.
func (mr MockedResponse) Response() *http.Response <span class="cov8" title="1">{
        buff := bytes.NewBuffer(mr.Res)
        res := http.Response{}
        buffLen := buff.Len()
        res.Body = ioutil.NopCloser(buff)
        res.ContentLength = int64(buffLen)
        res.Header = mr.Meta.Headers
        res.StatusCode = mr.Meta.StatusCode
        return &amp;res
}</span>

// MockedResponseGenerator is a function that returns a mocked response.
type MockedResponseGenerator func(*Request) MockedResponse

// MockedResponseInjector injects the mocked response into the request response.
func MockedResponseInjector(req *Request) *MockedResponse <span class="cov8" title="1">{
        if !isMocked </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if gen, hasGen := mocks[req.Hash()]; hasGen </span><span class="cov8" title="1">{
                return ref(gen(req))
        }</span>
        <span class="cov0" title="0">if catchAll != nil </span><span class="cov0" title="0">{
                return ref(catchAll(req))
        }</span>
        <span class="cov0" title="0">panic(fmt.Sprintf("no mock registered for %s %s", req.Verb, req.URL().String()))</span>
}

// MockCatchAll sets a "catch all" mock generator.
func MockCatchAll(generator MockedResponseGenerator) <span class="cov0" title="0">{
        isMocked = true
        catchAll = generator
}</span>

// MockResponse mocks are response with a given generator.
func MockResponse(req *Request, generator MockedResponseGenerator) <span class="cov8" title="1">{
        isMocked = true
        reqHashCode := req.Hash()
        mocks[reqHashCode] = generator
}</span>

// MockResponseFromBinary mocks a service request response from a set of binary responses.
func MockResponseFromBinary(req *Request, statusCode int, responseBody []byte) <span class="cov0" title="0">{
        MockResponse(req, func(_ *Request) MockedResponse </span><span class="cov0" title="0">{
                return MockedResponse{
                        Meta: ResponseMeta{
                                StatusCode:    statusCode,
                                ContentLength: int64(len(responseBody)),
                                CompleteTime:  time.Now().UTC(),
                        },
                        Res: responseBody,
                }
        }</span>)
}

// MockResponseFromString mocks a service request response from a string responseBody.
func MockResponseFromString(verb string, url string, statusCode int, responseBody string) <span class="cov0" title="0">{
        MockResponseFromBinary(New().WithVerb(verb).WithURL(url), statusCode, []byte(responseBody))
}</span>

// MockResponseFromFile mocks a service request response from a set of file paths.
func MockResponseFromFile(verb string, url string, statusCode int, responseFilePath string) <span class="cov0" title="0">{
        MockResponse(New().WithVerb(verb).WithURL(url), readFile(statusCode, responseFilePath))
}</span>

// ClearMockedResponses clears any mocked responses that have been set up for the test.
func ClearMockedResponses() <span class="cov8" title="1">{
        isMocked = false
        catchAll = nil
        mocks = map[uint32]MockedResponseGenerator{}
}</span>

func readFile(statusCode int, filePath string) MockedResponseGenerator <span class="cov0" title="0">{
        return func(_ *Request) MockedResponse </span><span class="cov0" title="0">{
                f, err := os.Open(filePath)
                if err != nil </span><span class="cov0" title="0">{
                        return MockedResponse{
                                Meta: ResponseMeta{
                                        StatusCode: http.StatusInternalServerError,
                                },
                                Err: err,
                        }
                }</span>
                <span class="cov0" title="0">defer f.Close()

                contents, err := ioutil.ReadAll(f)
                if err != nil </span><span class="cov0" title="0">{
                        return MockedResponse{
                                Meta: ResponseMeta{
                                        StatusCode: http.StatusInternalServerError,
                                },
                                Err: err,
                        }
                }</span>

                <span class="cov0" title="0">return MockedResponse{
                        Meta: ResponseMeta{
                                StatusCode:    statusCode,
                                ContentLength: int64(len(contents)),
                        },
                        Res: contents,
                }</span>
        }
}

func ref(res MockedResponse) *MockedResponse <span class="cov8" title="1">{
        return &amp;res
}</span>
</pre>
		
		<pre class="file" id="file83" style="display: none">package request

import (
        "bytes"
        "context"
        "crypto/tls"
        "crypto/x509"
        "encoding/json"
        "encoding/xml"
        "fmt"
        "hash/fnv"
        "io"
        "io/ioutil"
        "net"
        "net/http"
        "net/http/httptrace"
        "net/url"
        "time"

        "github.com/blend/go-sdk/exception"
        "github.com/blend/go-sdk/logger"
        "github.com/blend/go-sdk/util"
)

// Get returns a new get request.
func Get(url string) *Request <span class="cov0" title="0">{
        return New().AsGet().WithURL(url)
}</span>

// Post returns a new post request with an optional body.
func Post(url string, body []byte) *Request <span class="cov0" title="0">{
        if len(body) &gt; 0 </span><span class="cov0" title="0">{
                return New().AsPost().WithURL(url).WithPostBody(body)
        }</span>
        <span class="cov0" title="0">return New().AsPost().WithURL(url)</span>
}

// New returns a new HTTPRequest instance.
func New() *Request <span class="cov8" title="1">{
        return &amp;Request{
                Scheme:    "http",
                Verb:      "GET",
                KeepAlive: false,
        }
}</span>

// Request makes http requests.
type Request struct {
        Verb string

        Scheme string
        Host   string
        Path   string

        QueryString url.Values

        Cookies []*http.Cookie

        Header            http.Header
        BasicAuthUsername string
        BasicAuthPassword string

        ContentType string
        PostData    url.Values
        Body        []byte

        Timeout time.Duration

        TLSClientCertPath string
        TLSClientKeyPath  string
        TLSClientCert     []byte
        TLSClientKey      []byte
        TLSSkipVerify     bool

        TLSCAPool *x509.CertPool

        KeepAlive        bool
        KeepAliveTimeout time.Duration
        Label            string

        log            *logger.Logger
        state          interface{}
        postedFiles    []PostedFile
        responseBuffer Buffer
        requestStart   time.Time

        err error

        ctx                             context.Context
        trace                           *httptrace.ClientTrace
        transport                       *http.Transport
        createTransportHandler          CreateTransportHandler
        incomingResponseHandler         ResponseHandler
        statefulIncomingResponseHandler StatefulResponseHandler
        outgoingRequestHandler          OutgoingRequestHandler
        mockProvider                    MockedResponseProvider
}

// WithOnResponse configures an event receiver.
func (hr *Request) WithOnResponse(hook ResponseHandler) *Request <span class="cov0" title="0">{
        hr.incomingResponseHandler = hook
        return hr
}</span>

// WithOnResponseStateful configures an event receiver that includes the request state.
func (hr *Request) WithOnResponseStateful(hook StatefulResponseHandler) *Request <span class="cov0" title="0">{
        hr.statefulIncomingResponseHandler = hook
        return hr
}</span>

// WithOnCreateTransport configures an event receiver.
func (hr *Request) WithOnCreateTransport(hook CreateTransportHandler) *Request <span class="cov0" title="0">{
        hr.createTransportHandler = hook
        return hr
}</span>

// WithOnRequest configures an event receiver.
func (hr *Request) WithOnRequest(hook OutgoingRequestHandler) *Request <span class="cov8" title="1">{
        hr.outgoingRequestHandler = hook
        return hr
}</span>

// WithContext sets a context for the request.
func (hr *Request) WithContext(ctx context.Context) *Request <span class="cov0" title="0">{
        hr.ctx = ctx
        return hr
}</span>

// WithClientTrace sets up a trace for the request.
func (hr *Request) WithClientTrace(trace *httptrace.ClientTrace) *Request <span class="cov8" title="1">{
        hr.trace = trace
        return hr
}</span>

// WithState adds a state object to the request for later usage.
func (hr *Request) WithState(state interface{}) *Request <span class="cov0" title="0">{
        hr.state = state
        return hr
}</span>

// WithLabel gives the request a logging label.
func (hr *Request) WithLabel(label string) *Request <span class="cov0" title="0">{
        hr.Label = label
        return hr
}</span>

// WithVerifyTLS skips the bad certificate checking on TLS requests.
func (hr *Request) WithVerifyTLS(shouldVerify bool) *Request <span class="cov0" title="0">{
        hr.TLSSkipVerify = !shouldVerify
        return hr
}</span>

// WithMockProvider mocks a request response.
func (hr *Request) WithMockProvider(provider MockedResponseProvider) *Request <span class="cov8" title="1">{
        hr.mockProvider = provider
        return hr
}</span>

// WithLogger enables logging with HTTPRequestLogLevelErrors.
func (hr *Request) WithLogger(agent *logger.Logger) *Request <span class="cov8" title="1">{
        hr.log = agent
        return hr
}</span>

// Logger returns the request diagnostics agent.
func (hr *Request) Logger() *logger.Logger <span class="cov0" title="0">{
        return hr.log
}</span>

// WithTransport sets a transport for the request.
func (hr *Request) WithTransport(transport *http.Transport) *Request <span class="cov0" title="0">{
        hr.transport = transport
        return hr
}</span>

// WithKeepAlives sets if the request should use the `Connection=keep-alive` header or not.
func (hr *Request) WithKeepAlives() *Request <span class="cov0" title="0">{
        hr.KeepAlive = true
        hr = hr.WithHeader("Connection", "keep-alive")
        return hr
}</span>

// WithKeepAliveTimeout sets a keep alive timeout for the requests transport.
func (hr *Request) WithKeepAliveTimeout(timeout time.Duration) *Request <span class="cov0" title="0">{
        hr.KeepAliveTimeout = timeout
        return hr
}</span>

// WithContentType sets the `Content-Type` header for the request.
func (hr *Request) WithContentType(contentType string) *Request <span class="cov8" title="1">{
        hr.ContentType = contentType
        return hr
}</span>

// WithScheme sets the scheme, or protocol, of the request.
func (hr *Request) WithScheme(scheme string) *Request <span class="cov8" title="1">{
        hr.Scheme = scheme
        return hr
}</span>

// WithHost sets the target url host for the request.
func (hr *Request) WithHost(host string) *Request <span class="cov8" title="1">{
        hr.Host = host
        return hr
}</span>

// WithPath sets the path component of the host url..
func (hr *Request) WithPath(path string) *Request <span class="cov8" title="1">{
        hr.Path = path
        return hr
}</span>

// WithPathf sets the path component of the host url by the format and arguments.
func (hr *Request) WithPathf(format string, args ...interface{}) *Request <span class="cov0" title="0">{
        hr.Path = fmt.Sprintf(format, args...)
        return hr
}</span>

// WithCombinedPath sets the path component of the host url by combining the input path segments.
func (hr *Request) WithCombinedPath(components ...string) *Request <span class="cov0" title="0">{
        hr.Path = util.String.CombinePathComponents(components...)
        return hr
}</span>

// WithURLf sets the url based on a format and args.
func (hr *Request) WithURLf(format string, args ...interface{}) *Request <span class="cov0" title="0">{
        return hr.WithURL(fmt.Sprintf(format, args...))
}</span>

// WithURL sets the request target url whole hog.
func (hr *Request) WithURL(urlString string) *Request <span class="cov8" title="1">{
        workingURL, err := url.Parse(urlString)
        if err != nil </span><span class="cov0" title="0">{
                hr.err = err
                return hr
        }</span>

        <span class="cov8" title="1">hr.Scheme = workingURL.Scheme
        hr.Host = workingURL.Host
        hr.Path = workingURL.Path
        queryValues, err := url.ParseQuery(workingURL.RawQuery)
        if err != nil </span><span class="cov0" title="0">{
                hr.err = err
                return hr
        }</span>
        <span class="cov8" title="1">hr.QueryString = queryValues
        return hr</span>
}

// WithHeader sets a header on the request.
func (hr *Request) WithHeader(field string, value string) *Request <span class="cov8" title="1">{
        if hr.Header == nil </span><span class="cov8" title="1">{
                hr.Header = http.Header{}
        }</span>
        <span class="cov8" title="1">hr.Header.Set(field, value)
        return hr</span>
}

// WithQueryString sets a query string value for the host url of the request.
func (hr *Request) WithQueryString(field string, value string) *Request <span class="cov8" title="1">{
        if hr.QueryString == nil </span><span class="cov8" title="1">{
                hr.QueryString = url.Values{}
        }</span>
        <span class="cov8" title="1">hr.QueryString.Add(field, value)
        return hr</span>
}

// WithCookie sets a cookie for the request.
func (hr *Request) WithCookie(cookie *http.Cookie) *Request <span class="cov8" title="1">{
        if hr.Cookies == nil </span><span class="cov8" title="1">{
                hr.Cookies = []*http.Cookie{}
        }</span>
        <span class="cov8" title="1">hr.Cookies = append(hr.Cookies, cookie)
        return hr</span>
}

// WithPostData sets a post data value for the request.
func (hr *Request) WithPostData(field string, value string) *Request <span class="cov8" title="1">{
        if hr.PostData == nil </span><span class="cov8" title="1">{
                hr.PostData = url.Values{}
        }</span>
        <span class="cov8" title="1">hr.PostData.Add(field, value)
        return hr</span>
}

// WithPostDataFromObject sets the post data for a request as json from a given object.
// Remarks; this differs from `WithJSONBody` in that it sets individual post form fields
// for each member of the object.
func (hr *Request) WithPostDataFromObject(object interface{}) *Request <span class="cov8" title="1">{
        postDatums := util.Reflection.DecomposeToPostDataAsJSON(object)

        for _, item := range postDatums </span><span class="cov8" title="1">{
                hr.WithPostData(item.Key, item.Value)
        }</span>

        <span class="cov8" title="1">return hr</span>
}

// WithPostedFile adds a posted file to the multipart form elements of the request.
func (hr *Request) WithPostedFile(key, fileName string, fileContents io.Reader) *Request <span class="cov0" title="0">{
        hr.postedFiles = append(hr.postedFiles, PostedFile{Key: key, FileName: fileName, FileContents: fileContents})
        return hr
}</span>

// WithBasicAuth sets the basic auth headers for a request.
func (hr *Request) WithBasicAuth(username, password string) *Request <span class="cov8" title="1">{
        hr.BasicAuthUsername = username
        hr.BasicAuthPassword = password
        return hr
}</span>

// WithTimeout sets a timeout for the request.
// Remarks: This timeout is enforced on client connect, not on request read + response.
func (hr *Request) WithTimeout(timeout time.Duration) *Request <span class="cov8" title="1">{
        hr.Timeout = timeout
        return hr
}</span>

// WithClientTLSCertPath sets a tls cert on the transport for the request.
func (hr *Request) WithClientTLSCertPath(certPath string) *Request <span class="cov0" title="0">{
        hr.TLSClientCertPath = certPath
        return hr
}</span>

// WithClientTLSCert sets a tls cert on the transport for the request.
func (hr *Request) WithClientTLSCert(cert []byte) *Request <span class="cov0" title="0">{
        hr.TLSClientCert = cert
        return hr
}</span>

// WithClientTLSKeyPath sets a tls key on the transport for the request.
func (hr *Request) WithClientTLSKeyPath(keyPath string) *Request <span class="cov0" title="0">{
        hr.TLSClientKeyPath = keyPath
        return hr
}</span>

// WithClientTLSKey sets a tls key on the transport for the request.
func (hr *Request) WithClientTLSKey(key []byte) *Request <span class="cov0" title="0">{
        hr.TLSClientKey = key
        return hr
}</span>

// WithTLSRootCAPool sets the root TLS ca pool for the request.
func (hr *Request) WithTLSRootCAPool(certPool *x509.CertPool) *Request <span class="cov0" title="0">{
        hr.TLSCAPool = certPool
        return hr
}</span>

// WithVerb sets the http verb of the request.
func (hr *Request) WithVerb(verb string) *Request <span class="cov8" title="1">{
        hr.Verb = verb
        return hr
}</span>

// AsGet sets the http verb of the request to `GET`.
func (hr *Request) AsGet() *Request <span class="cov8" title="1">{
        hr.Verb = "GET"
        return hr
}</span>

// AsPost sets the http verb of the request to `POST`.
func (hr *Request) AsPost() *Request <span class="cov8" title="1">{
        hr.Verb = "POST"
        return hr
}</span>

// AsPut sets the http verb of the request to `PUT`.
func (hr *Request) AsPut() *Request <span class="cov8" title="1">{
        hr.Verb = "PUT"
        return hr
}</span>

// AsPatch sets the http verb of the request to `PATCH`.
func (hr *Request) AsPatch() *Request <span class="cov8" title="1">{
        hr.Verb = "PATCH"
        return hr
}</span>

// AsDelete sets the http verb of the request to `DELETE`.
func (hr *Request) AsDelete() *Request <span class="cov8" title="1">{
        hr.Verb = "DELETE"
        return hr
}</span>

// AsOptions sets the http verb of the request to `OPTIONS`.
func (hr *Request) AsOptions() *Request <span class="cov0" title="0">{
        hr.Verb = "OPTIONS"
        return hr
}</span>

// WithResponseBuffer sets the response buffer for the request (if you want to re-use one).
// An example is if you're constantly pinging an endpoint with a similarly sized response,
// You can just re-use a buffer for reading the response.
func (hr *Request) WithResponseBuffer(buffer Buffer) *Request <span class="cov0" title="0">{
        hr.responseBuffer = buffer
        return hr
}</span>

// WithPostBodyAsJSON sets the post body raw to be the json representation of an object.
func (hr *Request) WithPostBodyAsJSON(object interface{}) *Request <span class="cov8" title="1">{
        return hr.WithPostBodySerialized(object, serializeJSON).WithContentType("application/json")
}</span>

// WithPostBodyAsXML sets the post body raw to be the xml representation of an object.
func (hr *Request) WithPostBodyAsXML(object interface{}) *Request <span class="cov8" title="1">{
        return hr.WithPostBodySerialized(object, serializeXML).WithContentType("application/xml")
}</span>

// WithPostBodySerialized sets the post body with the results of the given serializer.
func (hr *Request) WithPostBodySerialized(object interface{}, serialize Serializer) *Request <span class="cov8" title="1">{
        body, _ := serialize(object)
        return hr.WithPostBody(body)
}</span>

// WithPostBody sets the post body directly.
func (hr *Request) WithPostBody(body []byte) *Request <span class="cov8" title="1">{
        hr.Body = body
        return hr
}</span>

// URL returns the currently formatted request target url.
func (hr *Request) URL() *url.URL <span class="cov8" title="1">{
        workingURL := &amp;url.URL{Scheme: hr.Scheme, Host: hr.Host, Path: hr.Path}
        workingURL.RawQuery = hr.QueryString.Encode()
        return workingURL
}</span>

// Meta returns the request as a HTTPRequestMeta.
func (hr Request) Meta() *Meta <span class="cov8" title="1">{
        return &amp;Meta{
                StartTime: hr.requestStart,
                Verb:      hr.Verb,
                URL:       hr.URL(),
                Body:      hr.PostBody(),
                Headers:   hr.Headers(),
        }
}</span>

// PostBody returns the current post body.
func (hr Request) PostBody() []byte <span class="cov8" title="1">{
        if len(hr.Body) &gt; 0 </span><span class="cov8" title="1">{
                return hr.Body
        }</span> else<span class="cov8" title="1"> if len(hr.PostData) &gt; 0 </span><span class="cov8" title="1">{
                return []byte(hr.PostData.Encode())
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Headers returns the headers on the request.
func (hr Request) Headers() http.Header <span class="cov8" title="1">{
        headers := http.Header{}
        for key, values := range hr.Header </span><span class="cov8" title="1">{
                for _, value := range values </span><span class="cov8" title="1">{
                        headers.Set(key, value)
                }</span>
        }
        <span class="cov8" title="1">if len(hr.PostData) &gt; 0 </span><span class="cov8" title="1">{
                headers.Set("Content-Type", "application/x-www-form-urlencoded")
        }</span>
        <span class="cov8" title="1">if !isEmpty(hr.ContentType) </span><span class="cov8" title="1">{
                headers.Set("Content-Type", hr.ContentType)
        }</span>
        <span class="cov8" title="1">return headers</span>
}

// Request returns a http.Request for the HTTPRequest.
func (hr *Request) Request() (*http.Request, error) <span class="cov8" title="1">{
        if hr.err != nil </span><span class="cov0" title="0">{
                return nil, hr.err
        }</span>

        <span class="cov8" title="1">workingURL := hr.URL()

        if len(hr.Body) &gt; 0 &amp;&amp; len(hr.PostData) &gt; 0 </span><span class="cov0" title="0">{
                return nil, exception.New("Cant set both a body and have post data.")
        }</span>

        <span class="cov8" title="1">req, err := http.NewRequest(hr.Verb, workingURL.String(), bytes.NewBuffer(hr.PostBody()))
        if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>

        <span class="cov8" title="1">if hr.ctx != nil </span><span class="cov0" title="0">{
                req = req.WithContext(hr.ctx)
        }</span>

        <span class="cov8" title="1">if hr.trace != nil </span><span class="cov8" title="1">{
                req = req.WithContext(httptrace.WithClientTrace(req.Context(), hr.trace))
        }</span>

        <span class="cov8" title="1">if !isEmpty(hr.BasicAuthUsername) </span><span class="cov8" title="1">{
                req.SetBasicAuth(hr.BasicAuthUsername, hr.BasicAuthPassword)
        }</span>

        <span class="cov8" title="1">if hr.Cookies != nil </span><span class="cov8" title="1">{
                for i := 0; i &lt; len(hr.Cookies); i++ </span><span class="cov8" title="1">{
                        cookie := hr.Cookies[i]
                        req.AddCookie(cookie)
                }</span>
        }

        <span class="cov8" title="1">for key, values := range hr.Headers() </span><span class="cov8" title="1">{
                for _, value := range values </span><span class="cov8" title="1">{
                        req.Header.Set(key, value)
                }</span>
        }

        <span class="cov8" title="1">return req, nil</span>
}

// Response makes the actual request but returns the underlying http.Response object.
func (hr *Request) Response() (*http.Response, error) <span class="cov8" title="1">{
        req, err := hr.Request()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">hr.logRequest()

        if hr.mockProvider != nil </span><span class="cov8" title="1">{
                mockedRes := hr.mockProvider(hr)
                if mockedRes != nil </span><span class="cov8" title="1">{
                        return mockedRes.Response(), mockedRes.Err
                }</span>
        }

        <span class="cov8" title="1">client := &amp;http.Client{}
        if hr.requiresCustomTransport() </span><span class="cov0" title="0">{
                transport, transportErr := hr.getTransport()
                if transportErr != nil </span><span class="cov0" title="0">{
                        return nil, exception.Wrap(transportErr)
                }</span>
                <span class="cov0" title="0">client.Transport = transport</span>
        }

        <span class="cov8" title="1">if hr.Timeout != time.Duration(0) </span><span class="cov8" title="1">{
                client.Timeout = hr.Timeout
        }</span>

        <span class="cov8" title="1">res, resErr := client.Do(req)
        return res, exception.Wrap(resErr)</span>
}

// Execute makes the request but does not read the response.
func (hr *Request) Execute() error <span class="cov0" title="0">{
        _, err := hr.ExecuteWithMeta()
        return exception.Wrap(err)
}</span>

// ExecuteWithMeta makes the request and returns the meta of the response.
func (hr *Request) ExecuteWithMeta() (*ResponseMeta, error) <span class="cov0" title="0">{
        res, err := hr.Response()
        if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>
        <span class="cov0" title="0">meta := NewResponseMeta(res)
        if res != nil &amp;&amp; res.Body != nil </span><span class="cov0" title="0">{
                defer res.Body.Close()
                if hr.responseBuffer != nil </span><span class="cov0" title="0">{
                        contentLength, err := hr.responseBuffer.ReadFrom(res.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, exception.Wrap(err)
                        }</span>
                        <span class="cov0" title="0">meta.ContentLength = contentLength
                        if hr.incomingResponseHandler != nil </span><span class="cov0" title="0">{
                                hr.logResponse(meta, hr.responseBuffer.Bytes(), hr.state)
                        }</span>
                } else<span class="cov0" title="0"> {
                        contents, err := ioutil.ReadAll(res.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, exception.Wrap(err)
                        }</span>
                        <span class="cov0" title="0">meta.ContentLength = int64(len(contents))
                        hr.logResponse(meta, contents, hr.state)</span>
                }
        }

        <span class="cov0" title="0">return meta, nil</span>
}

// BytesWithMeta fetches the response as bytes with meta.
func (hr *Request) BytesWithMeta() ([]byte, *ResponseMeta, error) <span class="cov8" title="1">{
        res, err := hr.Response()
        resMeta := NewResponseMeta(res)
        if err != nil </span><span class="cov0" title="0">{
                return nil, resMeta, exception.Wrap(err)
        }</span>
        <span class="cov8" title="1">defer res.Body.Close()

        bytes, readErr := ioutil.ReadAll(res.Body)
        if readErr != nil </span><span class="cov0" title="0">{
                return nil, resMeta, exception.Wrap(readErr)
        }</span>

        <span class="cov8" title="1">resMeta.ContentLength = int64(len(bytes))
        hr.logResponse(resMeta, bytes, hr.state)
        return bytes, resMeta, nil</span>
}

// Bytes fetches the response as bytes.
func (hr *Request) Bytes() ([]byte, error) <span class="cov0" title="0">{
        contents, _, err := hr.BytesWithMeta()
        return contents, err
}</span>

// String returns the body of the response as a string.
func (hr *Request) String() (string, error) <span class="cov0" title="0">{
        responseStr, _, err := hr.StringWithMeta()
        return responseStr, err
}</span>

// StringWithMeta returns the body of the response as a string in addition to the response metadata.
func (hr *Request) StringWithMeta() (string, *ResponseMeta, error) <span class="cov8" title="1">{
        contents, meta, err := hr.BytesWithMeta()
        return string(contents), meta, err
}</span>

// JSON unmarshals the response as json to an object.
func (hr *Request) JSON(destination interface{}) error <span class="cov8" title="1">{
        _, err := hr.deserialize(newJSONDeserializer(destination))
        return err
}</span>

// JSONWithMeta unmarshals the response as json to an object with metadata.
func (hr *Request) JSONWithMeta(destination interface{}) (*ResponseMeta, error) <span class="cov8" title="1">{
        return hr.deserialize(newJSONDeserializer(destination))
}</span>

// JSONWithErrorHandler unmarshals the response as json to an object with metadata or an error object depending on the meta.
func (hr *Request) JSONWithErrorHandler(successObject interface{}, errorObject interface{}) (*ResponseMeta, error) <span class="cov8" title="1">{
        return hr.deserializeWithError(newJSONDeserializer(successObject), newJSONDeserializer(errorObject))
}</span>

// JSONError unmarshals the response as json to an object if the meta indiciates an error.
func (hr *Request) JSONError(errorObject interface{}) (*ResponseMeta, error) <span class="cov0" title="0">{
        return hr.deserializeWithError(nil, newJSONDeserializer(errorObject))
}</span>

// XML unmarshals the response as xml to an object with metadata.
func (hr *Request) XML(destination interface{}) error <span class="cov0" title="0">{
        _, err := hr.deserialize(newXMLDeserializer(destination))
        return err
}</span>

// XMLWithMeta unmarshals the response as xml to an object with metadata.
func (hr *Request) XMLWithMeta(destination interface{}) (*ResponseMeta, error) <span class="cov8" title="1">{
        return hr.deserialize(newXMLDeserializer(destination))
}</span>

// XMLWithErrorHandler unmarshals the response as xml to an object with metadata or an error object depending on the meta.
func (hr *Request) XMLWithErrorHandler(successObject interface{}, errorObject interface{}) (*ResponseMeta, error) <span class="cov0" title="0">{
        return hr.deserializeWithError(newXMLDeserializer(successObject), newXMLDeserializer(errorObject))
}</span>

// Deserialized runs a deserializer with the response.
func (hr *Request) Deserialized(deserialize Deserializer) (*ResponseMeta, error) <span class="cov0" title="0">{
        meta, responseErr := hr.deserialize(func(body []byte) error </span><span class="cov0" title="0">{
                return deserialize(body)
        }</span>)
        <span class="cov0" title="0">return meta, responseErr</span>
}

func (hr *Request) requiresCustomTransport() bool <span class="cov8" title="1">{
        return (!isEmpty(hr.TLSClientCertPath) &amp;&amp; !isEmpty(hr.TLSClientKeyPath)) ||
                (!isEmpty(string(hr.TLSClientCert)) &amp;&amp; !isEmpty(string(hr.TLSClientKey))) ||
                hr.TLSCAPool != nil ||
                hr.transport != nil ||
                hr.createTransportHandler != nil ||
                hr.TLSSkipVerify
}</span>

func (hr *Request) getTransport() (*http.Transport, error) <span class="cov0" title="0">{
        if hr.transport != nil </span><span class="cov0" title="0">{
                return hr.transport, nil
        }</span>
        <span class="cov0" title="0">return hr.Transport()</span>
}

// Transport returns the the custom transport for the request.
func (hr *Request) Transport() (*http.Transport, error) <span class="cov0" title="0">{
        transport := &amp;http.Transport{
                DisableCompression: false,
                DisableKeepAlives:  !hr.KeepAlive,
        }

        dialer := &amp;net.Dialer{}
        if hr.Timeout != time.Duration(0) </span><span class="cov0" title="0">{
                dialer.Timeout = hr.Timeout
        }</span>

        <span class="cov0" title="0">if hr.KeepAlive </span><span class="cov0" title="0">{
                if hr.KeepAliveTimeout != time.Duration(0) </span><span class="cov0" title="0">{
                        dialer.KeepAlive = hr.KeepAliveTimeout
                }</span> else<span class="cov0" title="0"> {
                        dialer.KeepAlive = 30 * time.Second
                }</span>
        }

        <span class="cov0" title="0">transport.Dial = dialer.Dial

        if (!isEmpty(hr.TLSClientCertPath) &amp;&amp; !isEmpty(hr.TLSClientKeyPath)) || !isEmpty(string(hr.TLSClientCert)) &amp;&amp; !isEmpty(string(hr.TLSClientKey)) </span><span class="cov0" title="0">{
                var cert tls.Certificate
                var err error

                if !isEmpty(hr.TLSClientCertPath) </span><span class="cov0" title="0">{
                        cert, err = tls.LoadX509KeyPair(hr.TLSClientCertPath, hr.TLSClientKeyPath)
                }</span> else<span class="cov0" title="0"> {
                        cert, err = tls.X509KeyPair(hr.TLSClientCert, hr.TLSClientKey)
                }</span>
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, exception.Wrap(err)
                }</span>
                <span class="cov0" title="0">tlsConfig := &amp;tls.Config{
                        RootCAs:            hr.TLSCAPool,
                        InsecureSkipVerify: hr.TLSSkipVerify,
                        Certificates:       []tls.Certificate{cert},
                }
                transport.TLSClientConfig = tlsConfig</span>
        } else<span class="cov0" title="0"> {
                tlsConfig := &amp;tls.Config{
                        RootCAs:            hr.TLSCAPool,
                        InsecureSkipVerify: hr.TLSSkipVerify,
                }
                transport.TLSClientConfig = tlsConfig
        }</span>

        <span class="cov0" title="0">if hr.createTransportHandler != nil </span><span class="cov0" title="0">{
                hr.createTransportHandler(hr.URL(), transport)
        }</span>

        <span class="cov0" title="0">return transport, nil</span>
}

func (hr *Request) deserialize(handler Deserializer) (*ResponseMeta, error) <span class="cov8" title="1">{
        res, err := hr.Response()
        meta := NewResponseMeta(res)

        if err != nil </span><span class="cov0" title="0">{
                return meta, exception.Wrap(err)
        }</span>
        <span class="cov8" title="1">defer res.Body.Close()

        body, err := ioutil.ReadAll(res.Body)
        if err != nil </span><span class="cov0" title="0">{
                return meta, exception.Wrap(err)
        }</span>

        <span class="cov8" title="1">meta.ContentLength = int64(len(body))
        hr.logResponse(meta, body, hr.state)
        if meta.ContentLength &gt; 0 &amp;&amp; handler != nil </span><span class="cov8" title="1">{
                err = handler(body)
        }</span>
        <span class="cov8" title="1">return meta, exception.Wrap(err)</span>
}

func (hr *Request) deserializeWithError(okHandler Deserializer, errorHandler Deserializer) (*ResponseMeta, error) <span class="cov8" title="1">{
        res, err := hr.Response()
        meta := NewResponseMeta(res)

        if err != nil </span><span class="cov0" title="0">{
                return meta, exception.Wrap(err)
        }</span>
        <span class="cov8" title="1">defer res.Body.Close()

        body, err := ioutil.ReadAll(res.Body)
        if err != nil </span><span class="cov0" title="0">{
                return meta, exception.Wrap(err)
        }</span>

        <span class="cov8" title="1">meta.ContentLength = int64(len(body))
        hr.logResponse(meta, body, hr.state)
        if meta.ContentLength &gt; 0 </span><span class="cov8" title="1">{
                if res.StatusCode == http.StatusOK </span><span class="cov0" title="0">{
                        if okHandler != nil </span><span class="cov0" title="0">{
                                err = okHandler(body)
                        }</span>
                } else<span class="cov8" title="1"> if errorHandler != nil </span><span class="cov8" title="1">{
                        err = errorHandler(body)
                }</span>
        }
        <span class="cov8" title="1">return meta, exception.Wrap(err)</span>
}

func (hr *Request) logRequest() <span class="cov8" title="1">{
        hr.requestStart = time.Now().UTC()

        meta := hr.Meta()
        if hr.outgoingRequestHandler != nil </span><span class="cov8" title="1">{
                hr.outgoingRequestHandler(meta)
        }</span>

        <span class="cov8" title="1">if hr.log != nil </span><span class="cov8" title="1">{
                hr.log.Trigger(Event{
                        ts:  time.Now().UTC(),
                        req: meta,
                })
        }</span>
}

func (hr *Request) logResponse(resMeta *ResponseMeta, responseBody []byte, state interface{}) <span class="cov8" title="1">{
        if hr.statefulIncomingResponseHandler != nil </span><span class="cov0" title="0">{
                hr.statefulIncomingResponseHandler(hr.Meta(), resMeta, responseBody, state)
        }</span>
        <span class="cov8" title="1">if hr.incomingResponseHandler != nil </span><span class="cov0" title="0">{
                hr.incomingResponseHandler(hr.Meta(), resMeta, responseBody)
        }</span>

        <span class="cov8" title="1">if hr.log != nil </span><span class="cov8" title="1">{
                hr.log.Trigger(ResponseEvent{
                        ts:   time.Now().UTC(),
                        req:  hr.Meta(),
                        res:  resMeta,
                        body: responseBody,
                })
        }</span>
}

// Hash / Mock Utility Functions

// Hash returns a hashcode for a request.
func (hr *Request) Hash() uint32 <span class="cov8" title="1">{
        if hr == nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">buffer := bytes.NewBuffer(nil)
        buffer.WriteString(hr.Verb)
        buffer.WriteRune('|')
        buffer.WriteString(hr.URL().String())

        h := fnv.New32a()
        h.Write(buffer.Bytes())
        return h.Sum32()</span>
}

// Equals returns if a request equals another request.
func (hr *Request) Equals(other *Request) bool <span class="cov0" title="0">{
        if other == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if hr.Verb != other.Verb </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if hr.URL().String() != other.URL().String() </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

//--------------------------------------------------------------------------------
// Unexported Utility Functions
//--------------------------------------------------------------------------------

func newJSONDeserializer(object interface{}) Deserializer <span class="cov8" title="1">{
        return func(body []byte) error </span><span class="cov8" title="1">{
                return deserializeJSON(object, body)
        }</span>
}

func newXMLDeserializer(object interface{}) Deserializer <span class="cov8" title="1">{
        return func(body []byte) error </span><span class="cov8" title="1">{
                return deserializeXML(object, body)
        }</span>
}

func deserializeJSON(object interface{}, body []byte) error <span class="cov8" title="1">{
        decoder := json.NewDecoder(bytes.NewBuffer(body))
        decodeErr := decoder.Decode(object)
        return exception.Wrap(decodeErr)
}</span>

func deserializeJSONFromReader(object interface{}, body io.Reader) error <span class="cov0" title="0">{
        decoder := json.NewDecoder(body)
        decodeErr := decoder.Decode(object)
        return exception.Wrap(decodeErr)
}</span>

func serializeJSON(object interface{}) ([]byte, error) <span class="cov8" title="1">{
        return json.Marshal(object)
}</span>

func serializeJSONToReader(object interface{}) (io.Reader, error) <span class="cov0" title="0">{
        buf := bytes.NewBuffer([]byte{})
        encoder := json.NewEncoder(buf)
        err := encoder.Encode(object)
        return buf, err
}</span>

func deserializeXML(object interface{}, body []byte) error <span class="cov8" title="1">{
        return deserializeXMLFromReader(object, bytes.NewBuffer(body))
}</span>

func deserializeXMLFromReader(object interface{}, reader io.Reader) error <span class="cov8" title="1">{
        decoder := xml.NewDecoder(reader)
        return decoder.Decode(object)
}</span>

func serializeXML(object interface{}) ([]byte, error) <span class="cov8" title="1">{
        return xml.Marshal(object)
}</span>

func serializeXMLToReader(object interface{}) (io.Reader, error) <span class="cov0" title="0">{
        buf := bytes.NewBuffer([]byte{})
        encoder := xml.NewEncoder(buf)
        err := encoder.Encode(object)
        return buf, err
}</span>

func isEmpty(str string) bool <span class="cov8" title="1">{
        return len(str) == 0
}</span>
</pre>
		
		<pre class="file" id="file84" style="display: none">package selector

import "strings"

// And is a combination selector.
type And []Selector

// Matches returns if both A and B match the labels.
func (a And) Matches(labels Labels) bool <span class="cov8" title="1">{
        for _, s := range a </span><span class="cov8" title="1">{
                if !s.Matches(labels) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// Validate validates all the selectors in the clause.
func (a And) Validate() (err error) <span class="cov8" title="1">{
        for _, s := range a </span><span class="cov8" title="1">{
                err = s.Validate()
                if err != nil </span><span class="cov8" title="1">{
                        return
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// And returns a string representation for the selector.
func (a And) String() string <span class="cov8" title="1">{
        var childValues []string
        for _, c := range a </span><span class="cov8" title="1">{
                childValues = append(childValues, c.String())
        }</span>
        <span class="cov8" title="1">return strings.Join(childValues, ", ")</span>
}
</pre>
		
		<pre class="file" id="file85" style="display: none">package selector

import "fmt"

// Equals returns if a key strictly equals a value.
type Equals struct {
        Key, Value string
}

// Matches returns the selector result.
func (e Equals) Matches(labels Labels) bool <span class="cov8" title="1">{
        if value, hasValue := labels[e.Key]; hasValue </span><span class="cov8" title="1">{
                return e.Value == value
        }</span>
        <span class="cov8" title="1">return false</span>
}

// Validate validates the selector.
func (e Equals) Validate() (err error) <span class="cov8" title="1">{
        err = CheckKey(e.Key)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">err = CheckValue(e.Value)
        return</span>
}

// String returns the string representation of the selector.
func (e Equals) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s == %s", e.Key, e.Value)
}</span>
</pre>
		
		<pre class="file" id="file86" style="display: none">package selector

// HasKey returns if a label set has a given key.
type HasKey string

// Matches returns the selector result.
func (hk HasKey) Matches(labels Labels) bool <span class="cov8" title="1">{
        _, hasKey := labels[string(hk)]
        return hasKey
}</span>

// Validate validates the selector.
func (hk HasKey) Validate() (err error) <span class="cov8" title="1">{
        err = CheckKey(string(hk))
        return
}</span>

// String returns a string representation of the selector.
func (hk HasKey) String() string <span class="cov8" title="1">{
        return string(hk)
}</span>
</pre>
		
		<pre class="file" id="file87" style="display: none">package selector

import (
        "fmt"
        "strings"
)

// In returns if a key matches a set of values.
type In struct {
        Key    string
        Values []string
}

// Matches returns the selector result.
func (i In) Matches(labels Labels) bool <span class="cov8" title="1">{
        // if the labels has a given key
        if value, hasValue := labels[i.Key]; hasValue </span><span class="cov8" title="1">{
                // for each selector value
                for _, iv := range i.Values </span><span class="cov8" title="1">{
                        // if they match, return true
                        if iv == value </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
                <span class="cov8" title="1">return false</span>
        }
        <span class="cov8" title="1">return true</span>
}

// Validate validates the selector.
func (i In) Validate() (err error) <span class="cov8" title="1">{
        err = CheckKey(i.Key)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">for _, v := range i.Values </span><span class="cov8" title="1">{
                err = CheckValue(v)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// String returns a string representation of the selector.
func (i In) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s in (%s)", i.Key, strings.Join(i.Values, ", "))
}</span>
</pre>
		
		<pre class="file" id="file88" style="display: none">package selector

import "fmt"

// NotEquals returns if a key strictly equals a value.
type NotEquals struct {
        Key, Value string
}

// Matches returns the selector result.
func (ne NotEquals) Matches(labels Labels) bool <span class="cov8" title="1">{
        if value, hasValue := labels[ne.Key]; hasValue </span><span class="cov8" title="1">{
                return ne.Value != value
        }</span>
        <span class="cov8" title="1">return true</span>
}

// Validate validates the selector.
func (ne NotEquals) Validate() (err error) <span class="cov8" title="1">{
        err = CheckKey(ne.Key)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">err = CheckValue(ne.Value)
        return</span>
}

// String returns a string representation of the selector.
func (ne NotEquals) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s != %s", ne.Key, ne.Value)
}</span>
</pre>
		
		<pre class="file" id="file89" style="display: none">package selector

import "fmt"

// NotHasKey returns if a label set does not have a given key.
type NotHasKey string

// Matches returns the selector result.
func (nhk NotHasKey) Matches(labels Labels) bool <span class="cov8" title="1">{
        if _, hasKey := labels[string(nhk)]; hasKey </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

// Validate validates the selector.
func (nhk NotHasKey) Validate() (err error) <span class="cov8" title="1">{
        err = CheckKey(string(nhk))
        return
}</span>

// String returns a string representation of the selector.
func (nhk NotHasKey) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("!%s", string(nhk))
}</span>
</pre>
		
		<pre class="file" id="file90" style="display: none">package selector

import (
        "fmt"
        "strings"
)

// NotIn returns if a key does not match a set of values.
type NotIn struct {
        Key    string
        Values []string
}

// Matches returns the selector result.
func (ni NotIn) Matches(labels Labels) bool <span class="cov8" title="1">{
        if value, hasValue := labels[ni.Key]; hasValue </span><span class="cov8" title="1">{
                for _, iv := range ni.Values </span><span class="cov8" title="1">{
                        if iv == value </span><span class="cov8" title="1">{
                                // the key does not equal any of the values
                                return false
                        }</span>
                }
        }
        // the value doesn't exist.
        <span class="cov8" title="1">return true</span>
}

// Validate validates the selector.
func (ni NotIn) Validate() (err error) <span class="cov8" title="1">{
        err = CheckKey(ni.Key)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">for _, v := range ni.Values </span><span class="cov0" title="0">{
                err = CheckValue(v)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// String returns a string representation of the selector.
func (ni NotIn) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s notin (%s)", ni.Key, strings.Join(ni.Values, ", "))
}</span>
</pre>
		
		<pre class="file" id="file91" style="display: none">package selector

// Parse takes a string representing a selector and returns a selector
// object, or an error.
// The input will cause an error if it does not follow this form:
//
//  &lt;selector-syntax&gt;         ::= &lt;requirement&gt; | &lt;requirement&gt; "," &lt;selector-syntax&gt;
//  &lt;requirement&gt;             ::= [!] KEY [ &lt;set-based-restriction&gt; | &lt;exact-match-restriction&gt; ]
//  &lt;set-based-restriction&gt;   ::= "" | &lt;inclusion-exclusion&gt; &lt;value-set&gt;
//  &lt;inclusion-exclusion&gt;     ::= &lt;inclusion&gt; | &lt;exclusion&gt;
//  &lt;exclusion&gt;               ::= "notin"
//  &lt;inclusion&gt;               ::= "in"
//  &lt;value-set&gt;               ::= "(" &lt;values&gt; ")"
//  &lt;values&gt;                  ::= VALUE | VALUE "," &lt;values&gt;
//  &lt;exact-match-restriction&gt; ::= ["="|"=="|"!="] VALUE
//
// KEY is a sequence of one or more characters following [ DNS_SUBDOMAIN "/" ] DNS_LABEL. Max length is 63 characters.
// VALUE is a sequence of zero or more characters "([A-Za-z0-9_-\.])". Max length is 63 characters.
// Delimiter is white space: (' ', '\t')
// Example of valid syntax:
//  "x in (foo,,baz),y,z notin ()"
//
// Note:
//  (1) Inclusion - " in " - denotes that the KEY exists and is equal to any of the
//      VALUEs in its requirement
//  (2) Exclusion - " notin " - denotes that the KEY is not equal to any
//      of the VALUEs in its requirement or does not exist
//  (3) The empty string is a valid VALUE
//  (4) A requirement with just a KEY - as in "y" above - denotes that
//      the KEY exists and can be any VALUE.
//  (5) A requirement with just !KEY requires that the KEY not exist.
//
func Parse(query string) (Selector, error) <span class="cov8" title="1">{
        l := &amp;Parser{s: query}
        return l.Parse()
}</span>
</pre>
		
		<pre class="file" id="file92" style="display: none">package selector

import (
        "strings"
        "unicode/utf8"
)

const (
        // OpEquals is an operator.
        OpEquals = "="
        // OpDoubleEquals is an operator.
        OpDoubleEquals = "=="
        // OpNotEquals is an operator.
        OpNotEquals = "!="
        // OpIn is an operator.
        OpIn = "in"
        // OpNotIn is an operator.
        OpNotIn = "notin"
)

// Parser parses a selector incrementally.
type Parser struct {
        // s stores the string to be tokenized
        s string
        // pos is the position currently tokenized
        pos int
        // m is an optional mark
        m int
}

// Parse does the actual parsing.
func (p *Parser) Parse() (Selector, error) <span class="cov8" title="1">{
        p.s = strings.TrimSpace(p.s)
        if len(p.s) == 0 </span><span class="cov8" title="1">{
                return nil, ErrEmptySelector
        }</span>

        <span class="cov8" title="1">var b rune
        var selector Selector
        var err error
        var op string

        // loop over "clauses"
        // clauses are separated by commas and grouped logically as "ands"
        for </span><span class="cov8" title="1">{

                // sniff the !haskey form
                b = p.current()
                if b == Bang </span><span class="cov8" title="1">{
                        p.advance() // we aren't going to use the '!'
                        selector = p.addAnd(selector, p.notHasKey(p.readWord()))
                        if p.done() </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">continue</span>
                }

                // we're done peeking the first char
                <span class="cov8" title="1">key := p.readWord()

                p.mark()

                // check if the next character after the word is a comma
                // this indicates it's a "key" form, or existence check on a key
                b = p.skipToComma()
                if b == Comma || p.isTerminator(b) || p.done() </span><span class="cov8" title="1">{
                        selector = p.addAnd(selector, p.hasKey(key))
                        p.advance()
                        if p.done() </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">continue</span>
                } else<span class="cov8" title="1"> {
                        p.popMark()
                }</span>

                <span class="cov8" title="1">op, err = p.readOp()
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">var subSelector Selector
                switch op </span>{
                case OpEquals, OpDoubleEquals:<span class="cov8" title="1">
                        subSelector, err = p.equals(key)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">selector = p.addAnd(selector, subSelector)</span>
                case OpNotEquals:<span class="cov8" title="1">
                        subSelector, err = p.notEquals(key)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">selector = p.addAnd(selector, subSelector)</span>
                case OpIn:<span class="cov8" title="1">
                        subSelector, err = p.in(key)
                        if err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">selector = p.addAnd(selector, subSelector)</span>
                case OpNotIn:<span class="cov8" title="1">
                        subSelector, err = p.notIn(key)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">selector = p.addAnd(selector, subSelector)</span>
                default:<span class="cov0" title="0">
                        return nil, ErrInvalidOperator</span>
                }

                <span class="cov8" title="1">b = p.skipToComma()
                if b == Comma </span><span class="cov8" title="1">{
                        p.advance()
                        if p.done() </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov8" title="1">continue</span>
                }

                // these two are effectively the same
                <span class="cov8" title="1">if p.isTerminator(b) || p.done() </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">return nil, ErrInvalidSelector</span>
        }

        <span class="cov8" title="1">err = selector.Validate()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return selector, nil</span>
}

// addAnd starts grouping selectors into a high level `and`, returning the aggregate selector.
func (p *Parser) addAnd(current, next Selector) Selector <span class="cov8" title="1">{
        if current == nil </span><span class="cov8" title="1">{
                return next
        }</span>
        <span class="cov8" title="1">if typed, isTyped := current.(And); isTyped </span><span class="cov8" title="1">{
                return append(typed, next)
        }</span>
        <span class="cov8" title="1">return And([]Selector{current, next})</span>
}

func (p *Parser) hasKey(key string) Selector <span class="cov8" title="1">{
        return HasKey(key)
}</span>

func (p *Parser) notHasKey(key string) Selector <span class="cov8" title="1">{
        return NotHasKey(key)
}</span>

func (p *Parser) equals(key string) (Selector, error) <span class="cov8" title="1">{
        value := p.readWord()
        return Equals{Key: key, Value: value}, nil
}</span>

func (p *Parser) notEquals(key string) (Selector, error) <span class="cov8" title="1">{
        value := p.readWord()
        return NotEquals{Key: key, Value: value}, nil
}</span>

func (p *Parser) in(key string) (Selector, error) <span class="cov8" title="1">{
        csv, err := p.readCSV()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return In{Key: key, Values: csv}, nil</span>
}

func (p *Parser) notIn(key string) (Selector, error) <span class="cov8" title="1">{
        csv, err := p.readCSV()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return NotIn{Key: key, Values: csv}, nil</span>
}

// done indicates the cursor is past the usable length of the string.
func (p *Parser) done() bool <span class="cov8" title="1">{
        return p.pos == len(p.s)
}</span>

// mark sets a mark at the current position.
func (p *Parser) mark() <span class="cov8" title="1">{
        p.m = p.pos
}</span>

// popMark moves the cursor back to the previous mark.
func (p *Parser) popMark() <span class="cov8" title="1">{
        if p.m &gt; 0 </span><span class="cov8" title="1">{
                p.pos = p.m
        }</span>
        <span class="cov8" title="1">p.m = 0</span>
}

// read returns the rune currently lexed, and advances the position.
func (p *Parser) read() (r rune) <span class="cov0" title="0">{
        var width int
        if p.pos &lt; len(p.s) </span><span class="cov0" title="0">{
                r, width = utf8.DecodeRuneInString(p.s[p.pos:])
                p.pos += width
        }</span>
        <span class="cov0" title="0">return r</span>
}

// current returns the rune at the current position.
func (p *Parser) current() (r rune) <span class="cov8" title="1">{
        r, _ = utf8.DecodeRuneInString(p.s[p.pos:])
        return
}</span>

// advance moves the cursor forward one rune.
func (p *Parser) advance() <span class="cov8" title="1">{
        if p.pos &lt; len(p.s) </span><span class="cov8" title="1">{
                _, width := utf8.DecodeRuneInString(p.s[p.pos:])
                p.pos += width
        }</span>
}

// prev moves the cursor back a rune.
func (p *Parser) prev() <span class="cov0" title="0">{
        if p.pos &gt; 0 </span><span class="cov0" title="0">{
                p.pos--
        }</span>
}

// readOp reads a valid operator.
// valid operators include:
// [ =, ==, !=, in, notin ]
// errors if it doesn't read one of the above, or there is another structural issue.
func (p *Parser) readOp() (string, error) <span class="cov8" title="1">{
        // skip preceding whitespace
        p.skipWhiteSpace()

        var state int
        var ch rune
        var op []rune
        for </span><span class="cov8" title="1">{
                ch = p.current()

                switch state </span>{
                case 0:<span class="cov8" title="1"> // initial state, determine what op we're reading for
                        if ch == Equal </span><span class="cov8" title="1">{
                                state = 1
                                break</span>
                        }
                        <span class="cov8" title="1">if ch == Bang </span><span class="cov8" title="1">{
                                state = 2
                                break</span>
                        }
                        <span class="cov8" title="1">if ch == 'i' </span><span class="cov8" title="1">{
                                state = 6
                                break</span>
                        }
                        <span class="cov8" title="1">if ch == 'n' </span><span class="cov8" title="1">{
                                state = 7
                                break</span>
                        }
                        <span class="cov0" title="0">return "", ErrInvalidOperator</span>
                case 1:<span class="cov8" title="1"> // =
                        if p.isWhitespace(ch) || p.isAlpha(ch) || ch == Comma </span><span class="cov8" title="1">{
                                return string(op), nil
                        }</span>
                        <span class="cov8" title="1">if ch == Equal </span><span class="cov8" title="1">{
                                op = append(op, ch)
                                p.advance()
                                return string(op), nil
                        }</span>
                        <span class="cov8" title="1">return "", ErrInvalidOperator</span>
                case 2:<span class="cov8" title="1"> // !
                        if ch == Equal </span><span class="cov8" title="1">{
                                op = append(op, ch)
                                p.advance()
                                return string(op), nil
                        }</span>
                        <span class="cov0" title="0">return "", ErrInvalidOperator</span>
                case 6:<span class="cov8" title="1"> // in
                        if ch == 'n' </span><span class="cov8" title="1">{
                                op = append(op, ch)
                                p.advance()
                                return string(op), nil
                        }</span>
                        <span class="cov0" title="0">return "", ErrInvalidOperator</span>
                case 7:<span class="cov8" title="1"> // o
                        if ch == 'o' </span><span class="cov8" title="1">{
                                state = 8
                                break</span>
                        }
                        <span class="cov0" title="0">return "", ErrInvalidOperator</span>
                case 8:<span class="cov8" title="1"> // t
                        if ch == 't' </span><span class="cov8" title="1">{
                                state = 9
                                break</span>
                        }
                        <span class="cov0" title="0">return "", ErrInvalidOperator</span>
                case 9:<span class="cov8" title="1"> // i
                        if ch == 'i' </span><span class="cov8" title="1">{
                                state = 10
                                break</span>
                        }
                        <span class="cov0" title="0">return "", ErrInvalidOperator</span>
                case 10:<span class="cov8" title="1"> // n
                        if ch == 'n' </span><span class="cov8" title="1">{
                                op = append(op, ch)
                                p.advance()
                                return string(op), nil
                        }</span>
                        <span class="cov0" title="0">return "", ErrInvalidOperator</span>
                }

                <span class="cov8" title="1">op = append(op, ch)
                p.advance()

                if p.done() </span><span class="cov8" title="1">{
                        return string(op), nil
                }</span>
        }
}

// readWord skips whitespace, then reads a word until whitespace or a token.
// it will leave the cursor on the next char after the word, i.e. the space or token.
func (p *Parser) readWord() string <span class="cov8" title="1">{
        // skip preceding whitespace
        p.skipWhiteSpace()

        var word []rune
        var ch rune
        for </span><span class="cov8" title="1">{
                ch = p.current()

                if p.isWhitespace(ch) </span><span class="cov8" title="1">{
                        return string(word)
                }</span>
                <span class="cov8" title="1">if p.isSpecialSymbol(ch) </span><span class="cov8" title="1">{
                        return string(word)
                }</span>

                <span class="cov8" title="1">word = append(word, ch)
                p.advance()

                if p.done() </span><span class="cov8" title="1">{
                        return string(word)
                }</span>
        }
}

func (p *Parser) readCSV() (results []string, err error) <span class="cov8" title="1">{
        // skip preceding whitespace
        p.skipWhiteSpace()

        var word []rune
        var ch rune
        var state int

        for </span><span class="cov8" title="1">{
                ch = p.current()

                if p.done() </span><span class="cov8" title="1">{
                        err = ErrInvalidSelector
                        return
                }</span>

                <span class="cov8" title="1">switch state </span>{
                case 0:<span class="cov8" title="1"> // leading paren
                        if ch == OpenParens </span><span class="cov8" title="1">{
                                state = 2 // spaces or alphas
                                p.advance()
                                continue</span>
                        }
                        // not open parens, bail
                        <span class="cov8" title="1">err = ErrInvalidSelector
                        return</span>
                case 1:<span class="cov8" title="1"> // alphas (in word)

                        if ch == Comma </span><span class="cov8" title="1">{
                                if len(word) &gt; 0 </span><span class="cov8" title="1">{
                                        results = append(results, string(word))
                                        word = nil
                                }</span>
                                <span class="cov8" title="1">state = 2 // from comma
                                p.advance()
                                continue</span>
                        }

                        <span class="cov8" title="1">if ch == CloseParens </span><span class="cov8" title="1">{
                                if len(word) &gt; 0 </span><span class="cov8" title="1">{
                                        results = append(results, string(word))
                                }</span>
                                <span class="cov8" title="1">p.advance()
                                return</span>
                        }

                        <span class="cov8" title="1">if p.isWhitespace(ch) </span><span class="cov8" title="1">{
                                state = 3
                                p.advance()
                                continue</span>
                        }

                        <span class="cov8" title="1">if !p.isValidValue(ch) </span><span class="cov0" title="0">{
                                err = ErrInvalidSelector
                                return
                        }</span>

                        <span class="cov8" title="1">word = append(word, ch)
                        p.advance()
                        continue</span>

                case 2:<span class="cov8" title="1"> //whitespace after symbol

                        if ch == CloseParens </span><span class="cov8" title="1">{
                                p.advance()
                                return
                        }</span>

                        <span class="cov8" title="1">if p.isWhitespace(ch) </span><span class="cov8" title="1">{
                                p.advance()
                                continue</span>
                        }

                        <span class="cov8" title="1">if ch == Comma </span><span class="cov8" title="1">{
                                p.advance()
                                continue</span>
                        }

                        <span class="cov8" title="1">if p.isAlpha(ch) </span><span class="cov8" title="1">{
                                state = 1
                                continue</span>
                        }

                        <span class="cov0" title="0">err = ErrInvalidSelector
                        return</span>

                case 3:<span class="cov8" title="1"> //whitespace after alpha

                        if ch == CloseParens </span><span class="cov0" title="0">{
                                if len(word) &gt; 0 </span><span class="cov0" title="0">{
                                        results = append(results, string(word))
                                }</span>
                                <span class="cov0" title="0">p.advance()
                                return</span>
                        }

                        <span class="cov8" title="1">if p.isWhitespace(ch) </span><span class="cov0" title="0">{
                                p.advance()
                                continue</span>
                        }

                        <span class="cov8" title="1">if ch == Comma </span><span class="cov0" title="0">{
                                if len(word) &gt; 0 </span><span class="cov0" title="0">{
                                        results = append(results, string(word))
                                        word = nil
                                }</span>
                                <span class="cov0" title="0">p.advance()
                                state = 2
                                continue</span>
                        }

                        <span class="cov8" title="1">err = ErrInvalidSelector
                        return</span>

                }
        }
}

func (p *Parser) skipWhiteSpace() <span class="cov8" title="1">{
        if p.done() </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">var ch rune
        for </span><span class="cov8" title="1">{
                ch = p.current()
                if !p.isWhitespace(ch) </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">p.advance()
                if p.done() </span><span class="cov8" title="1">{
                        return
                }</span>
        }
}

func (p *Parser) skipToComma() (ch rune) <span class="cov8" title="1">{
        if p.done() </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                ch = p.current()
                if ch == Comma </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">if !p.isWhitespace(ch) </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">p.advance()
                if p.done() </span><span class="cov0" title="0">{
                        return
                }</span>
        }
}

// isWhitespace returns true if the rune is a space, tab, or newline.
func (p *Parser) isWhitespace(ch rune) bool <span class="cov8" title="1">{
        return ch == Space || ch == Tab || ch == CarriageReturn || ch == NewLine
}</span>

// isSpecialSymbol returns if the ch is on the selector symbol list.
func (p *Parser) isSpecialSymbol(ch rune) bool <span class="cov8" title="1">{
        return isSelectorSymbol(ch)
}</span>

// isTerminator returns if we've reached the end of the string
func (p *Parser) isTerminator(ch rune) bool <span class="cov8" title="1">{
        return ch == 0
}</span>

func (p *Parser) isAlpha(ch rune) bool <span class="cov8" title="1">{
        return isAlpha(ch)
}</span>

func (p *Parser) isValidValue(ch rune) bool <span class="cov8" title="1">{
        return isAlpha(ch) || isNameSymbol(ch)
}</span>
</pre>
		
		<pre class="file" id="file93" style="display: none">package selector

import (
        "fmt"
        "unicode"
        "unicode/utf8"
)

const (
        // At is a common rune.
        At = rune('@')
        // Colon is a common rune.
        Colon = rune(':')
        // Dash is a common rune.
        Dash = rune('-')
        // Underscore  is a common rune.
        Underscore = rune('_')
        // Dot is a common rune.
        Dot = rune('.')
        // ForwardSlash is a common rune.
        ForwardSlash = rune('/')
        // BackSlash is a common rune.
        BackSlash = rune('\\')
        // BackTick is a common rune.
        BackTick = rune('`')
        // Bang is a common rune.
        Bang = rune('!')
        // Comma is a common rune.
        Comma = rune(',')
        // OpenBracket is a common rune.
        OpenBracket = rune('[')
        // OpenParens is a common rune.
        OpenParens = rune('(')
        // OpenCurly is a common rune.
        OpenCurly = rune('{')
        // CloseBracket is a common rune.
        CloseBracket = rune(']')
        // CloseParens is a common rune.
        CloseParens = rune(')')
        // Equal is a common rune.
        Equal = rune('=')
        // Space is a common rune.
        Space = rune(' ')
        // Tab is a common rune.
        Tab = rune('\t')
        // Tilde is a common rune.
        Tilde = rune('~')
        // CarriageReturn is a common rune.
        CarriageReturn = rune('\r')
        // NewLine is a common rune.
        NewLine = rune('\n')
)

var (
        // ErrEmptySelector is returned if the selector to be compiled is empty.
        ErrEmptySelector = fmt.Errorf("empty selector")

        // ErrInvalidOperator is returned if the operator is invalid.
        ErrInvalidOperator = fmt.Errorf("invalid operator")

        // ErrInvalidSelector is returned if there is a structural issue with the selector.
        ErrInvalidSelector = fmt.Errorf("invalid selector")

        // ErrKeyEmpty indicates a key is empty.
        ErrKeyEmpty = fmt.Errorf("key empty")

        // ErrKeyTooLong indicates a key is too long.
        ErrKeyTooLong = fmt.Errorf("key too long")

        // ErrKeyDNSPrefixEmpty indicates a key's "dns" prefix is empty.
        ErrKeyDNSPrefixEmpty = fmt.Errorf("key dns prefix empty")

        // ErrKeyDNSPrefixTooLong indicates a key's "dns" prefix is empty.
        ErrKeyDNSPrefixTooLong = fmt.Errorf("key dns prefix too long; must be less than 253 characters")

        // ErrValueTooLong indicates a value is too long.
        ErrValueTooLong = fmt.Errorf("value too long; must be less than 63 characters")

        // ErrKeyInvalidCharacter indicates a key contains characters
        ErrKeyInvalidCharacter = fmt.Errorf(`key contains invalid characters, regex used: ([A-Za-z0-9_-\.])`)

        // MaxDNSPrefixLen is the maximum dns prefix length.
        MaxDNSPrefixLen = 253
        // MaxKeyLen is the maximum key length.
        MaxKeyLen = 63
        // MaxValueLen is the maximum value length.
        MaxValueLen = 63

        // MaxKeyTotalLen is the maximum total key length.
        MaxKeyTotalLen = MaxDNSPrefixLen + MaxKeyLen + 1
)

// CheckLabels validates all the keys and values for the label set.
func CheckLabels(labels Labels) (err error) <span class="cov8" title="1">{
        for key, value := range labels </span><span class="cov8" title="1">{
                err = CheckKey(key)
                if err != nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">err = CheckValue(value)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// CheckKey validates a key.
func CheckKey(key string) (err error) <span class="cov8" title="1">{
        keyLen := len(key)
        if keyLen == 0 </span><span class="cov8" title="1">{
                err = ErrKeyEmpty
                return
        }</span>
        <span class="cov8" title="1">if keyLen &gt; MaxKeyTotalLen </span><span class="cov8" title="1">{
                err = ErrKeyTooLong
                return
        }</span>

        <span class="cov8" title="1">var working []rune
        var state int
        var ch rune
        var width int
        for pos := 0; pos &lt; keyLen; pos += width </span><span class="cov8" title="1">{
                ch, width = utf8.DecodeRuneInString(key[pos:])
                switch state </span>{
                case 0:<span class="cov8" title="1"> // collect dns prefix or key
                        if ch == ForwardSlash </span><span class="cov8" title="1">{
                                err = checkDNS(string(working))
                                if err != nil </span><span class="cov8" title="1">{
                                        return
                                }</span>
                                <span class="cov8" title="1">working = nil
                                state = 1
                                continue</span>
                        }
                }
                <span class="cov8" title="1">working = append(working, ch)
                continue</span>
        }

        <span class="cov8" title="1">if len(working) == 0 </span><span class="cov8" title="1">{
                return ErrKeyEmpty
        }</span>
        <span class="cov8" title="1">if len(working) &gt; MaxKeyLen </span><span class="cov8" title="1">{
                return ErrKeyTooLong
        }</span>

        <span class="cov8" title="1">return checkName(string(working))</span>
}

// CheckValue returns if the value is valid.
func CheckValue(value string) error <span class="cov8" title="1">{
        if len(value) &gt; MaxValueLen </span><span class="cov0" title="0">{
                return ErrValueTooLong
        }</span>
        <span class="cov8" title="1">return checkName(value)</span>
}

func checkName(value string) (err error) <span class="cov8" title="1">{
        valueLen := len(value)
        var state int
        var ch rune
        var width int
        for pos := 0; pos &lt; valueLen; pos += width </span><span class="cov8" title="1">{
                ch, width = utf8.DecodeRuneInString(value[pos:])
                switch state </span>{
                case 0:<span class="cov8" title="1"> //check prefix/suffix
                        if !isAlpha(ch) </span><span class="cov8" title="1">{
                                err = ErrKeyInvalidCharacter
                                return
                        }</span>
                        <span class="cov8" title="1">state = 1
                        continue</span>
                case 1:<span class="cov8" title="1">
                        if !(isNameSymbol(ch) || ch == BackSlash || isAlpha(ch)) </span><span class="cov8" title="1">{
                                err = ErrKeyInvalidCharacter
                                return
                        }</span>
                        <span class="cov8" title="1">if pos == valueLen-2 </span><span class="cov8" title="1">{
                                state = 0
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

func checkDNS(value string) (err error) <span class="cov8" title="1">{
        valueLen := len(value)
        if valueLen == 0 </span><span class="cov8" title="1">{
                err = ErrKeyDNSPrefixEmpty
                return
        }</span>
        <span class="cov8" title="1">if valueLen &gt; MaxDNSPrefixLen </span><span class="cov8" title="1">{
                err = ErrKeyDNSPrefixTooLong
                return
        }</span>
        <span class="cov8" title="1">var state int
        var ch rune
        var width int
        for pos := 0; pos &lt; valueLen; pos += width </span><span class="cov8" title="1">{
                ch, width = utf8.DecodeRuneInString(value[pos:])
                switch state </span>{
                case 0:<span class="cov8" title="1"> //check prefix | suffix
                        if !isLowerAlpha(ch) </span><span class="cov8" title="1">{
                                return ErrKeyInvalidCharacter
                        }</span>
                        <span class="cov8" title="1">state = 1
                        continue</span>
                case 1:<span class="cov8" title="1">
                        if ch == Underscore </span><span class="cov8" title="1">{
                                err = ErrKeyInvalidCharacter
                                return
                        }</span>
                        <span class="cov8" title="1">if isNameSymbol(ch) </span><span class="cov8" title="1">{
                                state = 2
                                continue</span>
                        }
                        <span class="cov8" title="1">if !isLowerAlpha(ch) </span><span class="cov0" title="0">{
                                err = ErrKeyInvalidCharacter
                                return
                        }</span>
                        <span class="cov8" title="1">if pos == valueLen-2 </span><span class="cov8" title="1">{
                                state = 0
                        }</span>
                        <span class="cov8" title="1">continue</span>
                case 2:<span class="cov8" title="1"> // we've hit a dot, dash, or underscore that can't repeat
                        if !isLowerAlpha(ch) </span><span class="cov0" title="0">{
                                err = ErrKeyInvalidCharacter
                                return
                        }</span>
                        <span class="cov8" title="1">if pos == valueLen-2 </span><span class="cov8" title="1">{
                                state = 0
                        }</span>

                        <span class="cov8" title="1">state = 1</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func isWhitespace(ch rune) bool <span class="cov8" title="1">{
        return unicode.IsSpace(ch)
}</span>

func isSelectorSymbol(ch rune) bool <span class="cov8" title="1">{
        switch ch </span>{
        case Equal, Bang, OpenParens, CloseParens, Comma:<span class="cov8" title="1">
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

func isNameSymbol(ch rune) bool <span class="cov8" title="1">{
        switch ch </span>{
        case Dot, Dash, Underscore:<span class="cov8" title="1">
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

func isSymbol(ch rune) bool <span class="cov8" title="1">{
        return (int(ch) &gt;= int(Bang) &amp;&amp; int(ch) &lt;= int(ForwardSlash)) ||
                (int(ch) &gt;= int(Colon) &amp;&amp; int(ch) &lt;= int(At)) ||
                (int(ch) &gt;= int(OpenBracket) &amp;&amp; int(ch) &lt;= int(BackTick)) ||
                (int(ch) &gt;= int(OpenCurly) &amp;&amp; int(ch) &lt;= int(Tilde))
}</span>

func isLowerAlpha(ch rune) bool <span class="cov8" title="1">{
        if unicode.IsLetter(ch) </span><span class="cov8" title="1">{
                return unicode.IsLower(ch)
        }</span>
        <span class="cov8" title="1">return isAlpha(ch)</span>
}

func isAlpha(ch rune) bool <span class="cov8" title="1">{
        return !isWhitespace(ch) &amp;&amp; !unicode.IsControl(ch) &amp;&amp; !isSymbol(ch)
}</span>
</pre>
		
		<pre class="file" id="file94" style="display: none">package semver

import (
        "fmt"
        "reflect"
        "regexp"
        "strings"
)

// Constraint represents a single constraint for a version, such as
// "&gt;= 1.0".
type Constraint struct {
        f        constraintFunc
        check    *Version
        original string
}

// Constraints is a slice of constraints. We make a custom type so that
// we can add methods to it.
type Constraints []*Constraint

type constraintFunc func(v, c *Version) bool

var constraintOperators map[string]constraintFunc

var constraintRegexp *regexp.Regexp

func init() <span class="cov8" title="1">{
        constraintOperators = map[string]constraintFunc{
                "":   constraintEqual,
                "=":  constraintEqual,
                "!=": constraintNotEqual,
                "&gt;":  constraintGreaterThan,
                "&lt;":  constraintLessThan,
                "&gt;=": constraintGreaterThanEqual,
                "&lt;=": constraintLessThanEqual,
                "~&gt;": constraintPessimistic,
        }

        ops := make([]string, 0, len(constraintOperators))
        for k := range constraintOperators </span><span class="cov8" title="1">{
                ops = append(ops, regexp.QuoteMeta(k))
        }</span>

        <span class="cov8" title="1">constraintRegexp = regexp.MustCompile(fmt.Sprintf(
                `^\s*(%s)\s*(%s)\s*$`,
                strings.Join(ops, "|"),
                VersionRegexpRaw))</span>
}

// NewConstraint will parse one or more constraints from the given
// constraint string. The string must be a comma-separated list of
// constraints.
func NewConstraint(v string) (Constraints, error) <span class="cov8" title="1">{
        vs := strings.Split(v, ",")
        result := make([]*Constraint, len(vs))
        for i, single := range vs </span><span class="cov8" title="1">{
                c, err := parseSingle(single)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">result[i] = c</span>
        }

        <span class="cov8" title="1">return Constraints(result), nil</span>
}

// Check tests if a version satisfies all the constraints.
func (cs Constraints) Check(v *Version) bool <span class="cov8" title="1">{
        for _, c := range cs </span><span class="cov8" title="1">{
                if !c.Check(v) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// Returns the string format of the constraints
func (cs Constraints) String() string <span class="cov8" title="1">{
        csStr := make([]string, len(cs))
        for i, c := range cs </span><span class="cov8" title="1">{
                csStr[i] = c.String()
        }</span>

        <span class="cov8" title="1">return strings.Join(csStr, ",")</span>
}

// Check tests if a constraint is validated by the given version.
func (c *Constraint) Check(v *Version) bool <span class="cov8" title="1">{
        return c.f(v, c.check)
}</span>

func (c *Constraint) String() string <span class="cov8" title="1">{
        return c.original
}</span>

func parseSingle(v string) (*Constraint, error) <span class="cov8" title="1">{
        matches := constraintRegexp.FindStringSubmatch(v)
        if matches == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("Malformed constraint: %s", v)
        }</span>

        <span class="cov8" title="1">check, err := NewVersion(matches[2])
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;Constraint{
                f:        constraintOperators[matches[1]],
                check:    check,
                original: v,
        }, nil</span>
}

func prereleaseCheck(v, c *Version) bool <span class="cov8" title="1">{
        switch vPre, cPre := v.Prerelease() != "", c.Prerelease() != ""; </span>{
        case cPre &amp;&amp; vPre:<span class="cov8" title="1">
                // A constraint with a pre-release can only match a pre-release version
                // with the same base segments.
                return reflect.DeepEqual(c.Segments64(), v.Segments64())</span>

        case !cPre &amp;&amp; vPre:<span class="cov8" title="1">
                // A constraint without a pre-release can only match a version without a
                // pre-release.
                return false</span>

        case cPre &amp;&amp; !vPre:</span><span class="cov8" title="1">
                // OK, except with the pessimistic operator
        case !cPre &amp;&amp; !vPre:</span><span class="cov8" title="1">
                // OK
        }
        <span class="cov8" title="1">return true</span>
}

//-------------------------------------------------------------------
// Constraint functions
//-------------------------------------------------------------------

func constraintEqual(v, c *Version) bool <span class="cov8" title="1">{
        return v.Equal(c)
}</span>

func constraintNotEqual(v, c *Version) bool <span class="cov0" title="0">{
        return !v.Equal(c)
}</span>

func constraintGreaterThan(v, c *Version) bool <span class="cov8" title="1">{
        return prereleaseCheck(v, c) &amp;&amp; v.Compare(c) == 1
}</span>

func constraintLessThan(v, c *Version) bool <span class="cov8" title="1">{
        return prereleaseCheck(v, c) &amp;&amp; v.Compare(c) == -1
}</span>

func constraintGreaterThanEqual(v, c *Version) bool <span class="cov8" title="1">{
        return prereleaseCheck(v, c) &amp;&amp; v.Compare(c) &gt;= 0
}</span>

func constraintLessThanEqual(v, c *Version) bool <span class="cov8" title="1">{
        return prereleaseCheck(v, c) &amp;&amp; v.Compare(c) &lt;= 0
}</span>

func constraintPessimistic(v, c *Version) bool <span class="cov8" title="1">{
        // Using a pessimistic constraint with a pre-release, restricts versions to pre-releases
        if !prereleaseCheck(v, c) || (c.Prerelease() != "" &amp;&amp; v.Prerelease() == "") </span><span class="cov8" title="1">{
                return false
        }</span>

        // If the version being checked is naturally less than the constraint, then there
        // is no way for the version to be valid against the constraint
        <span class="cov8" title="1">if v.LessThan(c) </span><span class="cov8" title="1">{
                return false
        }</span>
        // We'll use this more than once, so grab the length now so it's a little cleaner
        // to write the later checks
        <span class="cov8" title="1">cs := len(c.segments)

        // If the version being checked has less specificity than the constraint, then there
        // is no way for the version to be valid against the constraint
        if cs &gt; len(v.segments) </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check the segments in the constraint against those in the version. If the version
        // being checked, at any point, does not have the same values in each index of the
        // constraints segments, then it cannot be valid against the constraint.
        <span class="cov8" title="1">for i := 0; i &lt; c.si-1; i++ </span><span class="cov8" title="1">{
                if v.segments[i] != c.segments[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        // Check the last part of the segment in the constraint. If the version segment at
        // this index is less than the constraints segment at this index, then it cannot
        // be valid against the constraint
        <span class="cov8" title="1">if c.segments[cs-1] &gt; v.segments[cs-1] </span><span class="cov0" title="0">{
                return false
        }</span>

        // If nothing has rejected the version by now, it's valid
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">package semver

import (
        "bytes"
        "fmt"
        "reflect"
        "regexp"
        "strconv"
        "strings"
)

// The compiled regular expression used to test the validity of a version.
var versionRegexp *regexp.Regexp

// VersionRegexpRaw is the raw regular expression string used for
// testing the validity of a version.
const VersionRegexpRaw string = `v?([0-9]+(\.[0-9]+)*?)` +
        `(-?([0-9A-Za-z\-~]+(\.[0-9A-Za-z\-~]+)*))?` +
        `(\+([0-9A-Za-z\-~]+(\.[0-9A-Za-z\-~]+)*))?` +
        `?`

// Version represents a single version.
type Version struct {
        metadata string
        pre      string
        segments []int64
        si       int
}

func init() <span class="cov8" title="1">{
        versionRegexp = regexp.MustCompile("^" + VersionRegexpRaw + "$")
}</span>

// NewVersion parses the given version and returns a new Version.
func NewVersion(v string) (*Version, error) <span class="cov8" title="1">{
        matches := versionRegexp.FindStringSubmatch(v)
        if matches == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("Malformed version: %s", v)
        }</span>
        <span class="cov8" title="1">segmentsStr := strings.Split(matches[1], ".")
        segments := make([]int64, len(segmentsStr))
        si := 0
        for i, str := range segmentsStr </span><span class="cov8" title="1">{
                val, err := strconv.ParseInt(str, 10, 64)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf(
                                "Error parsing version: %s", err)
                }</span>

                <span class="cov8" title="1">segments[i] = int64(val)
                si++</span>
        }

        <span class="cov8" title="1">for i := len(segments); i &lt; 3; i++ </span><span class="cov8" title="1">{
                segments = append(segments, 0)
        }</span>

        <span class="cov8" title="1">return &amp;Version{
                metadata: matches[7],
                pre:      matches[4],
                segments: segments,
                si:       si,
        }, nil</span>
}

// Must is a helper that wraps a call to a function returning (*Version, error)
// and panics if error is non-nil.
func Must(v *Version, err error) *Version <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">return v</span>
}

// Compare compares this version to another version. This
// returns -1, 0, or 1 if this version is smaller, equal,
// or larger than the other version, respectively.
//
// If you want boolean results, use the LessThan, Equal,
// or GreaterThan methods.
func (v *Version) Compare(other *Version) int <span class="cov8" title="1">{
        // A quick, efficient equality check
        if v.String() == other.String() </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">segmentsSelf := v.Segments64()
        segmentsOther := other.Segments64()

        // If the segments are the same, we must compare on prerelease info
        if reflect.DeepEqual(segmentsSelf, segmentsOther) </span><span class="cov8" title="1">{
                preSelf := v.Prerelease()
                preOther := other.Prerelease()
                if preSelf == "" &amp;&amp; preOther == "" </span><span class="cov8" title="1">{
                        return 0
                }</span>
                <span class="cov8" title="1">if preSelf == "" </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">if preOther == "" </span><span class="cov8" title="1">{
                        return -1
                }</span>

                <span class="cov8" title="1">return comparePrereleases(preSelf, preOther)</span>
        }

        // Get the highest specificity (hS), or if they're equal, just use segmentSelf length
        <span class="cov8" title="1">lenSelf := len(segmentsSelf)
        lenOther := len(segmentsOther)
        hS := lenSelf
        if lenSelf &lt; lenOther </span><span class="cov8" title="1">{
                hS = lenOther
        }</span>
        // Compare the segments
        // Because a constraint could have more/less specificity than the version it's
        // checking, we need to account for a lopsided or jagged comparison
        <span class="cov8" title="1">for i := 0; i &lt; hS; i++ </span><span class="cov8" title="1">{
                if i &gt; lenSelf-1 </span><span class="cov8" title="1">{
                        // This means Self had the lower specificity
                        // Check to see if the remaining segments in Other are all zeros
                        if !allZero(segmentsOther[i:]) </span><span class="cov8" title="1">{
                                // if not, it means that Other has to be greater than Self
                                return -1
                        }</span>
                        <span class="cov8" title="1">break</span>
                } else<span class="cov8" title="1"> if i &gt; lenOther-1 </span><span class="cov8" title="1">{
                        // this means Other had the lower specificity
                        // Check to see if the remaining segments in Self are all zeros -
                        if !allZero(segmentsSelf[i:]) </span><span class="cov8" title="1">{
                                //if not, it means that Self has to be greater than Other
                                return 1
                        }</span>
                        <span class="cov8" title="1">break</span>
                }
                <span class="cov8" title="1">lhs := segmentsSelf[i]
                rhs := segmentsOther[i]
                if lhs == rhs </span><span class="cov8" title="1">{
                        continue</span>
                } else<span class="cov8" title="1"> if lhs &lt; rhs </span><span class="cov8" title="1">{
                        return -1
                }</span>
                // Otherwis, rhs was &gt; lhs, they're not equal
                <span class="cov8" title="1">return 1</span>
        }

        // if we got this far, they're equal
        <span class="cov8" title="1">return 0</span>
}

func allZero(segs []int64) bool <span class="cov8" title="1">{
        for _, s := range segs </span><span class="cov8" title="1">{
                if s != 0 </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func comparePart(preSelf string, preOther string) int <span class="cov8" title="1">{
        if preSelf == preOther </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">var selfInt int64
        selfNumeric := true
        selfInt, err := strconv.ParseInt(preSelf, 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                selfNumeric = false
        }</span>

        <span class="cov8" title="1">var otherInt int64
        otherNumeric := true
        otherInt, err = strconv.ParseInt(preOther, 10, 64)
        if err != nil </span><span class="cov8" title="1">{
                otherNumeric = false
        }</span>

        // if a part is empty, we use the other to decide
        <span class="cov8" title="1">if preSelf == "" </span><span class="cov8" title="1">{
                if otherNumeric </span><span class="cov8" title="1">{
                        return -1
                }</span>
                <span class="cov8" title="1">return 1</span>
        }

        <span class="cov8" title="1">if preOther == "" </span><span class="cov8" title="1">{
                if selfNumeric </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov0" title="0">return -1</span>
        }

        <span class="cov8" title="1">if selfNumeric &amp;&amp; !otherNumeric </span><span class="cov8" title="1">{
                return -1
        }</span> else<span class="cov8" title="1"> if !selfNumeric &amp;&amp; otherNumeric </span><span class="cov8" title="1">{
                return 1
        }</span> else<span class="cov8" title="1"> if !selfNumeric &amp;&amp; !otherNumeric &amp;&amp; preSelf &gt; preOther </span><span class="cov8" title="1">{
                return 1
        }</span> else<span class="cov8" title="1"> if selfInt &gt; otherInt </span><span class="cov8" title="1">{
                return 1
        }</span>

        <span class="cov8" title="1">return -1</span>
}

func comparePrereleases(v string, other string) int <span class="cov8" title="1">{
        // the same pre release!
        if v == other </span><span class="cov0" title="0">{
                return 0
        }</span>

        // split both pre releases for analyse their parts
        <span class="cov8" title="1">selfPreReleaseMeta := strings.Split(v, ".")
        otherPreReleaseMeta := strings.Split(other, ".")

        selfPreReleaseLen := len(selfPreReleaseMeta)
        otherPreReleaseLen := len(otherPreReleaseMeta)

        biggestLen := otherPreReleaseLen
        if selfPreReleaseLen &gt; otherPreReleaseLen </span><span class="cov8" title="1">{
                biggestLen = selfPreReleaseLen
        }</span>

        // loop for parts to find the first difference
        <span class="cov8" title="1">for i := 0; i &lt; biggestLen; i = i + 1 </span><span class="cov8" title="1">{
                partSelfPre := ""
                if i &lt; selfPreReleaseLen </span><span class="cov8" title="1">{
                        partSelfPre = selfPreReleaseMeta[i]
                }</span>

                <span class="cov8" title="1">partOtherPre := ""
                if i &lt; otherPreReleaseLen </span><span class="cov8" title="1">{
                        partOtherPre = otherPreReleaseMeta[i]
                }</span>

                <span class="cov8" title="1">compare := comparePart(partSelfPre, partOtherPre)
                // if parts are equals, continue the loop
                if compare != 0 </span><span class="cov8" title="1">{
                        return compare
                }</span>
        }

        <span class="cov0" title="0">return 0</span>
}

// Equal tests if two versions are equal.
func (v *Version) Equal(o *Version) bool <span class="cov8" title="1">{
        return v.Compare(o) == 0
}</span>

// GreaterThan tests if this version is greater than another version.
func (v *Version) GreaterThan(o *Version) bool <span class="cov0" title="0">{
        return v.Compare(o) &gt; 0
}</span>

// LessThan tests if this version is less than another version.
func (v *Version) LessThan(o *Version) bool <span class="cov8" title="1">{
        return v.Compare(o) &lt; 0
}</span>

// Metadata returns any metadata that was part of the version
// string.
//
// Metadata is anything that comes after the "+" in the version.
// For example, with "1.2.3+beta", the metadata is "beta".
func (v *Version) Metadata() string <span class="cov8" title="1">{
        return v.metadata
}</span>

// Prerelease returns any prerelease data that is part of the version,
// or blank if there is no prerelease data.
//
// Prerelease information is anything that comes after the "-" in the
// version (but before any metadata). For example, with "1.2.3-beta",
// the prerelease information is "beta".
func (v *Version) Prerelease() string <span class="cov8" title="1">{
        return v.pre
}</span>

// Segments returns the numeric segments of the version as a slice of ints.
//
// This excludes any metadata or pre-release information. For example,
// for a version "1.2.3-beta", segments will return a slice of
// 1, 2, 3.
func (v *Version) Segments() []int <span class="cov8" title="1">{
        segmentSlice := make([]int, len(v.segments))
        for i, v := range v.segments </span><span class="cov8" title="1">{
                segmentSlice[i] = int(v)
        }</span>
        <span class="cov8" title="1">return segmentSlice</span>
}

// Segments64 returns the numeric segments of the version as a slice of int64s.
//
// This excludes any metadata or pre-release information. For example,
// for a version "1.2.3-beta", segments will return a slice of
// 1, 2, 3.
func (v *Version) Segments64() []int64 <span class="cov8" title="1">{
        return v.segments
}</span>

// String returns the full version string included pre-release
// and metadata information.
func (v *Version) String() string <span class="cov8" title="1">{
        var buf bytes.Buffer
        fmtParts := make([]string, len(v.segments))
        for i, s := range v.segments </span><span class="cov8" title="1">{
                // We can ignore err here since we've pre-parsed the values in segments
                str := strconv.FormatInt(s, 10)
                fmtParts[i] = str
        }</span>
        <span class="cov8" title="1">fmt.Fprintf(&amp;buf, strings.Join(fmtParts, "."))
        if v.pre != "" </span><span class="cov8" title="1">{
                fmt.Fprintf(&amp;buf, "-%s", v.pre)
        }</span>
        <span class="cov8" title="1">if v.metadata != "" </span><span class="cov8" title="1">{
                fmt.Fprintf(&amp;buf, "+%s", v.metadata)
        }</span>

        <span class="cov8" title="1">return buf.String()</span>
}

// Collection is a type that implements the sort.Interface interface
// so that versions can be sorted.
type Collection []*Version

func (v Collection) Len() int <span class="cov8" title="1">{
        return len(v)
}</span>

func (v Collection) Less(i, j int) bool <span class="cov8" title="1">{
        return v[i].LessThan(v[j])
}</span>

func (v Collection) Swap(i, j int) <span class="cov8" title="1">{
        v[i], v[j] = v[j], v[i]
}</span>
</pre>
		
		<pre class="file" id="file96" style="display: none">package template

import (
        "crypto/rand"
        "encoding/base64"
        "io"
        "time"
)

// Helpers is a namespace for helper functions.
type Helpers struct{}

// UTCNow returns the current time in utc.
func (h Helpers) UTCNow() time.Time <span class="cov8" title="1">{
        return time.Now().UTC()
}</span>

// CreateKey creates an encryption key (base64 encoded).
func (h Helpers) CreateKey(keySize int) string <span class="cov8" title="1">{
        key := make([]byte, keySize)
        io.ReadFull(rand.Reader, key)
        return base64.StdEncoding.EncodeToString(key)
}</span>

// UUID returns a uuidv4 as a string.
func (h Helpers) UUID() string <span class="cov0" title="0">{
        return UUIDv4().String()
}</span>
</pre>
		
		<pre class="file" id="file97" style="display: none">package template

import (
        "bytes"
        "errors"
        "fmt"
        "sort"
        "strconv"
        "strings"
)

// NewSemver creates a new Semver.
func NewSemver(version string) (*Semver, error) <span class="cov8" title="1">{
        v := Semver{}

        if err := v.Set(version); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;v, nil</span>
}

// Semver is a semantic version
type Semver struct {
        Major      int64
        Minor      int64
        Patch      int64
        PreRelease PreRelease
        Metadata   string
}

// Set parses and updates v from the given version string. Implements flag.Value
func (v *Semver) Set(version string) error <span class="cov8" title="1">{
        metadata := splitOff(&amp;version, "+")
        preRelease := PreRelease(splitOff(&amp;version, "-"))
        dotParts := strings.SplitN(version, ".", 3)

        if len(dotParts) != 3 </span><span class="cov0" title="0">{
                return fmt.Errorf("%s is not in dotted-tri format", version)
        }</span>

        <span class="cov8" title="1">parsed := make([]int64, 3, 3)

        for i, v := range dotParts[:3] </span><span class="cov8" title="1">{
                val, err := strconv.ParseInt(v, 10, 64)
                parsed[i] = val
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">v.Metadata = metadata
        v.PreRelease = preRelease
        v.Major = parsed[0]
        v.Minor = parsed[1]
        v.Patch = parsed[2]
        return nil</span>
}

func (v Semver) String() string <span class="cov0" title="0">{
        var buffer bytes.Buffer

        fmt.Fprintf(&amp;buffer, "%d.%d.%d", v.Major, v.Minor, v.Patch)

        if v.PreRelease != "" </span><span class="cov0" title="0">{
                fmt.Fprintf(&amp;buffer, "-%s", v.PreRelease)
        }</span>

        <span class="cov0" title="0">if v.Metadata != "" </span><span class="cov0" title="0">{
                fmt.Fprintf(&amp;buffer, "+%s", v.Metadata)
        }</span>

        <span class="cov0" title="0">return buffer.String()</span>
}

// UnmarshalYAML unmarshals a semver to yaml.
func (v *Semver) UnmarshalYAML(unmarshal func(interface{}) error) error <span class="cov0" title="0">{
        var data string
        if err := unmarshal(&amp;data); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return v.Set(data)</span>
}

// MarshalJSON marshals the semver to json.
func (v Semver) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        return []byte(`"` + v.String() + `"`), nil
}</span>

//UnmarshalJSON unmarshals the semver to json.
func (v *Semver) UnmarshalJSON(data []byte) error <span class="cov0" title="0">{
        l := len(data)
        if l == 0 || string(data) == `""` </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if l &lt; 2 || data[0] != '"' || data[l-1] != '"' </span><span class="cov0" title="0">{
                return errors.New("invalid semver string")
        }</span>
        <span class="cov0" title="0">return v.Set(string(data[1 : l-1]))</span>
}

// Compare tests if v is less than, equal to, or greater than versionB,
// returning -1, 0, or +1 respectively.
func (v Semver) Compare(versionB Semver) int <span class="cov0" title="0">{
        if cmp := recursiveCompare(v.Slice(), versionB.Slice()); cmp != 0 </span><span class="cov0" title="0">{
                return cmp
        }</span>
        <span class="cov0" title="0">return preReleaseCompare(v, versionB)</span>
}

// Equal tests if v is equal to versionB.
func (v Semver) Equal(versionB Semver) bool <span class="cov0" title="0">{
        return v.Compare(versionB) == 0
}</span>

// LessThan tests if v is less than versionB.
func (v Semver) LessThan(versionB Semver) bool <span class="cov0" title="0">{
        return v.Compare(versionB) &lt; 0
}</span>

// Slice converts the comparable parts of the semver into a slice of integers.
func (v Semver) Slice() []int64 <span class="cov0" title="0">{
        return []int64{v.Major, v.Minor, v.Patch}
}</span>

// BumpMajor increments the Major field by 1 and resets all other fields to their default values
func (v *Semver) BumpMajor() <span class="cov0" title="0">{
        v.Major++
        v.Minor = 0
        v.Patch = 0
        v.PreRelease = PreRelease("")
        v.Metadata = ""
}</span>

// BumpMinor increments the Minor field by 1 and resets all other fields to their default values
func (v *Semver) BumpMinor() <span class="cov0" title="0">{
        v.Minor++
        v.Patch = 0
        v.PreRelease = PreRelease("")
        v.Metadata = ""
}</span>

// BumpPatch increments the Patch field by 1 and resets all other fields to their default values
func (v *Semver) BumpPatch() <span class="cov0" title="0">{
        v.Patch++
        v.PreRelease = PreRelease("")
        v.Metadata = ""
}</span>

func preReleaseCompare(versionA Semver, versionB Semver) int <span class="cov0" title="0">{
        a := versionA.PreRelease
        b := versionB.PreRelease

        /* Handle the case where if two versions are otherwise equal it is the
         * one without a PreRelease that is greater */
        if len(a) == 0 &amp;&amp; (len(b) &gt; 0) </span><span class="cov0" title="0">{
                return 1
        }</span> else<span class="cov0" title="0"> if len(b) == 0 &amp;&amp; (len(a) &gt; 0) </span><span class="cov0" title="0">{
                return -1
        }</span>

        // If there is a prerelease, check and compare each part.
        <span class="cov0" title="0">return recursivePreReleaseCompare(a.Slice(), b.Slice())</span>
}

func recursiveCompare(versionA []int64, versionB []int64) int <span class="cov0" title="0">{
        if len(versionA) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">a := versionA[0]
        b := versionB[0]

        if a &gt; b </span><span class="cov0" title="0">{
                return 1
        }</span> else<span class="cov0" title="0"> if a &lt; b </span><span class="cov0" title="0">{
                return -1
        }</span>

        <span class="cov0" title="0">return recursiveCompare(versionA[1:], versionB[1:])</span>
}

func recursivePreReleaseCompare(versionA []string, versionB []string) int <span class="cov0" title="0">{
        // A larger set of pre-release fields has a higher precedence than a smaller set,
        // if all of the preceding identifiers are equal.
        if len(versionA) == 0 </span><span class="cov0" title="0">{
                if len(versionB) &gt; 0 </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov0" title="0">return 0</span>
        } else<span class="cov0" title="0"> if len(versionB) == 0 </span><span class="cov0" title="0">{
                // We're longer than versionB so return 1.
                return 1
        }</span>

        <span class="cov0" title="0">a := versionA[0]
        b := versionB[0]

        aInt := false
        bInt := false

        aI, err := strconv.Atoi(versionA[0])
        if err == nil </span><span class="cov0" title="0">{
                aInt = true
        }</span>

        <span class="cov0" title="0">bI, err := strconv.Atoi(versionB[0])
        if err == nil </span><span class="cov0" title="0">{
                bInt = true
        }</span>

        // Numeric identifiers always have lower precedence than non-numeric identifiers.
        <span class="cov0" title="0">if aInt &amp;&amp; !bInt </span><span class="cov0" title="0">{
                return -1
        }</span> else<span class="cov0" title="0"> if !aInt &amp;&amp; bInt </span><span class="cov0" title="0">{
                return 1
        }</span>

        // Handle Integer Comparison
        <span class="cov0" title="0">if aInt &amp;&amp; bInt </span><span class="cov0" title="0">{
                if aI &gt; bI </span><span class="cov0" title="0">{
                        return 1
                }</span> else<span class="cov0" title="0"> if aI &lt; bI </span><span class="cov0" title="0">{
                        return -1
                }</span>
        }

        // Handle String Comparison
        <span class="cov0" title="0">if a &gt; b </span><span class="cov0" title="0">{
                return 1
        }</span> else<span class="cov0" title="0"> if a &lt; b </span><span class="cov0" title="0">{
                return -1
        }</span>

        <span class="cov0" title="0">return recursivePreReleaseCompare(versionA[1:], versionB[1:])</span>
}

// PreRelease is a type alias to string.
type PreRelease string

// Slice returns the dot components of a preprease string.
func (p PreRelease) Slice() []string <span class="cov0" title="0">{
        preRelease := string(p)
        return strings.Split(preRelease, ".")
}</span>

func splitOff(input *string, delim string) (val string) <span class="cov8" title="1">{
        parts := strings.SplitN(*input, delim, 2)

        if len(parts) == 2 </span><span class="cov8" title="1">{
                *input = parts[0]
                val = parts[1]
        }</span>

        <span class="cov8" title="1">return val</span>
}

// Semvers is a collection of semver versions.
type Semvers []*Semver

func (s Semvers) Len() int <span class="cov0" title="0">{
        return len(s)
}</span>

func (s Semvers) Swap(i, j int) <span class="cov0" title="0">{
        s[i], s[j] = s[j], s[i]
}</span>

func (s Semvers) Less(i, j int) bool <span class="cov0" title="0">{
        return s[i].LessThan(*s[j])
}</span>

// Sort sorts the given slice of Semver
func Sort(versions []*Semver) <span class="cov0" title="0">{
        sort.Sort(Semvers(versions))
}</span>
</pre>
		
		<pre class="file" id="file98" style="display: none">package template

import (
        "crypto/sha1"
        "crypto/sha256"
        "crypto/sha512"
        "fmt"
        "io"
        "io/ioutil"
        "os"
        "strings"
        "time"

        "github.com/blend/go-sdk/yaml"

        "encoding/base64"
        "encoding/json"
        "net/url"
        "reflect"
        "regexp"
        "strconv"
        texttemplate "text/template"
)

// Vars is a loose type alias to map[string]interface{}
type Vars = map[string]interface{}

// New creates a new template.
func New() *Template <span class="cov8" title="1">{
        temp := &amp;Template{
                vars: Vars{},
                env:  parseEnvVars(os.Environ()),
        }
        temp.funcs = temp.baseFuncMap()
        return temp
}</span>

// NewFromFile creates a new template from a file.
func NewFromFile(filepath string) (*Template, error) <span class="cov8" title="1">{
        file, err := os.Open(filepath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">contents, err := ioutil.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return New().WithName(filepath).WithBody(string(contents)), nil</span>
}

// Template is a wrapper for html.Template.
type Template struct {
        name       string
        body       string
        vars       Vars
        env        map[string]string
        includes   []string
        funcs      texttemplate.FuncMap
        helpers    Helpers
        leftDelim  string
        rightDelim string
}

// WithName sets the template name.
func (t *Template) WithName(name string) *Template <span class="cov8" title="1">{
        t.name = name
        return t
}</span>

// Name returns the template name if set, or if not set, just "template" as a constant.
func (t *Template) Name() string <span class="cov8" title="1">{
        if len(t.name) &gt; 0 </span><span class="cov8" title="1">{
                return t.name
        }</span>
        <span class="cov8" title="1">return "template"</span>
}

// WithDelims sets the template action delimiters, treating empty string as default delimiter.
func (t *Template) WithDelims(left, right string) *Template <span class="cov8" title="1">{
        t.leftDelim = left
        t.rightDelim = right
        return t
}</span>

// WithBody sets the template body and returns a reference to the template object.
func (t *Template) WithBody(body string) *Template <span class="cov8" title="1">{
        t.body = body
        return t
}</span>

// WithInclude includes a (sub) template into the rendering assets.
func (t *Template) WithInclude(body string) *Template <span class="cov8" title="1">{
        t.includes = append(t.includes, body)
        return t
}</span>

// Body returns the template body.
func (t *Template) Body() string <span class="cov0" title="0">{
        return t.body
}</span>

// WithVar sets a variable and returns a reference to the template object.
func (t *Template) WithVar(key string, value interface{}) *Template <span class="cov8" title="1">{
        t.SetVar(key, value)
        return t
}</span>

// WithVars reads a map of variables into the template.
func (t *Template) WithVars(vars Vars) *Template <span class="cov8" title="1">{
        for key, value := range vars </span><span class="cov8" title="1">{
                t.SetVar(key, value)
        }</span>
        <span class="cov8" title="1">return t</span>
}

// SetVar sets a var in the template.
func (t *Template) SetVar(key string, value interface{}) <span class="cov8" title="1">{
        t.vars[key] = value
}</span>

// HasVar returns if a variable is set.
func (t *Template) HasVar(key string) bool <span class="cov8" title="1">{
        _, hasKey := t.vars[key]
        return hasKey
}</span>

// Var returns the value of a variable, or panics if the variable is not set.
func (t *Template) Var(key string, defaults ...interface{}) (interface{}, error) <span class="cov8" title="1">{
        if value, hasVar := t.vars[key]; hasVar </span><span class="cov8" title="1">{
                return value, nil
        }</span>

        <span class="cov8" title="1">if len(defaults) &gt; 0 </span><span class="cov8" title="1">{
                return defaults[0], nil
        }</span>

        <span class="cov8" title="1">return nil, fmt.Errorf("template variable `%s` is unset and no default is provided", key)</span>
}

// Env returns an environment variable.
func (t *Template) Env(key string, defaults ...string) (string, error) <span class="cov8" title="1">{
        if value, hasVar := t.env[key]; hasVar </span><span class="cov8" title="1">{
                return value, nil
        }</span>

        <span class="cov8" title="1">if len(defaults) &gt; 0 </span><span class="cov8" title="1">{
                return defaults[0], nil
        }</span>

        <span class="cov8" title="1">return "", fmt.Errorf("template env variable `%s` is unset and no default is provided", key)</span>
}

// HasEnv returns if an env var is set.
func (t *Template) HasEnv(key string) bool <span class="cov8" title="1">{
        _, hasKey := t.env[key]
        return hasKey
}</span>

// File returns the contents of a file.
func (t *Template) File(path string) (string, error) <span class="cov8" title="1">{
        contents, err := ioutil.ReadFile(path)
        return string(contents), err
}</span>

// HasFile returns if a file exists.
func (t *Template) HasFile(path string) bool <span class="cov8" title="1">{
        _, err := os.Stat(path)
        return err == nil
}</span>

// Helpers returns the helpers object.
func (t *Template) Helpers() *Helpers <span class="cov8" title="1">{
        return &amp;t.helpers
}</span>

// Process processes the template.
func (t *Template) Process(dst io.Writer) error <span class="cov8" title="1">{
        base := texttemplate.New(t.Name()).Funcs(t.ViewFuncs()).Delims(t.leftDelim, t.rightDelim)

        var err error
        for _, include := range t.includes </span><span class="cov8" title="1">{
                _, err = base.New(t.Name()).Parse(include)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">final, err := base.New(t.Name()).Parse(t.body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return final.Execute(dst, t)</span>
}

// ViewFuncs returns the view funcs.
func (t *Template) ViewFuncs() texttemplate.FuncMap <span class="cov8" title="1">{
        return t.funcs
}</span>

func (t *Template) baseFuncMap() texttemplate.FuncMap <span class="cov8" title="1">{
        return texttemplate.FuncMap{
                "string": func(v interface{}) string </span><span class="cov8" title="1">{
                        return fmt.Sprintf("%v", v)
                }</span>,

                "unix": func(t time.Time) string <span class="cov8" title="1">{
                        return fmt.Sprintf("%d", t.Unix())
                }</span>,
                "rfc3339": func(t time.Time) string <span class="cov0" title="0">{
                        return t.Format(time.RFC3339)
                }</span>,
                "short": func(t time.Time) string <span class="cov0" title="0">{
                        return t.Format("1/02/2006 3:04:05 PM")
                }</span>,
                "short_date": func(t time.Time) string <span class="cov0" title="0">{
                        return t.Format("1/02/2006")
                }</span>,
                "medium": func(t time.Time) string <span class="cov0" title="0">{
                        return t.Format("Jan 02, 2006 3:04:05 PM")
                }</span>,
                "kitchen": func(t time.Time) string <span class="cov0" title="0">{
                        return t.Format(time.Kitchen)
                }</span>,
                "month_day": func(t time.Time) string <span class="cov0" title="0">{
                        return t.Format("1/2")
                }</span>,
                "in": func(loc string, t time.Time) (time.Time, error) <span class="cov0" title="0">{
                        location, err := time.LoadLocation(loc)
                        if err != nil </span><span class="cov0" title="0">{
                                return time.Time{}, err
                        }</span>
                        <span class="cov0" title="0">return t.In(location), err</span>
                },
                "time": func(format, v string) (time.Time, error) <span class="cov8" title="1">{
                        return time.Parse(format, v)
                }</span>,
                "time_unix": func(v int64) time.Time <span class="cov8" title="1">{
                        return time.Unix(v, 0)
                }</span>,
                "year": func(t time.Time) int <span class="cov8" title="1">{
                        return t.Year()
                }</span>,
                "month": func(t time.Time) int <span class="cov0" title="0">{
                        return int(t.Month())
                }</span>,
                "day": func(t time.Time) int <span class="cov8" title="1">{
                        return t.Day()
                }</span>,
                "hour": func(t time.Time) int <span class="cov0" title="0">{
                        return t.Hour()
                }</span>,
                "minute": func(t time.Time) int <span class="cov0" title="0">{
                        return t.Minute()
                }</span>,
                "second": func(t time.Time) int <span class="cov0" title="0">{
                        return t.Second()
                }</span>,
                "millisecond": func(t time.Time) int <span class="cov0" title="0">{
                        return int(time.Duration(t.Nanosecond()) / time.Millisecond)
                }</span>,

                "bool": func(raw interface{}) (bool, error) <span class="cov8" title="1">{
                        v := fmt.Sprintf("%v", raw)
                        if len(v) == 0 </span><span class="cov0" title="0">{
                                return false, nil
                        }</span>
                        <span class="cov8" title="1">switch strings.ToLower(v) </span>{
                        case "true", "1", "yes":<span class="cov8" title="1">
                                return true, nil</span>
                        case "false", "0", "no":<span class="cov0" title="0">
                                return false, nil</span>
                        default:<span class="cov0" title="0">
                                return false, fmt.Errorf("invalid boolean value `%s`", v)</span>
                        }
                },
                "int": func(v interface{}) (int, error) <span class="cov8" title="1">{
                        return strconv.Atoi(fmt.Sprintf("%v", v))
                }</span>,
                "int64": func(v interface{}) (int64, error) <span class="cov8" title="1">{
                        return strconv.ParseInt(fmt.Sprintf("%v", v), 10, 64)
                }</span>,
                "float": func(v string) (float64, error) <span class="cov8" title="1">{
                        return strconv.ParseFloat(v, 64)
                }</span>,

                "money": func(d float64) string <span class="cov8" title="1">{
                        return fmt.Sprintf("$%0.2f", d)
                }</span>,
                "pct": func(d float64) string <span class="cov8" title="1">{
                        return fmt.Sprintf("%0.2f%%", d*100)
                }</span>,

                "base64": func(v string) string <span class="cov8" title="1">{
                        return base64.StdEncoding.EncodeToString([]byte(v))
                }</span>,
                "base64decode": func(v string) (string, error) <span class="cov8" title="1">{
                        result, err := base64.StdEncoding.DecodeString(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov8" title="1">return string(result), nil</span>
                },

                // string transforms
                "upper": func(v string) string <span class="cov8" title="1">{
                        return strings.ToUpper(v)
                }</span>,
                "lower": func(v string) string <span class="cov0" title="0">{
                        return strings.ToLower(v)
                }</span>,
                "title": func(v string) string <span class="cov0" title="0">{
                        return strings.ToTitle(v)
                }</span>,
                "trim": func(v string) string <span class="cov0" title="0">{
                        return strings.TrimSpace(v)
                }</span>,
                "prefix": func(pref, v string) string <span class="cov8" title="1">{
                        return pref + v
                }</span>,
                "suffix": func(suf, v string) string <span class="cov8" title="1">{
                        return v + suf
                }</span>,

                "split": func(sep, v string) []string <span class="cov8" title="1">{
                        return strings.Split(v, sep)
                }</span>,

                "slice": func(from, to int, collection interface{}) (interface{}, error) <span class="cov8" title="1">{
                        value := reflect.ValueOf(collection)

                        if value.Type().Kind() != reflect.Slice </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("input must be a slice")
                        }</span>

                        <span class="cov8" title="1">return value.Slice(from, to).Interface(), nil</span>
                },
                "first": func(collection interface{}) (interface{}, error) <span class="cov8" title="1">{
                        value := reflect.ValueOf(collection)
                        if value.Type().Kind() != reflect.Slice </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("input must be a slice")
                        }</span>
                        <span class="cov8" title="1">if value.Len() == 0 </span><span class="cov0" title="0">{
                                return nil, nil
                        }</span>
                        <span class="cov8" title="1">return value.Index(0).Interface(), nil</span>
                },
                "at": func(index int, collection interface{}) (interface{}, error) <span class="cov8" title="1">{
                        value := reflect.ValueOf(collection)
                        if value.Type().Kind() != reflect.Slice </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("input must be a slice")
                        }</span>
                        <span class="cov8" title="1">if value.Len() == 0 </span><span class="cov0" title="0">{
                                return nil, nil
                        }</span>
                        <span class="cov8" title="1">return value.Index(index).Interface(), nil</span>
                },
                "last": func(collection interface{}) (interface{}, error) <span class="cov8" title="1">{
                        value := reflect.ValueOf(collection)
                        if value.Type().Kind() != reflect.Slice </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("input must be a slice")
                        }</span>
                        <span class="cov8" title="1">if value.Len() == 0 </span><span class="cov0" title="0">{
                                return nil, nil
                        }</span>
                        <span class="cov8" title="1">return value.Index(value.Len() - 1).Interface(), nil</span>
                },
                "join": func(sep string, collection interface{}) (string, error) <span class="cov8" title="1">{
                        value := reflect.ValueOf(collection)
                        if value.Type().Kind() != reflect.Slice </span><span class="cov0" title="0">{
                                return "", fmt.Errorf("input must be a slice")
                        }</span>
                        <span class="cov8" title="1">if value.Len() == 0 </span><span class="cov0" title="0">{
                                return "", nil
                        }</span>
                        <span class="cov8" title="1">values := make([]string, value.Len())
                        for i := 0; i &lt; value.Len(); i++ </span><span class="cov8" title="1">{
                                values[i] = fmt.Sprintf("%v", value.Index(i).Interface())
                        }</span>
                        <span class="cov8" title="1">return strings.Join(values, sep), nil</span>
                },

                // string tests
                "has_suffix": func(suffix, v string) bool <span class="cov8" title="1">{
                        return strings.HasSuffix(v, suffix)
                }</span>,
                "has_prefix": func(prefix, v string) bool <span class="cov8" title="1">{
                        return strings.HasPrefix(v, prefix)
                }</span>,
                "contains": func(substr, v string) bool <span class="cov8" title="1">{
                        return strings.Contains(v, substr)
                }</span>,
                "matches": func(expr, v string) (bool, error) <span class="cov8" title="1">{
                        return regexp.MatchString(expr, v)
                }</span>,

                // url transforms and helpers
                "url": func(v string) (*url.URL, error) <span class="cov0" title="0">{
                        return url.Parse(v)
                }</span>,
                "proto": func(v *url.URL) string <span class="cov0" title="0">{
                        return v.Scheme
                }</span>,
                "host": func(v *url.URL) string <span class="cov0" title="0">{
                        return v.Host
                }</span>,
                "port": func(v *url.URL) string <span class="cov0" title="0">{
                        portValue := v.Port()
                        if len(portValue) &gt; 0 </span><span class="cov0" title="0">{
                                return portValue
                        }</span>
                        <span class="cov0" title="0">switch strings.ToLower(v.Scheme) </span>{
                        case "http":<span class="cov0" title="0">
                                return "80"</span>
                        case "https":<span class="cov0" title="0">
                                return "443"</span>
                        case "ssh":<span class="cov0" title="0">
                                return "22"</span>
                        case "ftp":<span class="cov0" title="0">
                                return "21"</span>
                        case "sftp":<span class="cov0" title="0">
                                return "22"</span>
                        }
                        <span class="cov0" title="0">return ""</span>
                },
                "path": func(v *url.URL) string <span class="cov0" title="0">{
                        return v.Path
                }</span>,
                "rawquery": func(v *url.URL) string <span class="cov0" title="0">{
                        return v.RawQuery
                }</span>,
                "query": func(name string, v *url.URL) string <span class="cov0" title="0">{
                        return v.Query().Get(name)
                }</span>,

                "sha1": func(v string) string <span class="cov8" title="1">{
                        h := sha1.New()
                        io.WriteString(h, v)
                        return fmt.Sprintf("%x", h.Sum(nil))
                }</span>,
                "sha256": func(v string) string <span class="cov8" title="1">{
                        h := sha256.New()
                        io.WriteString(h, v)
                        return fmt.Sprintf("%x", h.Sum(nil))
                }</span>,
                "sha512": func(v string) string <span class="cov8" title="1">{
                        h := sha512.New()
                        io.WriteString(h, v)
                        return fmt.Sprintf("%x", h.Sum(nil))
                }</span>,

                "semver": func(v string) (*Semver, error) <span class="cov8" title="1">{
                        return NewSemver(v)
                }</span>,
                "major": func(v *Semver) int <span class="cov8" title="1">{
                        return int(v.Major)
                }</span>,
                "minor": func(v *Semver) int <span class="cov8" title="1">{
                        return int(v.Minor)
                }</span>,
                "patch": func(v *Semver) int <span class="cov8" title="1">{
                        return int(v.Patch)
                }</span>,
                "prerelease": func(v *Semver) string <span class="cov8" title="1">{
                        return string(v.PreRelease)
                }</span>,

                "yaml": func(v interface{}) (string, error) <span class="cov8" title="1">{
                        data, err := yaml.Marshal(v)
                        return string(data), err
                }</span>,

                "json": func(v interface{}) (string, error) <span class="cov0" title="0">{
                        data, err := json.Marshal(v)
                        return string(data), err
                }</span>,

                "indent": func(tabCount int, v interface{}) string <span class="cov8" title="1">{
                        lines := strings.Split(fmt.Sprintf("%v", v), "\n")
                        outputLines := make([]string, len(lines))

                        var tabs string
                        for i := 0; i &lt; tabCount; i++ </span><span class="cov8" title="1">{
                                tabs = tabs + "\t"
                        }</span>

                        <span class="cov8" title="1">for i := 0; i &lt; len(lines); i++ </span><span class="cov8" title="1">{
                                outputLines[i] = tabs + lines[i]
                        }</span>
                        <span class="cov8" title="1">return strings.Join(outputLines, "\n")</span>
                },

                "indentSpaces": func(spaceCount int, v interface{}) string <span class="cov0" title="0">{
                        lines := strings.Split(fmt.Sprintf("%v", v), "\n")
                        outputLines := make([]string, len(lines))

                        var spaces string
                        for i := 0; i &lt; spaceCount; i++ </span><span class="cov0" title="0">{
                                spaces = spaces + " "
                        }</span>

                        <span class="cov0" title="0">for i := 0; i &lt; len(lines); i++ </span><span class="cov0" title="0">{
                                outputLines[i] = spaces + lines[i]
                        }</span>
                        <span class="cov0" title="0">return strings.Join(outputLines, "\n")</span>
                },
        }
}

func parseEnvVars(envVars []string) map[string]string <span class="cov8" title="1">{
        vars := map[string]string{}
        for _, str := range envVars </span><span class="cov8" title="1">{
                parts := strings.Split(str, "=")
                if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                        vars[parts[0]] = parts[1]
                }</span>
        }
        <span class="cov8" title="1">return vars</span>
}
</pre>
		
		<pre class="file" id="file99" style="display: none">package template

import (
        "crypto/rand"
        "fmt"
)

// UUID represents a unique identifier conforming to the RFC 4122 standard.
// UUIDs are a fixed 128bit (16 byte) binary blob.
type UUID []byte

func newUUID() UUID <span class="cov8" title="1">{
        return UUID(make([]byte, 16))
}</span>

// UUIDv4 Create a new UUID version 4.
func UUIDv4() UUID <span class="cov8" title="1">{
        uuid := newUUID()
        rand.Read(uuid)
        uuid[6] = (uuid[6] &amp; 0x0f) | 0x40 // set version 4
        uuid[8] = (uuid[8] &amp; 0x3f) | 0x80 // set variant 2
        return uuid
}</span>

// ToShortString returns a hex representation of the uuid.
func (uuid UUID) String() string <span class="cov8" title="1">{
        b := []byte(uuid)
        return fmt.Sprintf("%x", b[:])
}</span>

// Version returns the version byte of a uuid.
func (uuid UUID) Version() byte <span class="cov0" title="0">{
        return uuid[6] &gt;&gt; 4
}</span>
</pre>
		
		<pre class="file" id="file100" style="display: none">package util

// AnsiColorCode represents an ansi color code fragment.
type AnsiColorCode string

func (acc AnsiColorCode) escaped() string <span class="cov8" title="1">{
        return "\033[" + string(acc)
}</span>

// Apply returns a string with the color code applied.
func (acc AnsiColorCode) Apply(text string) string <span class="cov8" title="1">{
        return acc.escaped() + text + ColorReset.escaped()
}</span>

const (
        // ColorBlack is the posix escape code fragment for black.
        ColorBlack AnsiColorCode = "30m"

        // ColorRed is the posix escape code fragment for red.
        ColorRed AnsiColorCode = "31m"

        // ColorGreen is the posix escape code fragment for green.
        ColorGreen AnsiColorCode = "32m"

        // ColorYellow is the posix escape code fragment for yellow.
        ColorYellow AnsiColorCode = "33m"

        // ColorBlue is the posix escape code fragment for blue.
        ColorBlue AnsiColorCode = "34m"

        // ColorPurple is the posix escape code fragement for magenta (purple)
        ColorPurple AnsiColorCode = "35m"

        // ColorCyan is the posix escape code fragement for cyan.
        ColorCyan AnsiColorCode = "36m"

        // ColorWhite is the posix escape code fragment for white.
        ColorWhite AnsiColorCode = "37m"

        // ColorLightBlack is the posix escape code fragment for black.
        ColorLightBlack AnsiColorCode = "90m"

        // ColorLightRed is the posix escape code fragment for red.
        ColorLightRed AnsiColorCode = "91m"

        // ColorLightGreen is the posix escape code fragment for green.
        ColorLightGreen AnsiColorCode = "92m"

        // ColorLightYellow is the posix escape code fragment for yellow.
        ColorLightYellow AnsiColorCode = "93m"

        // ColorLightBlue is the posix escape code fragment for blue.
        ColorLightBlue AnsiColorCode = "94m"

        // ColorLightPurple is the posix escape code fragement for magenta (purple)
        ColorLightPurple AnsiColorCode = "95m"

        // ColorLightCyan is the posix escape code fragement for cyan.
        ColorLightCyan AnsiColorCode = "96m"

        // ColorLightWhite is the posix escape code fragment for white.
        ColorLightWhite AnsiColorCode = "97m"

        // ColorGray is an alias to ColorLightWhite to preserve backwards compatibility.
        ColorGray AnsiColorCode = ColorLightBlack

        // ColorReset is the posix escape code fragment to reset all formatting.
        ColorReset AnsiColorCode = "0m"
)
</pre>
		
		<pre class="file" id="file101" style="display: none">package util

import "encoding/base64"

// Base64 is a namespace singleton for (2) methods.
var Base64 base64Util

type base64Util struct{}

// Encode returns a base64 string for a byte array.
func (bu base64Util) Encode(blob []byte) string <span class="cov0" title="0">{
        return base64.StdEncoding.EncodeToString(blob)
}</span>

// Decode returns a byte array for a base64 encoded string.
func (bu base64Util) Decode(blob string) ([]byte, error) <span class="cov0" title="0">{
        return base64.StdEncoding.DecodeString(blob)
}</span>
</pre>
		
		<pre class="file" id="file102" style="display: none">package util

var (
        // BitFlag is a namespace for bitflag functions.
        BitFlag = bitFlag{}
)

type bitFlag struct{}

// All returns if all the reference bits are set for a given value
func (bf bitFlag) All(reference, value uint64) bool <span class="cov8" title="1">{
        return reference&amp;value == value
}</span>

// Any returns if any the reference bits are set for a given value
func (bf bitFlag) Any(reference, value uint64) bool <span class="cov8" title="1">{
        return reference&amp;value &gt; 0
}</span>

// Zero makes a given flag zero'd in the set.
func (bf bitFlag) Zero(flagSet, value uint64) uint64 <span class="cov8" title="1">{
        return flagSet ^ ((-(0) ^ value) &amp; flagSet)
}</span>

// Set sets a flag value to 1.
func (bf bitFlag) Set(flagSet, value uint64) uint64 <span class="cov8" title="1">{
        return flagSet | value
}</span>

// Combine combines all the values into one flag.
func (bf bitFlag) Combine(values ...uint64) uint64 <span class="cov8" title="1">{
        var outputFlag uint64
        for _, value := range values </span><span class="cov8" title="1">{
                outputFlag = outputFlag | value
        }</span>
        <span class="cov8" title="1">return outputFlag</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">package util

import (
        "strings"

        "github.com/blend/go-sdk/exception"
)

var (
        // BooleanTrue represents a true value for a boolean.
        BooleanTrue Boolean = true

        // BooleanFalse represents a false value for a boolean.
        BooleanFalse Boolean = false
)

// Boolean is a type alias for bool that can be unmarshaled from 0|1, true|false etc.
type Boolean bool

// UnmarshalJSON unmarshals the boolean from json.
func (bit *Boolean) UnmarshalJSON(data []byte) error <span class="cov8" title="1">{
        asString := strings.ToLower(string(data))
        if asString == "1" || asString == "true" </span><span class="cov8" title="1">{
                *bit = true
                return nil
        }</span> else<span class="cov8" title="1"> if asString == "0" || asString == "false" </span><span class="cov8" title="1">{
                *bit = false
                return nil
        }</span> else<span class="cov8" title="1"> if len(asString) &gt; 0 &amp;&amp; (asString[0] == '"' || asString[0] == '\'') </span><span class="cov8" title="1">{
                cleaned := String.StripQuotes(asString)
                return bit.UnmarshalJSON([]byte(cleaned))
        }</span>
        <span class="cov8" title="1">return exception.Newf("Boolean unmarshal error: invalid input %s", asString)</span>
}

// AsBool returns the stdlib bool value for the boolean.
func (bit Boolean) AsBool() bool <span class="cov8" title="1">{
        if bit </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file104" style="display: none">package util

import "time"

// Coalesce is a set of utilities for coalesced values.
var Coalesce coalesceUtil

type coalesceUtil struct{}

// String returns a coalesced value.
func (cu coalesceUtil) String(value, defaultValue string, inheritedValues ...string) string <span class="cov0" title="0">{
        if len(value) &gt; 0 </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">if len(inheritedValues) &gt; 0 </span><span class="cov0" title="0">{
                return inheritedValues[0]
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

// Bool returns a coalesced value.
func (cu coalesceUtil) Bool(value *bool, defaultValue bool, inheritedValues ...bool) bool <span class="cov0" title="0">{
        if value != nil </span><span class="cov0" title="0">{
                return *value
        }</span>
        <span class="cov0" title="0">if len(inheritedValues) &gt; 0 </span><span class="cov0" title="0">{
                return inheritedValues[0]
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

// Int returns a coalesced value.
func (cu coalesceUtil) Int(value, defaultValue int, inheritedValues ...int) int <span class="cov0" title="0">{
        if value &gt; 0 </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">if len(inheritedValues) &gt; 0 </span><span class="cov0" title="0">{
                return inheritedValues[0]
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

// Int32 returns a coalesced value.
func (cu coalesceUtil) Int32(value, defaultValue int32, inheritedValues ...int32) int32 <span class="cov0" title="0">{
        if value &gt; 0 </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">if len(inheritedValues) &gt; 0 </span><span class="cov0" title="0">{
                return inheritedValues[0]
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

// Int returns a coalesced value.
func (cu coalesceUtil) Int64(value, defaultValue int64, inheritedValues ...int64) int64 <span class="cov0" title="0">{
        if value &gt; 0 </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">if len(inheritedValues) &gt; 0 </span><span class="cov0" title="0">{
                return inheritedValues[0]
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

// Float32 returns a coalesced value.
func (cu coalesceUtil) Float32(value, defaultValue float32, inheritedValues ...float32) float32 <span class="cov0" title="0">{
        if value &gt; 0 </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">if len(inheritedValues) &gt; 0 </span><span class="cov0" title="0">{
                return inheritedValues[0]
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

// Float64 returns a coalesced value.
func (cu coalesceUtil) Float64(value, defaultValue float64, inheritedValues ...float64) float64 <span class="cov0" title="0">{
        if value &gt; 0 </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">if len(inheritedValues) &gt; 0 </span><span class="cov0" title="0">{
                return inheritedValues[0]
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

// Duration returns a coalesced value.
func (cu coalesceUtil) Duration(value, defaultValue time.Duration, inheritedValues ...time.Duration) time.Duration <span class="cov0" title="0">{
        if value &gt; 0 </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">if len(inheritedValues) &gt; 0 </span><span class="cov0" title="0">{
                return inheritedValues[0]
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

// Time returns a coalesced value.
func (cu coalesceUtil) Time(value, defaultValue time.Time, inheritedValues ...time.Time) time.Time <span class="cov0" title="0">{
        if !value.IsZero() </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">if len(inheritedValues) &gt; 0 </span><span class="cov0" title="0">{
                return inheritedValues[0]
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

// Strings returns a coalesced value.
func (cu coalesceUtil) Strings(value, defaultValue []string, inheritedValues ...[]string) []string <span class="cov0" title="0">{
        if len(value) &gt; 0 </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">if len(inheritedValues) &gt; 0 </span><span class="cov0" title="0">{
                return inheritedValues[0]
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}

// Bytes returns a coalesced value.
func (cu coalesceUtil) Bytes(value, defaultValue []byte, inheritedValues ...[]byte) []byte <span class="cov0" title="0">{
        if len(value) &gt; 0 </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">if len(inheritedValues) &gt; 0 </span><span class="cov0" title="0">{
                return inheritedValues[0]
        }</span>
        <span class="cov0" title="0">return defaultValue</span>
}
</pre>
		
		<pre class="file" id="file105" style="display: none">package util

import "time"

var (
        // Combinatorics is a namespace containing combinatoric functions.
        Combinatorics = combinatorics{}
)

type combinatorics struct{}

// PairsOfInt returns unordered pairs of integers from an array.
func (c combinatorics) PairsOfInt(values ...int) [][2]int <span class="cov8" title="1">{
        if len(values) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">var output [][2]int
        for i := 0; i &lt; len(values); i++ </span><span class="cov8" title="1">{
                for j := i + 1; j &lt; len(values); j++ </span><span class="cov8" title="1">{
                        output = append(output, [2]int{values[i], values[j]})
                }</span>
        }

        <span class="cov8" title="1">return output</span>
}

// PairsOfFloat64 returns unordered pairs of integers from an array.
func (c combinatorics) PairsOfFloat64(values ...float64) [][2]float64 <span class="cov8" title="1">{
        if len(values) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">var output [][2]float64
        for i := 0; i &lt; len(values); i++ </span><span class="cov8" title="1">{
                for j := i + 1; j &lt; len(values); j++ </span><span class="cov8" title="1">{
                        output = append(output, [2]float64{values[i], values[j]})
                }</span>
        }

        <span class="cov8" title="1">return output</span>
}

// CombinationsOfInt returns the "power set" of values less the empty set.
// Use "combinations" when the order of the resulting sets do not matter.
func (c combinatorics) CombinationsOfInt(values ...int) [][]int <span class="cov8" title="1">{
        possibleValues := Math.PowOfInt(2, uint(len(values))) //less the empty entry
        output := make([][]int, possibleValues-1)

        for x := 0; x &lt; possibleValues-1; x++ </span><span class="cov8" title="1">{
                row := []int{}
                for i := 0; i &lt; len(values); i++ </span><span class="cov8" title="1">{
                        y := 1 &lt;&lt; uint(i)
                        if y&amp;x == 0 &amp;&amp; y != x </span><span class="cov8" title="1">{
                                row = append(row, values[i])
                        }</span>
                }
                <span class="cov8" title="1">if len(row) &gt; 0 </span><span class="cov8" title="1">{
                        output[x] = row
                }</span>
        }
        <span class="cov8" title="1">return output</span>
}

// CombinationsOfFloat returns the "power set" of values less the empty set.
// Use "combinations" when the order of the resulting sets do not matter.
func (c combinatorics) CombinationsOfFloat(values ...float64) [][]float64 <span class="cov8" title="1">{
        possibleValues := Math.PowOfInt(2, uint(len(values))) //less the empty entry
        output := make([][]float64, possibleValues-1)

        for x := 0; x &lt; possibleValues-1; x++ </span><span class="cov8" title="1">{
                row := []float64{}
                for i := 0; i &lt; len(values); i++ </span><span class="cov8" title="1">{
                        y := 1 &lt;&lt; uint(i)
                        if y&amp;x == 0 &amp;&amp; y != x </span><span class="cov8" title="1">{
                                row = append(row, values[i])
                        }</span>
                }
                <span class="cov8" title="1">if len(row) &gt; 0 </span><span class="cov8" title="1">{
                        output[x] = row
                }</span>
        }
        <span class="cov8" title="1">return output</span>
}

// CombinationsOfString returns the "power set" of values less the empty set.
// Use "combinations" when the order of the resulting sets do not matter.
func (c combinatorics) CombinationsOfString(values ...string) [][]string <span class="cov8" title="1">{
        possibleValues := Math.PowOfInt(2, uint(len(values))) //less the empty entry
        output := make([][]string, possibleValues-1)

        for x := 0; x &lt; possibleValues-1; x++ </span><span class="cov8" title="1">{
                row := []string{}
                for i := 0; i &lt; len(values); i++ </span><span class="cov8" title="1">{
                        y := 1 &lt;&lt; uint(i)
                        if y&amp;x == 0 &amp;&amp; y != x </span><span class="cov8" title="1">{
                                row = append(row, values[i])
                        }</span>
                }
                <span class="cov8" title="1">if len(row) &gt; 0 </span><span class="cov8" title="1">{
                        output[x] = row
                }</span>
        }
        <span class="cov8" title="1">return output</span>
}

// PermutationsOfInt returns the possible orderings of the values array.
// Use "permutations" when order matters.
func (c combinatorics) PermutationsOfInt(values ...int) [][]int <span class="cov8" title="1">{
        if len(values) == 1 </span><span class="cov8" title="1">{
                return [][]int{values}
        }</span>

        <span class="cov8" title="1">output := [][]int{}
        for x := 0; x &lt; len(values); x++ </span><span class="cov8" title="1">{
                workingValues := make([]int, len(values))
                copy(workingValues, values)
                value := workingValues[x]
                pre := workingValues[0:x]
                post := workingValues[x+1 : len(values)]

                joined := append(pre, post...)

                for _, inner := range c.PermutationsOfInt(joined...) </span><span class="cov8" title="1">{
                        output = append(output, append([]int{value}, inner...))
                }</span>
        }

        <span class="cov8" title="1">return output</span>
}

// PermutationsOfFloat returns the possible orderings of the values array.
// Use "permutations" when order matters.
func (c combinatorics) PermutationsOfFloat(values ...float64) [][]float64 <span class="cov8" title="1">{
        if len(values) == 1 </span><span class="cov8" title="1">{
                return [][]float64{values}
        }</span>

        <span class="cov8" title="1">output := [][]float64{}
        for x := 0; x &lt; len(values); x++ </span><span class="cov8" title="1">{
                workingValues := make([]float64, len(values))
                copy(workingValues, values)
                value := workingValues[x]
                pre := workingValues[0:x]
                post := workingValues[x+1 : len(values)]

                joined := append(pre, post...)

                for _, inner := range c.PermutationsOfFloat(joined...) </span><span class="cov8" title="1">{
                        output = append(output, append([]float64{value}, inner...))
                }</span>
        }

        <span class="cov8" title="1">return output</span>
}

// PermutationsOfString returns the possible orderings of the values array (i.e. when order matters).
// Note: Use "combinations" when order doesn't matter.
func (c combinatorics) PermutationsOfString(values ...string) [][]string <span class="cov8" title="1">{
        if len(values) == 1 </span><span class="cov8" title="1">{
                return [][]string{values}
        }</span>

        <span class="cov8" title="1">output := [][]string{}
        for x := 0; x &lt; len(values); x++ </span><span class="cov8" title="1">{
                workingValues := make([]string, len(values))
                copy(workingValues, values)
                value := workingValues[x]
                pre := workingValues[0:x]
                post := workingValues[x+1 : len(values)]
                joined := append(pre, post...)
                for _, inner := range c.PermutationsOfString(joined...) </span><span class="cov8" title="1">{
                        output = append(output, append([]string{value}, inner...))
                }</span>
        }

        <span class="cov8" title="1">return output</span>
}

// Anagrams is a form of permutations that is of a fixed length (i.e. order matters).
// It is very similar to permutations of string but uses word inputs instead of individual strings.
func (c combinatorics) Anagrams(word string) []string <span class="cov8" title="1">{
        if len(word) &lt;= 1 </span><span class="cov8" title="1">{
                return []string{word}
        }</span>

        <span class="cov8" title="1">output := []string{}
        var letter byte
        var pre []byte
        var post []byte
        var joined []byte
        for x := 0; x &lt; len(word); x++ </span><span class="cov8" title="1">{
                workingWord := make([]byte, len(word))
                copy(workingWord, []byte(word))
                letter = workingWord[x]
                pre = workingWord[0:x]
                post = workingWord[x+1 : len(word)]
                joined = append(pre, post...)
                for _, subResult := range c.Anagrams(string(joined)) </span><span class="cov8" title="1">{
                        output = append(output, string(letter)+subResult)
                }</span>
        }
        <span class="cov8" title="1">return output</span>
}

// PermuteDistributions returns all the possible ways you can split a total among buckets completely.
func (c combinatorics) PermuteDistributions(total, buckets int) [][]int <span class="cov8" title="1">{
        return c.PermuteDistributionsFromExisting(total, buckets, []int{})
}</span>

// PermuteDistributionsFromExisting returns all the possible ways you can split the total among additional buckets
// given an existing distribution
func (c combinatorics) PermuteDistributionsFromExisting(total, buckets int, existing []int) [][]int <span class="cov8" title="1">{
        output := [][]int{}
        existingLength := len(existing)
        existingSum := Math.SumOfInt(existing)
        remainder := total - existingSum

        if buckets == 1 </span><span class="cov8" title="1">{
                newExisting := make([]int, existingLength+1)
                copy(newExisting, existing)
                newExisting[existingLength] = remainder
                output = append(output, newExisting)
                return output
        }</span>

        <span class="cov8" title="1">for x := 0; x &lt;= remainder; x++ </span><span class="cov8" title="1">{
                newExisting := make([]int, existingLength+1)
                copy(newExisting, existing)
                newExisting[existingLength] = x

                results := c.PermuteDistributionsFromExisting(total, buckets-1, newExisting)
                output = append(output, results...)
        }</span>

        <span class="cov8" title="1">return output</span>
}

// RandomInt returns a random int from an array.
func (c combinatorics) RandomInt(values ...int) int <span class="cov0" title="0">{
        if len(values) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if len(values) == 1 </span><span class="cov0" title="0">{
                return values[0]
        }</span>
        <span class="cov0" title="0">return values[RandomProvider().Intn(len(values))]</span>
}

// RandomFloat64 returns a random int from an array.
func (c combinatorics) RandomFloat64(values ...float64) float64 <span class="cov0" title="0">{
        if len(values) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">if len(values) == 1 </span><span class="cov0" title="0">{
                return values[0]
        }</span>
        <span class="cov0" title="0">return values[RandomProvider().Intn(len(values))]</span>
}

// RandomString returns a random string from an array.
func (c combinatorics) RandomString(values ...string) string <span class="cov0" title="0">{
        if len(values) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">if len(values) == 1 </span><span class="cov0" title="0">{
                return values[0]
        }</span>
        <span class="cov0" title="0">return values[RandomProvider().Intn(len(values))]</span>
}

// RandomTime returns a random time.Time from an array.
func (c combinatorics) RandomTime(values ...time.Time) time.Time <span class="cov0" title="0">{
        if len(values) == 0 </span><span class="cov0" title="0">{
                return time.Time{}
        }</span>
        <span class="cov0" title="0">if len(values) == 1 </span><span class="cov0" title="0">{
                return values[0]
        }</span>
        <span class="cov0" title="0">return values[RandomProvider().Intn(len(values))]</span>
}
</pre>
		
		<pre class="file" id="file106" style="display: none">package util

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/hmac"
        "crypto/rand"
        "crypto/sha512"
        "fmt"
        "io"

        "github.com/blend/go-sdk/exception"
)

// Crypto is a namespace for crypto related functions.
var Crypto = cryptoUtil{}

type cryptoUtil struct{}

// GCMEncryptionResult is a struct for a gcm encryption result
type GCMEncryptionResult struct {
        CipherText []byte
        Nonce      []byte
}

// CreateKey creates a key of a given size by reading that much data off the crypto/rand reader.
func (cu cryptoUtil) CreateKey(keySize int) ([]byte, error) <span class="cov8" title="1">{
        key := make([]byte, keySize)
        _, err := rand.Read(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return key, nil</span>
}

// MustCreateKey creates a key, if an error is returned, it panics.
func (cu cryptoUtil) MustCreateKey(keySize int) []byte <span class="cov0" title="0">{
        key, err := cu.CreateKey(keySize)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return key</span>
}

// Encrypt encrypts data with the given key.
func (cu cryptoUtil) Encrypt(key, plainText []byte) ([]byte, error) <span class="cov8" title="1">{
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">ciphertext := make([]byte, aes.BlockSize+len(plainText))
        iv := ciphertext[:aes.BlockSize]
        if _, err := io.ReadFull(rand.Reader, iv); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">cfb := cipher.NewCFBEncrypter(block, iv)
        cfb.XORKeyStream(ciphertext[aes.BlockSize:], plainText)
        return ciphertext, nil</span>
}

// GCMEncryptionInPlace will encrypt and authenticate the plaintext with the given key. GCMEncryptionResult.CipherText will be backed in memory by the inputted plaintext []byte. Use GCMEncryption.CipherText, never plaintext.
func (cu cryptoUtil) GCMEncryptInPlace(key, plainText []byte) (*GCMEncryptionResult, error) <span class="cov8" title="1">{
        return cu.GCMEncrypt(key, plainText, plainText[:0])
}</span>

// GCMEncrypt encrypts and authenticates the plaintext with the given key. dst is the destination slice for the encrypted data
func (cu cryptoUtil) GCMEncrypt(key, plainText, dst []byte) (*GCMEncryptionResult, error) <span class="cov8" title="1">{
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>
        <span class="cov8" title="1">aead, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>
        <span class="cov8" title="1">nonce := make([]byte, aead.NonceSize())
        _, err = rand.Read(nonce)
        if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>
        <span class="cov8" title="1">dst = aead.Seal(dst, nonce, plainText, nil)
        return &amp;GCMEncryptionResult{CipherText: dst, Nonce: nonce}, nil</span>
}

// GCMDecryptInPlace decrypts the ciphertext in place. GCMEncryptionResult.CipherText will be used as the backing memory, but only use the returned slice
func (cu cryptoUtil) GCMDecryptInPlace(key []byte, gcm *GCMEncryptionResult) ([]byte, error) <span class="cov8" title="1">{
        return cu.GCMDecrypt(key, gcm, gcm.CipherText[:0])
}</span>

// GCMDecrypt decrypts and authenticates the cipherText with the given key
func (cu cryptoUtil) GCMDecrypt(key []byte, gcm *GCMEncryptionResult, dst []byte) ([]byte, error) <span class="cov8" title="1">{
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>
        <span class="cov8" title="1">aead, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>
        <span class="cov8" title="1">dst, err = aead.Open(dst, gcm.Nonce, gcm.CipherText, nil)
        return dst, exception.Wrap(err)</span>
}

// Decrypt decrypts data with the given key.
func (cu cryptoUtil) Decrypt(key, cipherText []byte) ([]byte, error) <span class="cov8" title="1">{
        if len(cipherText) &lt; aes.BlockSize </span><span class="cov0" title="0">{
                return nil, exception.New(fmt.Sprintf("Cannot decrypt string: `cipherText` is smaller than AES block size (%v)", aes.BlockSize))
        }</span>

        <span class="cov8" title="1">iv := cipherText[:aes.BlockSize]
        cipherText = cipherText[aes.BlockSize:]

        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">cfb := cipher.NewCFBDecrypter(block, iv)
        cfb.XORKeyStream(cipherText, cipherText)
        return cipherText, nil</span>
}

// Hash hashes data with the given key.
func (cu cryptoUtil) Hash(key, plainText []byte) []byte <span class="cov8" title="1">{
        mac := hmac.New(sha512.New, key)
        mac.Write([]byte(plainText))
        return mac.Sum(nil)
}</span>

// SecureRandomBytes generates a fixed length of random bytes.
func (cu cryptoUtil) SecureRandomBytes(length int) ([]byte, error) <span class="cov0" title="0">{
        b := make([]byte, length)
        _, err := rand.Read(b)
        if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>

        <span class="cov0" title="0">return b, nil</span>
}

// MustSecureRandomBytes generates a random byte sequence and panics if it fails.
func (cu cryptoUtil) MustSecureRandomBytes(length int) []byte <span class="cov0" title="0">{
        b, err := cu.SecureRandomBytes(length)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return b</span>
}
</pre>
		
		<pre class="file" id="file107" style="display: none">package util

// AnyError returns any variadic error that is not nil.
func AnyError(err ...error) error <span class="cov0" title="0">{
        for x := 0; x &lt; len(err); x++ </span><span class="cov0" title="0">{
                if err[x] != nil </span><span class="cov0" title="0">{
                        return err[x]
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file108" style="display: none">package util

import (
        "bufio"
        "io"
        "io/ioutil"
        "os"
        "path/filepath"
        "regexp"
        "strconv"
        "strings"

        "github.com/blend/go-sdk/exception"
)

const (
        // Kilobyte represents the bytes in a kilobyte.
        Kilobyte int64 = 1 &lt;&lt; 10
        // Megabyte represents the bytes in a megabyte.
        Megabyte int64 = Kilobyte &lt;&lt; 10
        // Gigabyte represents the bytes in a gigabyte.
        Gigabyte int64 = Megabyte &lt;&lt; 10
)

// File contains helper functions for files.
var File = &amp;fileUtil{}

type fileUtil struct{}

// CreateOrOpen creates or opens a file.
func (fu fileUtil) CreateOrOpen(filePath string) (*os.File, error) <span class="cov8" title="1">{
        f, err := os.OpenFile(filePath, os.O_APPEND|os.O_WRONLY, os.ModeAppend)
        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                return os.Create(filePath)
        }</span>
        <span class="cov8" title="1">return f, err</span>
}

// CreateAndClose creates and closes a file.
func (fu fileUtil) CreateAndClose(filePath string) error <span class="cov0" title="0">{
        f, err := os.Create(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer f.Close()
        return nil</span>
}

// RemoveMany removes an array of files.
func (fu fileUtil) RemoveMany(filePaths ...string) error <span class="cov0" title="0">{
        var err error
        for _, path := range filePaths </span><span class="cov0" title="0">{
                err = os.Remove(path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return err</span>
}

func (fu fileUtil) List(path string, expr *regexp.Regexp) ([]string, error) <span class="cov0" title="0">{
        var files []string
        dirFiles, err := ioutil.ReadDir(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var fileBase string
        for _, dirFile := range dirFiles </span><span class="cov0" title="0">{
                if dirFile.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">fileBase = filepath.Base(dirFile.Name())
                if expr == nil </span><span class="cov0" title="0">{
                        files = append(files, fileBase)
                        continue</span>
                }
                <span class="cov0" title="0">if expr.MatchString(fileBase) </span><span class="cov0" title="0">{
                        files = append(files, fileBase)
                }</span>
        }
        <span class="cov0" title="0">return files, err</span>
}

func (fu fileUtil) ParseSize(fileSizeValue string, defaultFileSize int64) int64 <span class="cov8" title="1">{
        if len(fileSizeValue) == 0 </span><span class="cov8" title="1">{
                return defaultFileSize
        }</span>

        <span class="cov8" title="1">if len(fileSizeValue) &lt; 2 </span><span class="cov0" title="0">{
                val, err := strconv.Atoi(fileSizeValue)
                if err != nil </span><span class="cov0" title="0">{
                        return defaultFileSize
                }</span>
                <span class="cov0" title="0">return int64(val)</span>
        }

        <span class="cov8" title="1">units := strings.ToLower(fileSizeValue[len(fileSizeValue)-2:])
        value, err := strconv.ParseInt(fileSizeValue[:len(fileSizeValue)-2], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return defaultFileSize
        }</span>
        <span class="cov8" title="1">switch units </span>{
        case "gb":<span class="cov8" title="1">
                return value * Gigabyte</span>
        case "mb":<span class="cov8" title="1">
                return value * Megabyte</span>
        case "kb":<span class="cov8" title="1">
                return value * Kilobyte</span>
        }
        <span class="cov8" title="1">fullValue, err := strconv.ParseInt(fileSizeValue, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return defaultFileSize
        }</span>
        <span class="cov8" title="1">return fullValue</span>
}

// ReadFile reads a file as a string.
func (fu fileUtil) ReadString(path string) (string, error) <span class="cov0" title="0">{
        bytes, err := ioutil.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return string(bytes), nil</span>
}

// ReadChunkHandler is a receiver for a chunk of a file.
type ReadChunkHandler func(line []byte) error

//ReadLineHandler is a receiver for a line of a file.
type ReadLineHandler func(line string) error

// ReadFileByLines reads a file and calls the handler for each line.
func (fu fileUtil) ReadByLines(filePath string, handler ReadLineHandler) error <span class="cov8" title="1">{
        if f, err := os.Open(filePath); err == nil </span><span class="cov8" title="1">{
                defer f.Close()

                scanner := bufio.NewScanner(f)
                for scanner.Scan() </span><span class="cov8" title="1">{
                        line := scanner.Text()
                        err = handler(line)
                        if err != nil </span><span class="cov0" title="0">{
                                return exception.Wrap(err)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                return exception.Wrap(err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ReadFileByChunks reads a file in `chunkSize` pieces, dispatched to the handler.
func (fu fileUtil) ReadByChunks(filePath string, chunkSize int, handler ReadChunkHandler) error <span class="cov8" title="1">{
        if f, err := os.Open(filePath); err == nil </span><span class="cov8" title="1">{
                defer f.Close()

                chunk := make([]byte, chunkSize)
                for </span><span class="cov8" title="1">{
                        readBytes, err := f.Read(chunk)
                        if err == io.EOF </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">readData := chunk[:readBytes]
                        err = handler(readData)
                        if err != nil </span><span class="cov0" title="0">{
                                return exception.Wrap(err)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                return exception.Wrap(err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ReadAllBytes reads all bytes in a file.
func (fu fileUtil) ReadAllBytes(filePath string) ([]byte, error) <span class="cov0" title="0">{
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer file.Close()
        return ioutil.ReadAll(file)</span>
}
</pre>
		
		<pre class="file" id="file109" style="display: none">package util

import (
        "fmt"
        "time"
)

// Format is a singleton namespace with utilties for formatting common values.
var Format formatUtil

type formatUtil struct{}

// Percent returns a value in the format 0.00%.
func (fu formatUtil) Percent(value float64) string <span class="cov0" title="0">{
        return fmt.Sprintf("%0.2f%%", value+100.0)
}</span>

// Money returns a typical dollar ammount representation for a float.
func (fu formatUtil) Money(value float64) string <span class="cov0" title="0">{
        return fmt.Sprintf("%.2f", value)
}</span>

// DateUTC returns a date formatted by `2006-01-02Z`.
func (fu formatUtil) DateUTC(t time.Time) string <span class="cov0" title="0">{
        return t.UTC().Format("2006-01-02Z")
}</span>

// DateTimeUTC returns a date and time formatted by RFC3339 tweaked slightly.
func (fu formatUtil) DateTimeUTC(t time.Time) string <span class="cov0" title="0">{
        return t.Format("2006-01-02T15:04:05Z")
}</span>

// FormatFileSize returns a string representation of a file size in bytes.
func (fu formatUtil) FileSize(sizeBytes int) string <span class="cov0" title="0">{
        if sizeBytes &gt;= 1&lt;&lt;30 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dgB", sizeBytes/(1&lt;&lt;30))
        }</span> else<span class="cov0" title="0"> if sizeBytes &gt;= 1&lt;&lt;20 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dmB", sizeBytes/(1&lt;&lt;20))
        }</span> else<span class="cov0" title="0"> if sizeBytes &gt;= 1&lt;&lt;10 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%dkB", sizeBytes/(1&lt;&lt;10))
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%dB", sizeBytes)</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">package util

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "io"

        "github.com/blend/go-sdk/exception"
)

// GCM is a namespace for gcm related utility functions
var GCM = gcmUtil{}

type gcmUtil struct{}

// Encrypt provides authenticity, integrity, and confidentiality
// It returns the nonce, ciphertext, and authenticity/integrity tag.
// All three parts are necessary during decryption, but are exposed for
// interoperability with external systems.
func (gu gcmUtil) Encrypt(key, plaintext []byte) ([]byte, []byte, []byte, error) <span class="cov8" title="1">{
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, exception.Wrap(err)
        }</span>

        <span class="cov8" title="1">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, exception.Wrap(err)
        }</span>

        <span class="cov8" title="1">nonce := make([]byte, gcm.NonceSize())
        if _, err := io.ReadFull(rand.Reader, nonce); err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, exception.Wrap(err)
        }</span>

        // out is the concatination of nonce, ciphertext, and tag
        <span class="cov8" title="1">out := gcm.Seal(nonce, nonce, plaintext, nil)

        tagStart := len(out) - gcm.Overhead()
        tag := out[tagStart:]
        ciphertext := out[gcm.NonceSize():tagStart]

        return nonce, ciphertext, tag, nil</span>
}

// Decrypt checks the authenticity tag and decrypts the ciphertext
func (gu gcmUtil) Decrypt(key, nonce, ciphertext, tag []byte) ([]byte, error) <span class="cov8" title="1">{

        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>

        <span class="cov8" title="1">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>

        <span class="cov8" title="1">if len(nonce) != gcm.NonceSize() </span><span class="cov0" title="0">{
                return nil, exception.New("Invalid `nonce`, should be [12]byte")
        }</span>

        <span class="cov8" title="1">message := append(ciphertext, tag...)

        out, err := gcm.Open(nil, nonce, message, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>

        <span class="cov8" title="1">return out, nil</span>
}
</pre>
		
		<pre class="file" id="file111" style="display: none">package util

import (
        "bytes"
        "compress/gzip"
        "io/ioutil"

        "github.com/blend/go-sdk/exception"
)

var (
        // GZip is a namespace for gzip utilities.
        GZip = gzipUtil{}
)

type gzipUtil struct{}

// Compress gzip compresses the bytes.
func (gu gzipUtil) Compress(contents []byte) ([]byte, error) <span class="cov8" title="1">{
        var b bytes.Buffer
        w := gzip.NewWriter(&amp;b)
        w.Write(contents)
        err := w.Flush()
        if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>
        <span class="cov8" title="1">err = w.Close()
        if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>

        <span class="cov8" title="1">return b.Bytes(), nil</span>
}

// Decompress gzip decompresses the bytes.
func (gu gzipUtil) Decompress(contents []byte) ([]byte, error) <span class="cov8" title="1">{
        r, err := gzip.NewReader(bytes.NewBuffer(contents))
        if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>
        <span class="cov8" title="1">defer r.Close()
        decompressed, err := ioutil.ReadAll(r)
        return decompressed, exception.Wrap(err)</span>
}
</pre>
		
		<pre class="file" id="file112" style="display: none">package util

import (
        "bytes"
        "encoding/json"
        "io"

        "github.com/blend/go-sdk/exception"
)

var (
        // JSON is a namespace for json utils.
        JSON = jsonUtil{}
)

type jsonUtil struct{}

// Deserialize unmarshals an object from JSON.
func (ju jsonUtil) Deserialize(object interface{}, body string) error <span class="cov8" title="1">{
        decoder := json.NewDecoder(bytes.NewBufferString(body))
        return exception.Wrap(decoder.Decode(object))
}</span>

// DeserializeFromReader unmashals an object from a json Reader.
func (ju jsonUtil) DeserializeFromReader(object interface{}, body io.Reader) error <span class="cov8" title="1">{
        return exception.Wrap(json.NewDecoder(body).Decode(object))
}</span>

// DeserializeFromReadCloser unmashals an object from a json ReadCloser.
func (ju jsonUtil) DeserializeFromReadCloser(object interface{}, body io.ReadCloser) error <span class="cov8" title="1">{
        defer body.Close()

        decoder := json.NewDecoder(body)
        return exception.Wrap(decoder.Decode(object))
}</span>

// Serialize marshals an object to json.
func (ju jsonUtil) Serialize(object interface{}) string <span class="cov8" title="1">{
        b, _ := json.Marshal(object)
        return string(b)
}</span>

// SerializePretty marshals an object to json with formatting whitespace.
func (ju jsonUtil) SerializePretty(object interface{}, prefix, indent string) string <span class="cov0" title="0">{
        b, _ := json.MarshalIndent(object, prefix, indent)
        return string(b)
}</span>

// SerializeAsReader marshals an object to json as a reader.
func (ju jsonUtil) SerializeAsReader(object interface{}) io.Reader <span class="cov8" title="1">{
        b, _ := json.Marshal(object)
        return bytes.NewBuffer(b)
}</span>
</pre>
		
		<pre class="file" id="file113" style="display: none">package util

import (
        "math"
        "sort"
        "time"
)

var (
        // Math is a namespace for math utilities.
        Math = mathUtil{}
)

const (
        _pi   = math.Pi
        _2pi  = 2 * math.Pi
        _3pi4 = (3 * math.Pi) / 4.0
        _4pi3 = (4 * math.Pi) / 3.0
        _3pi2 = (3 * math.Pi) / 2.0
        _5pi4 = (5 * math.Pi) / 4.0
        _7pi4 = (7 * math.Pi) / 4.0
        _pi2  = math.Pi / 2.0
        _pi4  = math.Pi / 4.0
        _d2r  = (math.Pi / 180.0)
        _r2d  = (180.0 / math.Pi)

        // Epsilon represents the minimum amount of relevant delta we care about.
        Epsilon = 0.00000001
)

type mathUtil struct{}

// PowOfInt returns the base to the power.
func (mu mathUtil) PowOfInt(base, power uint) int <span class="cov8" title="1">{
        if base == 2 </span><span class="cov8" title="1">{
                return 1 &lt;&lt; power
        }</span>
        <span class="cov0" title="0">return float64ToInt(math.Pow(float64(base), float64(power)))</span>
}

// MinAndMax returns both the min and max in one pass.
func (mu mathUtil) MinAndMax(values ...float64) (min float64, max float64) <span class="cov0" title="0">{
        if len(values) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">min = values[0]
        max = values[0]
        for _, v := range values </span><span class="cov0" title="0">{
                if max &lt; v </span><span class="cov0" title="0">{
                        max = v
                }</span>
                <span class="cov0" title="0">if min &gt; v </span><span class="cov0" title="0">{
                        min = v
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

// MinAndMaxOfInt returns both the min and max in one pass.
func (mu mathUtil) MinAndMaxOfInt(values ...int) (min int, max int) <span class="cov0" title="0">{
        if len(values) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">min = values[0]
        max = values[0]
        for _, v := range values </span><span class="cov0" title="0">{
                if max &lt; v </span><span class="cov0" title="0">{
                        max = v
                }</span>
                <span class="cov0" title="0">if min &gt; v </span><span class="cov0" title="0">{
                        min = v
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

// MinAndMaxOfInt64 returns both the min and max in one pass.
func (mu mathUtil) MinAndMaxOfInt64(values ...int64) (min int64, max int64) <span class="cov0" title="0">{
        if len(values) == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">min = values[0]
        max = values[0]
        for _, v := range values </span><span class="cov0" title="0">{
                if max &lt; v </span><span class="cov0" title="0">{
                        max = v
                }</span>
                <span class="cov0" title="0">if min &gt; v </span><span class="cov0" title="0">{
                        min = v
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

// Min finds the lowest value in a slice.
func (mu mathUtil) Min(input []float64) float64 <span class="cov8" title="1">{
        if len(input) == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">min := input[0]

        for i := 1; i &lt; len(input); i++ </span><span class="cov8" title="1">{
                if input[i] &lt; min </span><span class="cov8" title="1">{
                        min = input[i]
                }</span>
        }
        <span class="cov8" title="1">return min</span>
}

// MinOfInt finds the lowest value in a slice.
func (mu mathUtil) MinOfInt(input []int) int <span class="cov0" title="0">{
        if len(input) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">min := input[0]

        for i := 1; i &lt; len(input); i++ </span><span class="cov0" title="0">{
                if input[i] &lt; min </span><span class="cov0" title="0">{
                        min = input[i]
                }</span>
        }
        <span class="cov0" title="0">return min</span>
}

// MinOfDuration finds the lowest value in a slice.
func (mu mathUtil) MinOfDuration(input []time.Duration) time.Duration <span class="cov0" title="0">{
        if len(input) == 0 </span><span class="cov0" title="0">{
                return time.Duration(0)
        }</span>

        <span class="cov0" title="0">min := input[0]

        for i := 1; i &lt; len(input); i++ </span><span class="cov0" title="0">{
                if input[i] &lt; min </span><span class="cov0" title="0">{
                        min = input[i]
                }</span>
        }
        <span class="cov0" title="0">return min</span>
}

// Max finds the highest value in a slice.
func (mu mathUtil) Max(input []float64) float64 <span class="cov8" title="1">{

        if len(input) == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">max := input[0]

        for i := 1; i &lt; len(input); i++ </span><span class="cov8" title="1">{
                if input[i] &gt; max </span><span class="cov8" title="1">{
                        max = input[i]
                }</span>
        }

        <span class="cov8" title="1">return max</span>
}

// MaxOfInt finds the highest value in a slice.
func (mu mathUtil) MaxOfInt(input []int) int <span class="cov0" title="0">{
        if len(input) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">max := input[0]

        for i := 1; i &lt; len(input); i++ </span><span class="cov0" title="0">{
                if input[i] &gt; max </span><span class="cov0" title="0">{
                        max = input[i]
                }</span>
        }

        <span class="cov0" title="0">return max</span>
}

// MaxOfDuration finds the highest value in a slice.'
func (mu mathUtil) MaxOfDuration(input []time.Duration) time.Duration <span class="cov0" title="0">{
        if len(input) == 0 </span><span class="cov0" title="0">{
                return time.Duration(0)
        }</span>

        <span class="cov0" title="0">max := input[0]

        for i := 1; i &lt; len(input); i++ </span><span class="cov0" title="0">{
                if input[i] &gt; max </span><span class="cov0" title="0">{
                        max = input[i]
                }</span>
        }

        <span class="cov0" title="0">return max</span>
}

// Sum adds all the numbers of a slice together
func (mu mathUtil) Sum(input []float64) float64 <span class="cov8" title="1">{

        if len(input) == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">sum := float64(0)

        // Add em up
        for _, n := range input </span><span class="cov8" title="1">{
                sum += n
        }</span>

        <span class="cov8" title="1">return sum</span>
}

// SumOfInt adds all the numbers of a slice together
func (mu mathUtil) SumOfInt(values []int) int <span class="cov8" title="1">{
        total := 0
        for x := 0; x &lt; len(values); x++ </span><span class="cov8" title="1">{
                total += values[x]
        }</span>

        <span class="cov8" title="1">return total</span>
}

// SumOfDuration adds all the values of a slice together
func (mu mathUtil) SumOfDuration(values []time.Duration) time.Duration <span class="cov8" title="1">{
        total := time.Duration(0)
        for x := 0; x &lt; len(values); x++ </span><span class="cov8" title="1">{
                total += values[x]
        }</span>

        <span class="cov8" title="1">return total</span>
}

// Mean gets the average of a slice of numbers
func (mu mathUtil) Mean(input []float64) float64 <span class="cov8" title="1">{
        if len(input) == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">sum := mu.Sum(input)

        return sum / float64(len(input))</span>
}

// MeanOfInt gets the average of a slice of numbers
func (mu mathUtil) MeanOfInt(input []int) float64 <span class="cov0" title="0">{
        if len(input) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">sum := mu.SumOfInt(input)
        return float64(sum) / float64(len(input))</span>
}

// MeanOfDuration gets the average of a slice of numbers
func (mu mathUtil) MeanOfDuration(input []time.Duration) time.Duration <span class="cov8" title="1">{
        if len(input) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">sum := mu.SumOfDuration(input)
        mean := uint64(sum) / uint64(len(input))
        return time.Duration(mean)</span>
}

// Median gets the median number in a slice of numbers
func (mu mathUtil) Median(input []float64) float64 <span class="cov8" title="1">{
        median := float64(0)
        l := len(input)
        if l == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">c := copyslice(input)
        sort.Float64s(c)

        if l%2 == 0 </span><span class="cov8" title="1">{
                median = mu.Mean(c[l/2-1 : l/2+1])
        }</span> else<span class="cov8" title="1"> {
                median = float64(c[l/2])
        }</span>

        <span class="cov8" title="1">return median</span>
}

// Mode gets the mode of a slice of numbers
// `Mode` generally is the most frequently occurring values within the input set.
func (mu mathUtil) Mode(input []float64) []float64 <span class="cov8" title="1">{

        l := len(input)
        if l == 1 </span><span class="cov8" title="1">{
                return input
        }</span> else<span class="cov8" title="1"> if l == 0 </span><span class="cov8" title="1">{
                return []float64{}
        }</span>

        <span class="cov8" title="1">m := make(map[float64]int)
        for _, v := range input </span><span class="cov8" title="1">{
                m[v]++
        }</span>

        <span class="cov8" title="1">mode := []float64{}

        var current int
        for k, v := range m </span><span class="cov8" title="1">{
                switch </span>{
                case v &lt; current:</span><span class="cov8" title="1">
                case v &gt; current:<span class="cov8" title="1">
                        current = v
                        mode = append(mode[:0], k)</span>
                default:<span class="cov8" title="1">
                        mode = append(mode, k)</span>
                }
        }

        <span class="cov8" title="1">lm := len(mode)
        if l == lm </span><span class="cov8" title="1">{
                return []float64{}
        }</span>

        <span class="cov8" title="1">return mode</span>
}

// Variance finds the variance for both population and sample data
func (mu mathUtil) Variance(input []float64, sample int) float64 <span class="cov8" title="1">{

        if len(input) == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">variance := float64(0)
        m := mu.Mean(input)

        for _, n := range input </span><span class="cov8" title="1">{
                variance += (float64(n) - m) * (float64(n) - m)
        }</span>

        // When getting the mean of the squared differences
        // "sample" will allow us to know if it's a sample
        // or population and wether to subtract by one or not
        <span class="cov8" title="1">return variance / float64((len(input) - (1 * sample)))</span>
}

// VarP finds the amount of variance within a population
func (mu mathUtil) VarP(input []float64) float64 <span class="cov8" title="1">{
        return mu.Variance(input, 0)
}</span>

// VarS finds the amount of variance within a sample
func (mu mathUtil) VarS(input []float64) float64 <span class="cov8" title="1">{
        return mu.Variance(input, 1)
}</span>

// StdDevP finds the amount of variation from the population
func (mu mathUtil) StdDevP(input []float64) float64 <span class="cov8" title="1">{

        if len(input) == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>

        // stdev is generally the square root of the variance
        <span class="cov8" title="1">return math.Pow(mu.VarP(input), 0.5)</span>
}

// StdDevS finds the amount of variation from a sample
func (mu mathUtil) StdDevS(input []float64) float64 <span class="cov8" title="1">{

        if len(input) == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>

        // stdev is generally the square root of the variance
        <span class="cov8" title="1">return math.Pow(mu.VarS(input), 0.5)</span>
}

// Round a float to a specific decimal place or precision
func (mu mathUtil) Round(input float64, places int) float64 <span class="cov8" title="1">{
        if math.IsNaN(input) </span><span class="cov0" title="0">{
                return 0.0
        }</span>

        <span class="cov8" title="1">sign := 1.0
        if input &lt; 0 </span><span class="cov8" title="1">{
                sign = -1
                input *= -1
        }</span>

        <span class="cov8" title="1">rounded := float64(0)
        precision := math.Pow(10, float64(places))
        digit := input * precision
        _, decimal := math.Modf(digit)

        if decimal &gt;= 0.5 </span><span class="cov8" title="1">{
                rounded = math.Ceil(digit)
        }</span> else<span class="cov8" title="1"> {
                rounded = math.Floor(digit)
        }</span>

        <span class="cov8" title="1">return rounded / precision * sign</span>
}

// RoundUp rounds up to a given roundTo value.
func (mu mathUtil) RoundUp(value, roundTo float64) float64 <span class="cov0" title="0">{
        d1 := math.Ceil(value / roundTo)
        return d1 * roundTo
}</span>

// RoundDown rounds down to a given roundTo value.
func (mu mathUtil) RoundDown(value, roundTo float64) float64 <span class="cov0" title="0">{
        d1 := math.Floor(value / roundTo)
        return d1 * roundTo
}</span>

// Percentile finds the relative standing in a slice of floats.
// `percent` should be given on the interval [0,100.0).
func (mu mathUtil) Percentile(input []float64, percent float64) float64 <span class="cov8" title="1">{
        if len(input) == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">c := copyslice(input)
        sort.Float64s(c)
        index := (percent / 100.0) * float64(len(c))

        percentile := float64(0)
        if index == float64(int64(index)) </span><span class="cov8" title="1">{
                i := float64ToInt(index)
                percentile = mu.Mean([]float64{c[i-1], c[i]})
        }</span> else<span class="cov8" title="1"> {
                i := float64ToInt(index)
                percentile = c[i-1]
        }</span>

        <span class="cov8" title="1">return percentile</span>
}

type durations []time.Duration

func (dl durations) Len() int <span class="cov0" title="0">{
        return len(dl)
}</span>

func (dl durations) Less(i, j int) bool <span class="cov0" title="0">{
        return dl[i] &lt; dl[j]
}</span>

func (dl durations) Swap(i, j int) <span class="cov0" title="0">{
        dl[i], dl[j] = dl[j], dl[i]
}</span>

// Percentile finds the relative standing in a slice of floats
func (mu mathUtil) PercentileOfDuration(input []time.Duration, percentile float64) time.Duration <span class="cov0" title="0">{
        if len(input) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov0" title="0">sort.Sort(durations(input))
        index := (percentile / 100.0) * float64(len(input))
        if index == float64(int64(index)) </span><span class="cov0" title="0">{
                i := int(Math.Round(index, 0))

                if i &lt; 1 </span><span class="cov0" title="0">{
                        return time.Duration(0)
                }</span>

                <span class="cov0" title="0">return mu.MeanOfDuration([]time.Duration{input[i-1], input[i]})</span>
        }

        <span class="cov0" title="0">i := int(Math.Round(index, 0))
        if i &lt; 1 </span><span class="cov0" title="0">{
                return time.Duration(0)
        }</span>

        <span class="cov0" title="0">return input[i-1]</span>
}

// AbsInt returns the absolute value of an integer.
func (mu mathUtil) AbsInt(value int) int <span class="cov0" title="0">{
        if value &lt; 0 </span><span class="cov0" title="0">{
                return -value
        }</span>
        <span class="cov0" title="0">return value</span>
}

// Normalize returns a set of numbers on the interval [0,1] for a given set of inputs.
// An example: 4,3,2,1 =&gt; 0.4, 0.3, 0.2, 0.1
// Caveat; the total may be &lt; 1.0; there are going to be issues with irrational numbers etc.
func (mu mathUtil) Normalize(values ...float64) []float64 <span class="cov0" title="0">{
        var total float64
        for _, v := range values </span><span class="cov0" title="0">{
                total += v
        }</span>
        <span class="cov0" title="0">output := make([]float64, len(values))
        for x, v := range values </span><span class="cov0" title="0">{
                output[x] = mu.RoundDown(v/total, 0.0001)
        }</span>
        <span class="cov0" title="0">return output</span>
}

// PercentDifference computes the percentage difference between two values.
// The formula is (v2-v1)/v1.
func (mu mathUtil) PercentDifference(v1, v2 float64) float64 <span class="cov0" title="0">{
        if v1 == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return (v2 - v1) / v1</span>
}

// DegreesToRadians returns degrees as radians.
func (mu mathUtil) DegreesToRadians(degrees float64) float64 <span class="cov0" title="0">{
        return degrees * _d2r
}</span>

// RadiansToDegrees translates a radian value to a degree value.
func (mu mathUtil) RadiansToDegrees(value float64) float64 <span class="cov0" title="0">{
        return math.Mod(value, _2pi) * _r2d
}</span>

// PercentToRadians converts a normalized value (0,1) to radians.
func (mu mathUtil) PercentToRadians(pct float64) float64 <span class="cov0" title="0">{
        return mu.DegreesToRadians(360.0 * pct)
}</span>

// RadianAdd adds a delta to a base in radians.
func (mu mathUtil) RadianAdd(base, delta float64) float64 <span class="cov0" title="0">{
        value := base + delta
        if value &gt; _2pi </span><span class="cov0" title="0">{
                return math.Mod(value, _2pi)
        }</span> else<span class="cov0" title="0"> if value &lt; 0 </span><span class="cov0" title="0">{
                return math.Mod(_2pi+value, _2pi)
        }</span>
        <span class="cov0" title="0">return value</span>
}

// DegreesAdd adds a delta to a base in radians.
func (mu mathUtil) DegreesAdd(baseDegrees, deltaDegrees float64) float64 <span class="cov0" title="0">{
        value := baseDegrees + deltaDegrees
        if value &gt; _2pi </span><span class="cov0" title="0">{
                return math.Mod(value, 360.0)
        }</span> else<span class="cov0" title="0"> if value &lt; 0 </span><span class="cov0" title="0">{
                return math.Mod(360.0+value, 360.0)
        }</span>
        <span class="cov0" title="0">return value</span>
}

// DegreesToCompass returns the degree value in compass / clock orientation.
func (mu mathUtil) DegreesToCompass(deg float64) float64 <span class="cov0" title="0">{
        return mu.DegreesAdd(deg, -90.0)
}</span>

func (mu mathUtil) InEpsilon(a, b float64) bool <span class="cov8" title="1">{
        return (a-b) &lt; Epsilon &amp;&amp; (b-a) &lt; Epsilon
}</span>

// float64ToInt rounds a float64 to an int
func float64ToInt(input float64) (output int) <span class="cov8" title="1">{
        r := Math.Round(input, 0)
        return int(r)
}</span>

// copyslice copies a slice of float64s
func copyslice(input []float64) []float64 <span class="cov8" title="1">{
        s := make([]float64, len(input))
        copy(s, input)
        return s
}</span>
</pre>
		
		<pre class="file" id="file114" style="display: none">package util

import "time"

// OptionalUInt8 returns a pointer to a value
func OptionalUInt8(value uint8) *uint8 <span class="cov0" title="0">{
        return &amp;value
}</span>

// OptionalUInt16 returns a pointer to a value
func OptionalUInt16(value uint16) *uint16 <span class="cov0" title="0">{
        return &amp;value
}</span>

// OptionalUInt returns a pointer to a value
func OptionalUInt(value uint) *uint <span class="cov0" title="0">{
        return &amp;value
}</span>

// OptionalUInt64 returns a pointer to a value
func OptionalUInt64(value uint64) *uint64 <span class="cov0" title="0">{
        return &amp;value
}</span>

// OptionalInt16 returns a pointer to a value
func OptionalInt16(value int16) *int16 <span class="cov0" title="0">{
        return &amp;value
}</span>

// OptionalInt returns a pointer to a value
func OptionalInt(value int) *int <span class="cov0" title="0">{
        return &amp;value
}</span>

// OptionalInt32 returns a pointer to a value
func OptionalInt32(value int32) *int32 <span class="cov0" title="0">{
        return &amp;value
}</span>

// OptionalInt64 returns a pointer to a value
func OptionalInt64(value int64) *int64 <span class="cov0" title="0">{
        return &amp;value
}</span>

// OptionalFloat32 returns a pointer to a value
func OptionalFloat32(value float32) *float32 <span class="cov0" title="0">{
        return &amp;value
}</span>

// OptionalFloat64 returns a pointer to a value
func OptionalFloat64(value float64) *float64 <span class="cov0" title="0">{
        return &amp;value
}</span>

// OptionalString returns a pointer to a value
func OptionalString(value string) *string <span class="cov0" title="0">{
        return &amp;value
}</span>

// OptionalBool returns a pointer to a value
func OptionalBool(value bool) *bool <span class="cov0" title="0">{
        return &amp;value
}</span>

// OptionalTime returns a pointer to a value
func OptionalTime(value time.Time) *time.Time <span class="cov0" title="0">{
        return &amp;value
}</span>

// OptionalDuration returns a pointer to a value
func OptionalDuration(value time.Duration) *time.Duration <span class="cov0" title="0">{
        return &amp;value
}</span>
</pre>
		
		<pre class="file" id="file115" style="display: none">package util

import (
        "fmt"
        "reflect"
        "sync"
)

var (
        // Parallel contains parallel utils.
        Parallel = parallelUtil{}
)

type parallelUtil struct{}

func (pu parallelUtil) Each(collection interface{}, parallelism int, action func(interface{})) error <span class="cov8" title="1">{
        t := reflect.TypeOf(collection)
        for t.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                t = t.Elem()
        }</span>

        <span class="cov8" title="1">v := reflect.ValueOf(collection)
        for v.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                v = v.Elem()
        }</span>

        <span class="cov8" title="1">if t.Kind() != reflect.Slice </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot iterate over non-slice")
        }</span>

        <span class="cov8" title="1">effectiveParallelism := parallelism
        if parallelism &gt; v.Len() </span><span class="cov8" title="1">{
                effectiveParallelism = v.Len()
        }</span>
        <span class="cov8" title="1">if effectiveParallelism &lt; 1 </span><span class="cov0" title="0">{
                effectiveParallelism = 1
        }</span>

        // edge case, drop into single iterator, do not allocate any
        // goroutines.
        <span class="cov8" title="1">if effectiveParallelism == 1 </span><span class="cov8" title="1">{
                for i := 0; i &lt; v.Len(); i++ </span><span class="cov8" title="1">{
                        action(v.Index(i).Interface())
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">wg := sync.WaitGroup{}
        wg.Add(effectiveParallelism)

        for threadID := 0; threadID &lt; effectiveParallelism; threadID++ </span><span class="cov8" title="1">{
                go func(startIndex int) </span><span class="cov8" title="1">{
                        defer wg.Done()
                        pu.parallelIterator(v, startIndex, effectiveParallelism, action)
                }</span>(threadID)
        }

        <span class="cov8" title="1">wg.Wait()
        return nil</span>
}

func (pu parallelUtil) parallelIterator(collectionValue reflect.Value, startIndex, parallelism int, action func(interface{})) <span class="cov8" title="1">{
        for i := startIndex; i &lt; collectionValue.Len(); i += parallelism </span><span class="cov8" title="1">{
                action(collectionValue.Index(i).Interface())
        }</span>
}

// Await waits for all actions to complete.
func (pu parallelUtil) Await(actions ...func()) <span class="cov8" title="1">{
        wg := sync.WaitGroup{}
        wg.Add(len(actions))
        for i := 0; i &lt; len(actions); i++ </span><span class="cov8" title="1">{
                action := actions[i]
                go func() </span><span class="cov8" title="1">{
                        action()
                        wg.Done()
                }</span>()
        }

        <span class="cov8" title="1">wg.Wait()</span>
}
</pre>
		
		<pre class="file" id="file116" style="display: none">package util

import (
        "strconv"

        "github.com/blend/go-sdk/exception"
)

// Parse contains utilities to parse strings.
var Parse = new(parseUtil)

type parseUtil struct{}

// ParseFloat64 parses a float64
func (pu parseUtil) Float64(input string) float64 <span class="cov8" title="1">{
        result, err := strconv.ParseFloat(input, 64)
        if err != nil </span><span class="cov8" title="1">{
                return 0.0
        }</span>
        <span class="cov8" title="1">return result</span>
}

// ParseFloat32 parses a float32
func (pu parseUtil) Float32(input string) float32 <span class="cov8" title="1">{
        result, err := strconv.ParseFloat(input, 32)
        if err != nil </span><span class="cov8" title="1">{
                return 0.0
        }</span>
        <span class="cov8" title="1">return float32(result)</span>
}

// ParseInt parses an int
func (pu parseUtil) Int(input string) int <span class="cov8" title="1">{
        result, err := strconv.Atoi(input)
        if err != nil </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">return result</span>
}

// ParseInt32 parses an int
func (pu parseUtil) Int32(input string) int32 <span class="cov0" title="0">{
        result, err := strconv.Atoi(input)
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return int32(result)</span>
}

// ParseInt64 parses an int64
func (pu parseUtil) Int64(input string) int64 <span class="cov0" title="0">{
        result, err := strconv.ParseInt(input, 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                return int64(0)
        }</span>
        <span class="cov0" title="0">return result</span>
}

// Ints parses a list of values as integers.
func (pu parseUtil) Ints(values ...string) (output []int, err error) <span class="cov0" title="0">{
        output = make([]int, len(values))
        var val int
        for i, v := range values </span><span class="cov0" title="0">{
                val, err = strconv.Atoi(v)
                if err != nil </span><span class="cov0" title="0">{
                        err = exception.Wrap(err)
                        return
                }</span>
                <span class="cov0" title="0">output[i] = val</span>
        }
        <span class="cov0" title="0">return</span>
}

// Int64s parses a list of values as integers.
func (pu parseUtil) Int64s(values ...string) (output []int64, err error) <span class="cov0" title="0">{
        output = make([]int64, len(values))
        var val int64
        for i, v := range values </span><span class="cov0" title="0">{
                val, err = strconv.ParseInt(v, 10, 64)
                if err != nil </span><span class="cov0" title="0">{
                        err = exception.Wrap(err)
                        return
                }</span>
                <span class="cov0" title="0">output[i] = val</span>
        }
        <span class="cov0" title="0">return</span>
}

// Float64s parses a list of values as floats.
func (pu parseUtil) Float64s(values ...string) (output []float64, err error) <span class="cov0" title="0">{
        output = make([]float64, len(values))
        var val float64
        for i, v := range values </span><span class="cov0" title="0">{
                val, err = strconv.ParseFloat(v, 64)
                if err != nil </span><span class="cov0" title="0">{
                        err = exception.Wrap(err)
                        return
                }</span>
                <span class="cov0" title="0">output[i] = val</span>
        }
        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file117" style="display: none">package util

import (
        "math/rand"
        "time"
)

var (
        provider = rand.New(rand.NewSource(time.Now().UnixNano()))
)

// RandomProvider returns a centralized random provider, seeded with time.Now().UnixNano().
func RandomProvider() *rand.Rand <span class="cov0" title="0">{
        return provider
}</span>
</pre>
		
		<pre class="file" id="file118" style="display: none">package util

import (
        "fmt"
        "reflect"
        "strings"

        "github.com/blend/go-sdk/exception"
)

var (
        // Reflection is a namespace for reflection utilities.
        Reflection = reflectionUtil{}
)

// Patchable describes an object that can be patched with raw values.
type Patchable interface {
        Patch(values map[string]interface{}) error
}

type reflectionUtil struct{}

// FollowValuePointer derefs a reflectValue until it isn't a pointer, but will preseve it's nilness.
func (ru reflectionUtil) FollowValuePointer(v reflect.Value) interface{} <span class="cov8" title="1">{
        if v.Kind() == reflect.Ptr &amp;&amp; v.IsNil() </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">val := v
        for val.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                val = val.Elem()
        }</span>
        <span class="cov8" title="1">return val.Interface()</span>
}

// FollowType derefs a type until it isn't a pointer or an interface.
func (ru reflectionUtil) FollowType(t reflect.Type) reflect.Type <span class="cov0" title="0">{
        for t.Kind() == reflect.Ptr || t.Kind() == reflect.Interface </span><span class="cov0" title="0">{
                t = t.Elem()
        }</span>
        <span class="cov0" title="0">return t</span>
}

// FollowValue derefs a value until it isn't a pointer or an interface.
func (ru reflectionUtil) FollowValue(v reflect.Value) reflect.Value <span class="cov8" title="1">{
        for v.Kind() == reflect.Ptr || v.Kind() == reflect.Interface </span><span class="cov0" title="0">{
                v = v.Elem()
        }</span>
        <span class="cov8" title="1">return v</span>
}

// ReflectValue returns the integral reflect.Value for an object.
func (ru reflectionUtil) ReflectValue(obj interface{}) reflect.Value <span class="cov8" title="1">{
        v := reflect.ValueOf(obj)
        for v.Kind() == reflect.Ptr || v.Kind() == reflect.Interface </span><span class="cov8" title="1">{
                v = v.Elem()
        }</span>
        <span class="cov8" title="1">return v</span>
}

// ReflectType returns the integral type for an object.
func (ru reflectionUtil) ReflectType(obj interface{}) reflect.Type <span class="cov8" title="1">{
        t := reflect.TypeOf(obj)
        for t.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                t = t.Elem()
        }</span>

        <span class="cov8" title="1">return t</span>
}

// MakeNew returns a new instance of a reflect.Type.
func (ru reflectionUtil) MakeNew(t reflect.Type) interface{} <span class="cov0" title="0">{
        return reflect.New(t).Interface()
}</span>

// MakeSliceOfType returns a new slice of a given reflect.Type.
func (ru reflectionUtil) MakeSliceOfType(t reflect.Type) interface{} <span class="cov0" title="0">{
        return reflect.New(reflect.SliceOf(t)).Interface()
}</span>

// TypeName returns the string type name for an object's integral type.
func (ru reflectionUtil) TypeName(obj interface{}) string <span class="cov0" title="0">{
        return ru.ReflectType(obj).Name()
}</span>

// GetValueByName returns a value for a given struct field by name.
func (ru reflectionUtil) GetValueByName(target interface{}, fieldName string) interface{} <span class="cov0" title="0">{
        targetValue := ru.ReflectValue(target)
        field := targetValue.FieldByName(fieldName)
        return field.Interface()
}</span>

// GetFieldByNameOrJSONTag returns a value for a given struct field by name or by json tag name.
func (ru reflectionUtil) GetFieldByNameOrJSONTag(targetValue reflect.Type, fieldName string) *reflect.StructField <span class="cov8" title="1">{
        for index := 0; index &lt; targetValue.NumField(); index++ </span><span class="cov8" title="1">{
                field := targetValue.Field(index)

                if field.Name == fieldName </span><span class="cov0" title="0">{
                        return &amp;field
                }</span>
                <span class="cov8" title="1">tag := field.Tag
                jsonTag := tag.Get("json")
                if String.CaseInsensitiveEquals(jsonTag, fieldName) </span><span class="cov8" title="1">{
                        return &amp;field
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (ru reflectionUtil) SetValueByName(target interface{}, fieldName string, fieldValue interface{}) error <span class="cov0" title="0">{
        targetValue := ru.ReflectValue(target)
        targetType := ru.ReflectType(target)
        return ru.SetValueByNameFromType(target, targetType, targetValue, fieldName, fieldValue)
}</span>

// SetValueByName sets a value on an object by its field name.
func (ru reflectionUtil) SetValueByNameFromType(obj interface{}, targetType reflect.Type, targetValue reflect.Value, fieldName string, fieldValue interface{}) (err error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = exception.Newf("panic setting value by name").WithMessagef("field: %s panic: %v", fieldName, r)
                }</span>
        }()

        <span class="cov8" title="1">relevantField := ru.GetFieldByNameOrJSONTag(targetType, fieldName)
        if relevantField == nil </span><span class="cov0" title="0">{
                err = exception.New("unknown field").WithMessagef("%s `%s`", targetType.Name(), fieldName)
                return
        }</span>

        <span class="cov8" title="1">field := targetValue.FieldByName(relevantField.Name)
        if !field.CanSet() </span><span class="cov0" title="0">{
                err = exception.New("cannot set field").WithMessagef("%s `%s`", targetType.Name(), fieldName)
                return
        }</span>

        <span class="cov8" title="1">fieldType := field.Type()
        value := ru.ReflectValue(fieldValue)
        valueType := value.Type()
        if !value.IsValid() </span><span class="cov0" title="0">{
                err = exception.New("invalid value").WithMessagef("%s `%s`", targetType.Name(), fieldName)
                return
        }</span>

        <span class="cov8" title="1">assigned, assignErr := ru.tryAssignment(fieldType, valueType, field, value)
        if assignErr != nil </span><span class="cov0" title="0">{
                err = assignErr
                return
        }</span>
        <span class="cov8" title="1">if !assigned </span><span class="cov0" title="0">{
                err = exception.New("cannot set field").WithMessagef("%s `%s`", targetType.Name(), fieldName)
                return
        }</span>
        <span class="cov8" title="1">return</span>
}

func (ru reflectionUtil) tryAssignment(fieldType, valueType reflect.Type, field, value reflect.Value) (assigned bool, err error) <span class="cov8" title="1">{
        if valueType.AssignableTo(fieldType) </span><span class="cov8" title="1">{
                field.Set(value)
                assigned = true
                return
        }</span>

        <span class="cov0" title="0">if valueType.ConvertibleTo(fieldType) </span><span class="cov0" title="0">{
                convertedValue := value.Convert(fieldType)
                if convertedValue.Type().AssignableTo(fieldType) </span><span class="cov0" title="0">{
                        field.Set(convertedValue)
                        assigned = true
                        return
                }</span>
        }

        <span class="cov0" title="0">if fieldType.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                if valueType.AssignableTo(fieldType.Elem()) </span><span class="cov0" title="0">{
                        elem := reflect.New(fieldType.Elem())
                        elem.Elem().Set(value)
                        field.Set(elem)
                        assigned = true
                        return
                }</span> else<span class="cov0" title="0"> if valueType.ConvertibleTo(fieldType.Elem()) </span><span class="cov0" title="0">{
                        elem := reflect.New(fieldType.Elem())
                        elem.Elem().Set(value.Convert(fieldType.Elem()))
                        field.Set(elem)
                        assigned = true
                        return
                }</span>
        }

        <span class="cov0" title="0">return</span>
}

// PatchObject updates an object based on a map of field names to values.
func (ru reflectionUtil) PatchObject(obj interface{}, patchValues map[string]interface{}) (err error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = exception.Newf("%v", r)
                }</span>
        }()

        <span class="cov8" title="1">if patchable, isPatchable := obj.(Patchable); isPatchable </span><span class="cov0" title="0">{
                return patchable.Patch(patchValues)
        }</span>

        <span class="cov8" title="1">targetValue := ru.ReflectValue(obj)
        targetType := targetValue.Type()

        for key, value := range patchValues </span><span class="cov8" title="1">{
                err = ru.SetValueByNameFromType(obj, targetType, targetValue, key, value)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// KeyValuePairOfString is a pair of string values.
type KeyValuePairOfString struct {
        Key, Value string
}

// DecomposeToPostData dumps an object to a slice of key value tuples representing field name as form value and string value of field.
func (ru reflectionUtil) DecomposeToPostData(object interface{}) []KeyValuePairOfString <span class="cov8" title="1">{
        kvps := []KeyValuePairOfString{}

        objType := ru.ReflectType(object)
        objValue := ru.ReflectValue(object)

        numberOfFields := objType.NumField()
        for index := 0; index &lt; numberOfFields; index++ </span><span class="cov8" title="1">{
                field := objType.Field(index)
                valueField := objValue.Field(index)

                kvp := KeyValuePairOfString{}

                if !field.Anonymous </span><span class="cov8" title="1">{
                        tag := field.Tag.Get("json")
                        if len(tag) != 0 </span><span class="cov8" title="1">{
                                if strings.Contains(tag, ",") </span><span class="cov0" title="0">{
                                        parts := strings.Split(tag, ",")
                                        kvp.Key = parts[0]
                                }</span> else<span class="cov8" title="1"> {
                                        kvp.Key = tag
                                }</span>
                        } else<span class="cov8" title="1"> {
                                kvp.Key = field.Name
                        }</span>

                        <span class="cov8" title="1">if field.Type.Kind() == reflect.Slice </span><span class="cov8" title="1">{
                                //do something special
                                for subIndex := 0; subIndex &lt; valueField.Len(); subIndex++ </span><span class="cov8" title="1">{
                                        itemAtIndex := valueField.Index(subIndex).Interface()
                                        for _, prop := range ru.DecomposeToPostData(itemAtIndex) </span><span class="cov8" title="1">{
                                                if len(prop.Value) != 0 </span><span class="cov8" title="1">{ //this is a gutcheck, it shouldn't be needed
                                                        ikvp := KeyValuePairOfString{}
                                                        ikvp.Key = fmt.Sprintf("%s[%d].%s", kvp.Key, subIndex, prop.Key)
                                                        ikvp.Value = prop.Value
                                                        kvps = append(kvps, ikvp)
                                                }</span>
                                        }
                                }
                        } else<span class="cov8" title="1"> {
                                value := ru.FollowValuePointer(valueField)
                                if value != nil </span><span class="cov8" title="1">{
                                        kvp.Value = fmt.Sprintf("%v", value)
                                        if len(kvp.Value) != 0 </span><span class="cov8" title="1">{
                                                kvps = append(kvps, kvp)
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">return kvps</span>
}

// DecomposeToPostDataAsJSON returns an array of KeyValuePairOfString for an object.
func (ru reflectionUtil) DecomposeToPostDataAsJSON(object interface{}) []KeyValuePairOfString <span class="cov8" title="1">{
        kvps := []KeyValuePairOfString{}

        objType := ru.ReflectType(object)
        objValue := ru.ReflectValue(object)

        numberOfFields := objType.NumField()
        for index := 0; index &lt; numberOfFields; index++ </span><span class="cov8" title="1">{
                field := objType.Field(index)
                valueField := objValue.Field(index)

                kvp := KeyValuePairOfString{}

                if !field.Anonymous </span><span class="cov8" title="1">{
                        tag := field.Tag.Get("json")
                        if len(tag) != 0 </span><span class="cov8" title="1">{
                                if strings.Contains(tag, ",") </span><span class="cov0" title="0">{
                                        parts := strings.Split(tag, ",")
                                        kvp.Key = parts[0]
                                }</span> else<span class="cov8" title="1"> {
                                        kvp.Key = tag
                                }</span>
                        } else<span class="cov8" title="1"> {
                                kvp.Key = field.Name
                        }</span>

                        <span class="cov8" title="1">valueDereferenced := ru.FollowValue(valueField)
                        value := ru.FollowValuePointer(valueField)
                        if value != nil </span><span class="cov8" title="1">{
                                if valueDereferenced.Kind() == reflect.Slice || valueDereferenced.Kind() == reflect.Map </span><span class="cov8" title="1">{
                                        kvp.Value = JSON.Serialize(value)
                                }</span> else<span class="cov8" title="1"> {
                                        kvp.Value = fmt.Sprintf("%v", value)
                                }</span>
                        }

                        <span class="cov8" title="1">if len(kvp.Value) != 0 </span><span class="cov8" title="1">{
                                kvps = append(kvps, kvp)
                        }</span>
                }
        }

        <span class="cov8" title="1">return kvps</span>
}

// Decompose is a *very* inefficient way to turn an object into a map string =&gt; interface.
func (ru reflectionUtil) Decompose(object interface{}) map[string]interface{} <span class="cov8" title="1">{
        var output map[string]interface{}
        JSON.Deserialize(&amp;output, JSON.Serialize(object))
        return output
}</span>

// checks if a value is a zero value or its types default value
func (ru reflectionUtil) IsZero(v reflect.Value) bool <span class="cov8" title="1">{
        if !v.IsValid() </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">switch v.Kind() </span>{
        case reflect.Func, reflect.Map, reflect.Slice:<span class="cov8" title="1">
                return v.IsNil()</span>
        case reflect.Array:<span class="cov0" title="0">
                z := true
                for i := 0; i &lt; v.Len(); i++ </span><span class="cov0" title="0">{
                        z = z &amp;&amp; ru.IsZero(v.Index(i))
                }</span>
                <span class="cov0" title="0">return z</span>
        case reflect.Struct:<span class="cov8" title="1">
                z := true
                for i := 0; i &lt; v.NumField(); i++ </span><span class="cov8" title="1">{
                        z = z &amp;&amp; ru.IsZero(v.Field(i))
                }</span>
                <span class="cov8" title="1">return z</span>
        }
        // Compare other types directly:
        <span class="cov8" title="1">z := reflect.Zero(v.Type())
        return v.Interface() == z.Interface()</span>
}

// IsExported returns if a field is exported given its name and capitalization.
func (ru reflectionUtil) IsExported(fieldName string) bool <span class="cov8" title="1">{
        return fieldName != "" &amp;&amp; strings.ToUpper(fieldName)[0] == fieldName[0]
}</span>

// CoalesceFields merges non-zero fields into destination fields marked with the `coalesce:...` struct field tag.
func (ru reflectionUtil) CoalesceFields(object interface{}) <span class="cov8" title="1">{
        objectValue := ru.ReflectValue(object)
        objectType := ru.ReflectType(object)
        if objectType.Kind() == reflect.Struct </span><span class="cov8" title="1">{
                numberOfFields := objectValue.NumField()
                for index := 0; index &lt; numberOfFields; index++ </span><span class="cov8" title="1">{
                        field := objectType.Field(index)
                        fieldValue := objectValue.Field(index)
                        // only alter the field if it is exported (uppercase variable name) and is not already a non-zero value
                        if ru.IsExported(field.Name) &amp;&amp; ru.IsZero(fieldValue) </span><span class="cov8" title="1">{
                                alternateFieldNames := strings.Split(field.Tag.Get("coalesce"), ",")

                                // find the first non-zero value in the list of backup values
                                for j := 0; j &lt; len(alternateFieldNames); j++ </span><span class="cov8" title="1">{
                                        alternateFieldName := alternateFieldNames[j]
                                        alternateValue := objectValue.FieldByName(alternateFieldName)
                                        // will panic if trying to set a non-exported value or a zero value, so ignore those
                                        if ru.IsExported(alternateFieldName) &amp;&amp; !ru.IsZero(alternateValue) </span><span class="cov8" title="1">{
                                                fieldValue.Set(alternateValue)
                                                break</span>
                                        }
                                }
                        }
                        // recurse, in case nested values of this field need to be set as well
                        <span class="cov8" title="1">if ru.IsExported(field.Name) &amp;&amp; !ru.IsZero(fieldValue) </span><span class="cov8" title="1">{
                                ru.CoalesceFields(fieldValue.Addr().Interface())
                        }</span>
                }
        } else<span class="cov8" title="1"> if objectType.Kind() == reflect.Array || objectType.Kind() == reflect.Slice </span><span class="cov8" title="1">{
                arrayLength := objectValue.Len()
                for i := 0; i &lt; arrayLength; i++ </span><span class="cov8" title="1">{
                        ru.CoalesceFields(objectValue.Index(i).Addr().Interface())
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file119" style="display: none">package util

// Sequence is a namespace singleton for sequence utilities.
var Sequence sequenceUtil

type sequenceUtil struct{}

// Ints returns a sequence [0, end).
func (su sequenceUtil) Ints(end int) (values []int) <span class="cov8" title="1">{
        for i := 0; i &lt; end; i++ </span><span class="cov8" title="1">{
                values = append(values, i)
        }</span>
        <span class="cov8" title="1">return</span>
}

// IntsFrom returns a sequence [start, end).
func (su sequenceUtil) IntsFrom(start, end int) (values []int) <span class="cov8" title="1">{
        for i := start; i &lt; end; i++ </span><span class="cov8" title="1">{
                values = append(values, i)
        }</span>
        <span class="cov8" title="1">return</span>
}

// IntsFrom returns a sequence [start, end).
func (su sequenceUtil) IntsFromBy(start, end, by int) (values []int) <span class="cov8" title="1">{
        for i := start; i &lt; end; i += by </span><span class="cov8" title="1">{
                values = append(values, i)
        }</span>
        <span class="cov8" title="1">return</span>
}

// Floats returns a sequence [0, end).
func (su sequenceUtil) Floats(end float64) (values []float64) <span class="cov0" title="0">{
        for i := 0.0; i &lt; end; i++ </span><span class="cov0" title="0">{
                values = append(values, i)
        }</span>
        <span class="cov0" title="0">return</span>
}

// FloatsFrom returns a sequence [start, end).
func (su sequenceUtil) FloatsFrom(start, end float64) (values []float64) <span class="cov0" title="0">{
        for i := start; i &lt; end; i++ </span><span class="cov0" title="0">{
                values = append(values, i)
        }</span>
        <span class="cov0" title="0">return</span>
}

// FloatsFrom returns a sequence [start, end).
func (su sequenceUtil) FloatsFromBy(start, end, by float64) (values []float64) <span class="cov0" title="0">{
        for i := start; i &lt; end; i += by </span><span class="cov0" title="0">{
                values = append(values, i)
        }</span>
        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file120" style="display: none">package util

import (
        "crypto/aes"
        "crypto/cipher"
        "crypto/hmac"
        "crypto/sha256"
        "hash"
        "io"
        "math/rand"

        "github.com/blend/go-sdk/exception"
)

// EncryptedStream is metadata about an encrypted stream
type EncryptedStream struct {
        // IV is the initial value for the crypto function
        IV []byte
        // Hash is the sha256 hmac of the stream
        Hash []byte
}

// StreamEncrypter is an encrypter for a stream of data with authentication
type StreamEncrypter struct {
        src    io.Reader
        block  cipher.Block
        stream cipher.Stream
        mac    hash.Hash
        iv     []byte
}

// StreamDecrypter is a decrypter for a stream of data with authentication
type StreamDecrypter struct {
        src    io.Reader
        block  cipher.Block
        stream cipher.Stream
        mac    hash.Hash
        meta   *EncryptedStream
}

// NewStreamEncrypter creates a new stream encrypter
func NewStreamEncrypter(key []byte, plainText io.Reader) (*StreamEncrypter, error) <span class="cov8" title="1">{
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>
        <span class="cov8" title="1">iv := make([]byte, block.BlockSize())
        _, err = rand.Read(iv)
        if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>
        <span class="cov8" title="1">stream := cipher.NewCTR(block, iv)
        mac := hmac.New(sha256.New, key)
        return &amp;StreamEncrypter{
                src:    plainText,
                block:  block,
                stream: stream,
                mac:    mac,
                iv:     iv,
        }, nil</span>
}

// NewStreamDecrypter creates a new stream decrypter
func NewStreamDecrypter(key []byte, meta *EncryptedStream, cipherText io.Reader) (*StreamDecrypter, error) <span class="cov8" title="1">{
        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>
        <span class="cov8" title="1">stream := cipher.NewCTR(block, meta.IV)
        mac := hmac.New(sha256.New, key)
        return &amp;StreamDecrypter{
                src:    cipherText,
                block:  block,
                stream: stream,
                mac:    mac,
                meta:   meta,
        }, nil</span>
}

// Read encrypts the bytes of the inner reader and places them into p
func (s *StreamEncrypter) Read(p []byte) (int, error) <span class="cov8" title="1">{
        n, readErr := s.src.Read(p)
        if n &gt; 0 </span><span class="cov8" title="1">{
                err := writeHash(s.mac, p[:n])
                if err != nil </span><span class="cov0" title="0">{
                        return n, exception.Wrap(err)
                }</span>
                <span class="cov8" title="1">s.stream.XORKeyStream(p[:n], p[:n])
                return n, readErr</span>
        }
        <span class="cov8" title="1">return 0, io.EOF</span>
}

// Meta returns the encrypted stream metadata for use in decrypting. This should only be called after the stream is finished
func (s *StreamEncrypter) Meta() *EncryptedStream <span class="cov8" title="1">{
        return &amp;EncryptedStream{IV: s.iv, Hash: s.mac.Sum(nil)}
}</span>

// Read reads bytes from the underlying reader and then decrypts them
func (s *StreamDecrypter) Read(p []byte) (int, error) <span class="cov8" title="1">{
        n, readErr := s.src.Read(p)
        if n &gt; 0 </span><span class="cov8" title="1">{
                s.stream.XORKeyStream(p[:n], p[:n])
                err := writeHash(s.mac, p[:n])
                if err != nil </span><span class="cov0" title="0">{
                        return n, exception.Wrap(err)
                }</span>
                <span class="cov8" title="1">return n, readErr</span>
        }
        <span class="cov8" title="1">return 0, io.EOF</span>
}

// Authenticate verifys that the hash of the stream is correct. This should only be called after processing is finished
func (s *StreamDecrypter) Authenticate() error <span class="cov8" title="1">{
        if !hmac.Equal(s.meta.Hash, s.mac.Sum(nil)) </span><span class="cov0" title="0">{
                return exception.Newf("Authentication failed")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func writeHash(mac hash.Hash, p []byte) error <span class="cov8" title="1">{
        m, err := mac.Write(p)
        if err != nil </span><span class="cov0" title="0">{
                return exception.Wrap(err)
        }</span>
        <span class="cov8" title="1">if m != len(p) </span><span class="cov0" title="0">{
                return exception.Newf("Could not write all bytes to Hmac")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func writeToStream(p []byte, dst io.Writer) (int, error) <span class="cov0" title="0">{
        n, err := dst.Write(p)
        if err != nil </span><span class="cov0" title="0">{
                return n, exception.Wrap(err)
        }</span>
        <span class="cov0" title="0">if n != len(p) </span><span class="cov0" title="0">{
                return n, exception.Newf("Unable to write all bytes")
        }</span>
        <span class="cov0" title="0">return len(p), nil</span>
}
</pre>
		
		<pre class="file" id="file121" style="display: none">package util

import (
        "bytes"
        "encoding/base64"
        "fmt"
        "regexp"
        "strconv"
        "strings"
        "unicode"
)

const (
        // StringEmpty is the empty string
        StringEmpty string = ""

        // RuneSpace is a single rune representing a space.
        RuneSpace rune = ' '

        // RuneNewline is a single rune representing a newline.
        RuneNewline rune = '\n'

        // LowerA is the ascii int value for 'a'
        LowerA uint = uint('a')
        // LowerZ is the ascii int value for 'z'
        LowerZ uint = uint('z')
)

var (
        lowerDiff = (LowerZ - LowerA)

        // LowerLetters is a runset of lowercase letters.
        LowerLetters = []rune("abcdefghijklmnopqrstuvwxyz")

        // UpperLetters is a runset of uppercase letters.
        UpperLetters = []rune("ABCDEFGHIJKLMNOPQRSTUVWXYZ")

        // Letters is a runset of both lower and uppercase letters.
        Letters = append(LowerLetters, UpperLetters...)

        // Numbers is a runset of numeric characters.
        Numbers = []rune("0123456789")

        // LettersAndNumbers is a runset of letters and numeric characters.
        LettersAndNumbers = append(Letters, Numbers...)

        // Symbols is a runset of symbol characters.
        Symbols = []rune(`!@#$%^&amp;*()_+-=[]{}\|:;`)

        // LettersNumbersAndSymbols is a runset of letters, numbers and symbols.
        LettersNumbersAndSymbols = append(LettersAndNumbers, Symbols...)
)

var (
        // String is a namesapce for string utility functions.
        String = stringUtil{}
)

type stringUtil struct{}

// IsEmpty returns if a string is empty.
func (su stringUtil) IsEmpty(input string) bool <span class="cov8" title="1">{
        return len(input) == 0
}</span>

// EmptyCoalesce returns the first non-empty string.
func (su stringUtil) EmptyCoalesce(inputs ...string) string <span class="cov0" title="0">{
        for _, input := range inputs </span><span class="cov0" title="0">{
                if !su.IsEmpty(input) </span><span class="cov0" title="0">{
                        return input
                }</span>
        }
        <span class="cov0" title="0">return StringEmpty</span>
}

// CaseInsensitiveEquals compares two strings regardless of case.
func (su stringUtil) CaseInsensitiveEquals(a, b string) bool <span class="cov8" title="1">{
        aLen := len(a)
        bLen := len(b)
        if aLen != bLen </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for x := 0; x &lt; aLen; x++ </span><span class="cov8" title="1">{
                charA := uint(a[x])
                charB := uint(b[x])

                if charA-LowerA &lt;= lowerDiff </span><span class="cov8" title="1">{
                        charA = charA - 0x20
                }</span>
                <span class="cov8" title="1">if charB-LowerA &lt;= lowerDiff </span><span class="cov8" title="1">{
                        charB = charB - 0x20
                }</span>
                <span class="cov8" title="1">if charA != charB </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// HasPrefixCaseInsensitive returns if a corpus has a prefix regardless of casing.
func (su stringUtil) HasPrefixCaseInsensitive(corpus, prefix string) bool <span class="cov8" title="1">{
        corpusLen := len(corpus)
        prefixLen := len(prefix)

        if corpusLen &lt; prefixLen </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for x := 0; x &lt; prefixLen; x++ </span><span class="cov8" title="1">{
                charCorpus := uint(corpus[x])
                charPrefix := uint(prefix[x])

                if charCorpus-LowerA &lt;= lowerDiff </span><span class="cov8" title="1">{
                        charCorpus = charCorpus - 0x20
                }</span>

                <span class="cov8" title="1">if charPrefix-LowerA &lt;= lowerDiff </span><span class="cov8" title="1">{
                        charPrefix = charPrefix - 0x20
                }</span>
                <span class="cov8" title="1">if charCorpus != charPrefix </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// HasSuffixCaseInsensitive returns if a corpus has a suffix regardless of casing.
func (su stringUtil) HasSuffixCaseInsensitive(corpus, suffix string) bool <span class="cov8" title="1">{
        corpusLen := len(corpus)
        suffixLen := len(suffix)

        if corpusLen &lt; suffixLen </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for x := 0; x &lt; suffixLen; x++ </span><span class="cov8" title="1">{
                charCorpus := uint(corpus[corpusLen-(x+1)])
                charSuffix := uint(suffix[suffixLen-(x+1)])

                if charCorpus-LowerA &lt;= lowerDiff </span><span class="cov8" title="1">{
                        charCorpus = charCorpus - 0x20
                }</span>

                <span class="cov8" title="1">if charSuffix-LowerA &lt;= lowerDiff </span><span class="cov8" title="1">{
                        charSuffix = charSuffix - 0x20
                }</span>
                <span class="cov8" title="1">if charCorpus != charSuffix </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func (su stringUtil) TrimPrefixCaseInsensitive(corpus, prefix string) string <span class="cov8" title="1">{
        corpusLen := len(corpus)
        prefixLen := len(prefix)

        if corpusLen &lt; prefixLen </span><span class="cov8" title="1">{
                return corpus
        }</span>

        <span class="cov8" title="1">for x := 0; x &lt; prefixLen; x++ </span><span class="cov8" title="1">{
                charCorpus := uint(corpus[x])
                charPrefix := uint(prefix[x])

                if charCorpus-LowerA &lt;= lowerDiff </span><span class="cov8" title="1">{
                        charCorpus = charCorpus - 0x20
                }</span>

                <span class="cov8" title="1">if charPrefix-LowerA &lt;= lowerDiff </span><span class="cov8" title="1">{
                        charPrefix = charPrefix - 0x20
                }</span>
                <span class="cov8" title="1">if charCorpus != charPrefix </span><span class="cov8" title="1">{
                        return corpus
                }</span>
        }

        <span class="cov8" title="1">return corpus[prefixLen:]</span>
}

// TrimSuffixCaseInsensitive trims a case insensitive suffix from a corpus.
func (su stringUtil) TrimSuffixCaseInsensitive(corpus, suffix string) string <span class="cov8" title="1">{
        corpusLen := len(corpus)
        suffixLen := len(suffix)

        if corpusLen &lt; suffixLen </span><span class="cov8" title="1">{
                return corpus
        }</span>

        <span class="cov8" title="1">for x := 0; x &lt; suffixLen; x++ </span><span class="cov8" title="1">{
                charCorpus := uint(corpus[corpusLen-(x+1)])
                charSuffix := uint(suffix[suffixLen-(x+1)])

                if charCorpus-LowerA &lt;= lowerDiff </span><span class="cov8" title="1">{
                        charCorpus = charCorpus - 0x20
                }</span>

                <span class="cov8" title="1">if charSuffix-LowerA &lt;= lowerDiff </span><span class="cov8" title="1">{
                        charSuffix = charSuffix - 0x20
                }</span>

                <span class="cov8" title="1">if charCorpus != charSuffix </span><span class="cov8" title="1">{
                        return corpus
                }</span>
        }
        <span class="cov8" title="1">return corpus[:corpusLen-suffixLen]</span>
}

// IsLetter returns if a rune is in the ascii letter range.
func (su stringUtil) IsLetter(c rune) bool <span class="cov0" title="0">{
        return su.IsUpper(c) || su.IsLower(c)
}</span>

// IsUpper returns if a rune is in the ascii upper letter range.
func (su stringUtil) IsUpper(c rune) bool <span class="cov8" title="1">{
        return c &gt;= rune('A') &amp;&amp; c &lt;= rune('Z')
}</span>

// IsLower returns if a rune is in the ascii lower letter range.
func (su stringUtil) IsLower(c rune) bool <span class="cov8" title="1">{
        return c &gt;= rune('a') &amp;&amp; c &lt;= rune('z')
}</span>

// IsSymbol returns if the rune is in the symbol range.
func (su stringUtil) IsSymbol(c rune) bool <span class="cov8" title="1">{
        return c &gt;= rune(' ') &amp;&amp; c &lt;= rune('/')
}</span>

// CombinePathComponents combines string components of a path.
func (su stringUtil) CombinePathComponents(components ...string) string <span class="cov8" title="1">{
        slash := "/"
        fullPath := ""
        for index, component := range components </span><span class="cov8" title="1">{
                workingComponent := component
                if strings.HasPrefix(workingComponent, slash) </span><span class="cov8" title="1">{
                        workingComponent = strings.TrimPrefix(workingComponent, slash)
                }</span>

                <span class="cov8" title="1">if strings.HasSuffix(workingComponent, slash) </span><span class="cov8" title="1">{
                        workingComponent = strings.TrimSuffix(workingComponent, slash)
                }</span>

                <span class="cov8" title="1">if index != len(components)-1 </span><span class="cov8" title="1">{
                        fullPath = fullPath + workingComponent + slash
                }</span> else<span class="cov8" title="1"> {
                        fullPath = fullPath + workingComponent
                }</span>
        }
        <span class="cov8" title="1">return fullPath</span>
}

// Random returns a new random string composed of letters from the `letters` collection.
func (su stringUtil) Random(length int) string <span class="cov8" title="1">{
        return su.RandomLetters(length)
}</span>

// RandomLetters returns a new random string composed of letters from the `letters` collection.
func (su stringUtil) RandomLetters(length int) string <span class="cov8" title="1">{
        return su.RandomRunes(Letters, length)
}</span>

// RandomNumbers returns a random string of chars from the `numbers` collection.
func (su stringUtil) RandomNumbers(length int) string <span class="cov0" title="0">{
        return su.RandomRunes(Numbers, length)
}</span>

// RandomStringWithNumbers returns a random string composed of chars from the `lettersAndNumbers` collection.
func (su stringUtil) RandomStringWithNumbers(length int) string <span class="cov0" title="0">{
        return su.RandomRunes(LettersAndNumbers, length)
}</span>

// RandomStringWithNumbersAndSymbols returns a random string composed of chars from the `lettersNumbersAndSymbols` collection.
func (su stringUtil) RandomStringWithNumbersAndSymbols(length int) string <span class="cov0" title="0">{
        return su.RandomRunes(LettersNumbersAndSymbols, length)
}</span>

// RandomRunes returns a random selection of runes from the set.
func (su stringUtil) RandomRunes(runeset []rune, length int) string <span class="cov8" title="1">{
        runes := make([]rune, length)
        for index := range runes </span><span class="cov8" title="1">{
                runes[index] = runeset[provider.Intn(len(runeset))]
        }</span>
        <span class="cov8" title="1">return string(runes)</span>
}

// CombineRunsets combines given runsets into a single runset.
func (su stringUtil) CombineRunsets(runesets ...[]rune) []rune <span class="cov0" title="0">{
        output := []rune{}
        for _, set := range runesets </span><span class="cov0" title="0">{
                output = append(output, set...)
        }</span>
        <span class="cov0" title="0">return output</span>
}

// IsInteger returns if a string is an integer.
func (su stringUtil) IsInteger(input string) bool <span class="cov0" title="0">{
        _, convCrr := strconv.Atoi(input)
        return convCrr == nil
}</span>

// IsNumber returns if a string represents a number
func (su stringUtil) IsNumber(input string) bool <span class="cov8" title="1">{
        _, err := strconv.ParseFloat(input, 64)
        return err == nil
}</span>

// RegexMatch returns if a string matches a regexp.
func (su stringUtil) RegexMatch(input string, exp string) string <span class="cov8" title="1">{
        regexp := regexp.MustCompile(exp)
        matches := regexp.FindStringSubmatch(input)
        if len(matches) != 2 </span><span class="cov8" title="1">{
                return StringEmpty
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(matches[1])</span>
}

// RegexExtract returns all matches of a regex expr.
func (su stringUtil) RegexExtract(corpus, expr string) []string <span class="cov0" title="0">{
        re := regexp.MustCompile(expr)
        return re.FindAllString(corpus, -1)
}</span>

// RegexExtractSubMatches returns sub matches for an expr because go's regexp library is weird.
func (su stringUtil) RegexExtractSubMatches(corpus, expr string) []string <span class="cov8" title="1">{
        re := regexp.MustCompile(expr)
        allResults := re.FindAllStringSubmatch(corpus, -1)
        results := []string{}
        for _, resultSet := range allResults </span><span class="cov8" title="1">{
                for _, result := range resultSet </span><span class="cov8" title="1">{
                        results = append(results, result)
                }</span>
        }

        <span class="cov8" title="1">return results</span>
}

// FromInt turns an int into a string
func (su stringUtil) FromInt(input int) string <span class="cov8" title="1">{
        return strconv.Itoa(input)
}</span>

// FromInt64 turns an int64 into a string
func (su stringUtil) FromInt64(input int64) string <span class="cov8" title="1">{
        return strconv.FormatInt(input, 10)
}</span>

// FromFloat64 turns an float64 into a string
func (su stringUtil) FromFloat64(input float64) string <span class="cov8" title="1">{
        return strconv.FormatFloat(input, 'f', -1, 64)
}</span>

// Money turns an float64 into a string
func (su stringUtil) Money(money float64) string <span class="cov0" title="0">{
        return fmt.Sprintf("%.2f", money)
}</span>

// StripQuotes removes quote characters from a string.
func (su stringUtil) StripQuotes(input string) string <span class="cov8" title="1">{
        output := []rune{}
        for _, c := range input </span><span class="cov8" title="1">{
                if !(c == '\'' || c == '"') </span><span class="cov8" title="1">{
                        output = append(output, c)
                }</span>
        }
        <span class="cov8" title="1">return string(output)</span>
}

// TrimTo trims a string to a given length, i.e. the substring [0, length).
func (su stringUtil) TrimTo(val string, length int) string <span class="cov0" title="0">{
        if len(val) &gt; length </span><span class="cov0" title="0">{
                return val[0:length]
        }</span>
        <span class="cov0" title="0">return val</span>
}

// TrimWhitespace trims spaces and tabs from a string.
func (su stringUtil) TrimWhitespace(input string) string <span class="cov8" title="1">{
        return strings.TrimSpace(input)
}</span>

// IsCamelCase returns if a string is CamelCased.
// CamelCased in this sense is if a string has both upper and lower characters.
func (su stringUtil) IsCamelCase(input string) bool <span class="cov8" title="1">{
        hasLowers := false
        hasUppers := false

        for _, c := range input </span><span class="cov8" title="1">{
                if unicode.IsUpper(c) </span><span class="cov8" title="1">{
                        hasUppers = true
                }</span>
                <span class="cov8" title="1">if unicode.IsLower(c) </span><span class="cov8" title="1">{
                        hasLowers = true
                }</span>
        }

        <span class="cov8" title="1">return hasLowers &amp;&amp; hasUppers</span>
}

var nonTitleWords = map[string]bool{
        "and":     true,
        "the":     true,
        "a":       true,
        "an":      true,
        "but":     true,
        "or":      true,
        "on":      true,
        "in":      true,
        "with":    true,
        "for":     true,
        "either":  true,
        "neither": true,
        "nor":     true,
}

func (su stringUtil) ToTitleCase(corpus string) string <span class="cov8" title="1">{
        output := bytes.NewBuffer(nil)
        runes := []rune(corpus)

        haveSeenLetter := false
        var r rune
        for x := 0; x &lt; len(runes); x++ </span><span class="cov8" title="1">{
                r = runes[x]

                if unicode.IsLetter(r) </span><span class="cov8" title="1">{
                        if !haveSeenLetter </span><span class="cov8" title="1">{
                                output.WriteRune(unicode.ToUpper(r))
                                haveSeenLetter = true
                        }</span> else<span class="cov8" title="1"> {
                                output.WriteRune(unicode.ToLower(r))
                        }</span>
                } else<span class="cov8" title="1"> {
                        output.WriteRune(r)
                        haveSeenLetter = false
                }</span>
        }
        <span class="cov8" title="1">return output.String()</span>
}

// FixedWidth returns a fixed width, right aligned, string with a given minimum space padded width.
func (su stringUtil) FixedWidth(text string, width int) string <span class="cov8" title="1">{
        fixedToken := fmt.Sprintf("%%%d.%ds", width, width)
        return fmt.Sprintf(fixedToken, text)
}</span>

// FixedWidthLeftAligned returns a fixed width, left aligned, string with a given minimum space padded width.
func (su stringUtil) FixedWidthLeftAligned(text string, width int) string <span class="cov8" title="1">{
        if width &lt; len(text) </span><span class="cov8" title="1">{
                return text[0:width]
        }</span>
        <span class="cov8" title="1">fixedToken := fmt.Sprintf("%%-%ds", width)
        return fmt.Sprintf(fixedToken, text)</span>
}

func (su stringUtil) SplitOnSpace(text string) (output []string) <span class="cov8" title="1">{
        if len(text) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">var state int
        var word string
        for _, r := range text </span><span class="cov8" title="1">{
                switch state </span>{
                case 0:<span class="cov8" title="1"> // word
                        if unicode.IsSpace(r) </span><span class="cov8" title="1">{
                                if len(word) &gt; 0 </span><span class="cov8" title="1">{
                                        output = append(output, word)
                                        word = ""
                                }</span>
                                <span class="cov8" title="1">state = 1</span>
                        } else<span class="cov8" title="1"> {
                                word = word + string(r)
                        }</span>
                case 1:<span class="cov8" title="1">
                        if !unicode.IsSpace(r) </span><span class="cov8" title="1">{
                                word = string(r)
                                state = 0
                        }</span>
                }
        }

        <span class="cov8" title="1">if len(word) &gt; 0 </span><span class="cov8" title="1">{
                output = append(output, word)
        }</span>
        <span class="cov8" title="1">return</span>
}

// Tokenize replaces a given set of tokens in a corpus.
// Tokens should appear in the corpus in the form ${[KEY]} where [KEY] is the key in the map.
// Examples: corpus: "foo/${bar}/baz", { "${bar}": "bailey" } =&gt; "foo/bailey/baz"
// UTF-8 is handled via. runes.
func (su stringUtil) Tokenize(corpus string, tokens map[string]string) string <span class="cov8" title="1">{
        // there is no way to escape anything smaller than [3] b/c len("${}") == 3
        if len(corpus) &lt; 3 </span><span class="cov8" title="1">{
                return corpus
        }</span>
        // sanity check on tokens collection.
        <span class="cov8" title="1">if tokens == nil || len(tokens) == 0 </span><span class="cov0" title="0">{
                return corpus
        }</span>

        <span class="cov8" title="1">output := bytes.NewBuffer(nil)

        start0 := rune('$')
        start1 := rune('{')
        end0 := rune('}')

        var state int
        // working token is the full token (including ${ and }).
        // wokring key is the stuff within the ${ and }.
        var workingToken, workingKey *bytes.Buffer
        var key string

        for _, c := range corpus </span><span class="cov8" title="1">{
                switch state </span>{
                case 0:<span class="cov8" title="1"> // non-token, add to output
                        if c == start0 </span><span class="cov8" title="1">{
                                state = 1
                                workingToken = bytes.NewBuffer(nil)
                                workingToken.WriteRune(c)
                                continue</span>
                        }
                        <span class="cov8" title="1">output.WriteRune(c)
                        continue</span>
                case 1:<span class="cov8" title="1">
                        if c == start1 </span><span class="cov8" title="1">{
                                state = 2 //consume token key
                                workingToken.WriteRune(c)
                                workingKey = bytes.NewBuffer(nil)
                                continue</span>
                        }
                        <span class="cov0" title="0">state = 0
                        output.WriteString(workingToken.String())
                        output.WriteRune(c)
                        workingToken = nil
                        workingKey = nil
                        continue</span>
                case 2:<span class="cov8" title="1">
                        if c == end0 </span><span class="cov8" title="1">{
                                workingToken.WriteRune(c)
                                // lookup replacement token.
                                key = workingKey.String()
                                if value, hasValue := tokens[key]; hasValue </span><span class="cov8" title="1">{
                                        output.WriteString(value)
                                }</span> else<span class="cov8" title="1"> {
                                        output.WriteString(workingToken.String())
                                }</span>
                                <span class="cov8" title="1">workingToken = nil
                                workingKey = nil
                                state = 0
                                continue</span>
                        }
                        <span class="cov8" title="1">if c == start0 </span><span class="cov8" title="1">{
                                state = 3
                                workingToken.WriteRune(c)
                                workingKey.WriteRune(c)
                                continue</span>
                        }
                        <span class="cov8" title="1">workingToken.WriteRune(c)
                        workingKey.WriteRune(c)
                        continue</span>
                case 3:<span class="cov8" title="1">
                        if c == start1 </span><span class="cov8" title="1">{
                                state = 4
                                workingToken.WriteRune(c)
                                workingKey.WriteRune(c)
                                continue</span>
                        }
                        <span class="cov0" title="0">state = 2
                        workingToken.WriteRune(c)
                        workingKey.WriteRune(c)
                        continue</span>
                case 4:<span class="cov8" title="1">
                        if c == end0 </span><span class="cov8" title="1">{
                                state = 2
                                workingToken.WriteRune(c)
                                workingKey.WriteRune(c)
                                continue</span>
                        }
                        <span class="cov8" title="1">workingToken.WriteRune(c)
                        workingKey.WriteRune(c)
                        continue</span>
                }
        }

        <span class="cov8" title="1">return output.String()</span>
}

// SecureRandom generates a secure random string of bytes base64 encoded.
func (su stringUtil) SecureRandom(length int) (string, error) <span class="cov0" title="0">{
        b, err := Crypto.SecureRandomBytes(length)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return base64.URLEncoding.EncodeToString(b), nil</span>
}

// MustSecureRandom generates a secure random string of bytes base64 encoded.
func (su stringUtil) MustSecureRandom(length int) string <span class="cov0" title="0">{
        return base64.URLEncoding.EncodeToString(Crypto.MustSecureRandomBytes(length))
}</span>

// CSV produces a csv from a given set of values.
func (su stringUtil) CSV(values []string) string <span class="cov0" title="0">{
        return strings.Join(values, ",")
}</span>
</pre>
		
		<pre class="file" id="file122" style="display: none">package util

import "time"

// Ternary is a collection of ternary functions.
var Ternary = ternaryUtil{}

type ternaryUtil struct{}

func (tu *ternaryUtil) OfRune(condition bool, trueResult, falseResult rune) rune <span class="cov0" title="0">{
        if condition </span><span class="cov0" title="0">{
                return trueResult
        }</span>
        <span class="cov0" title="0">return falseResult</span>
}

func (tu *ternaryUtil) OfBytes(condition bool, trueResult, falseResult []byte) []byte <span class="cov0" title="0">{
        if condition </span><span class="cov0" title="0">{
                return trueResult
        }</span>
        <span class="cov0" title="0">return falseResult</span>
}

func (tu *ternaryUtil) OfInt(condition bool, trueResult, falseResult int) int <span class="cov0" title="0">{
        if condition </span><span class="cov0" title="0">{
                return trueResult
        }</span>
        <span class="cov0" title="0">return falseResult</span>
}

func (tu *ternaryUtil) OfInt64(condition bool, trueResult, falseResult int64) int64 <span class="cov0" title="0">{
        if condition </span><span class="cov0" title="0">{
                return trueResult
        }</span>
        <span class="cov0" title="0">return falseResult</span>
}

func (tu *ternaryUtil) OfFloat64(condition bool, trueResult, falseResult float64) float64 <span class="cov0" title="0">{
        if condition </span><span class="cov0" title="0">{
                return trueResult
        }</span>
        <span class="cov0" title="0">return falseResult</span>
}

func (tu *ternaryUtil) OfTime(condition bool, trueResult, falseResult time.Time) time.Time <span class="cov0" title="0">{
        if condition </span><span class="cov0" title="0">{
                return trueResult
        }</span>
        <span class="cov0" title="0">return falseResult</span>
}

func (tu *ternaryUtil) OfDuration(condition bool, trueResult, falseResult time.Duration) time.Duration <span class="cov0" title="0">{
        if condition </span><span class="cov0" title="0">{
                return trueResult
        }</span>
        <span class="cov0" title="0">return falseResult</span>
}

func (tu *ternaryUtil) OfString(condition bool, trueResult, falseResult string) string <span class="cov0" title="0">{
        if condition </span><span class="cov0" title="0">{
                return trueResult
        }</span>
        <span class="cov0" title="0">return falseResult</span>
}
</pre>
		
		<pre class="file" id="file123" style="display: none">package util

import (
        "strconv"
        "time"
        "unicode"
)

var (
        // Time is a namespace for time utility functions.
        Time = timeUtil{}
)

type timeUtil struct{}

func (tu timeUtil) CurrentTimeMillis() int64 <span class="cov0" title="0">{
        return tu.UnixMillis(time.Now().UTC())
}</span>

// FromMillis returns a time from an unix time in millis.
func (tu timeUtil) FromMillis(millis int64) time.Time <span class="cov8" title="1">{
        seconds := time.Duration(millis) / (time.Second / time.Millisecond)
        nanoSeconds := ((time.Duration(millis) * time.Millisecond) - (time.Duration(seconds) * time.Second)) / time.Nanosecond
        return time.Unix(int64(seconds), int64(nanoSeconds)).UTC()
}</span>

func (tu timeUtil) UnixMillis(t time.Time) int64 <span class="cov8" title="1">{
        return t.UnixNano() / int64(time.Millisecond)
}</span>

// NoonOn is a shortcut for On(Time(12,0,0), cd) a.k.a. noon on a given date.
func (tu timeUtil) NoonOn(cd time.Time) time.Time <span class="cov0" title="0">{
        return time.Date(cd.Year(), cd.Month(), cd.Day(), 12, 0, 0, 0, cd.Location())
}</span>

// IsWeekDay returns if the day is a monday-&gt;friday.
func (tu timeUtil) IsWeekDay(day time.Weekday) bool <span class="cov0" title="0">{
        return !tu.IsWeekendDay(day)
}</span>

// IsWeekendDay returns if the day is a monday-&gt;friday.
func (tu timeUtil) IsWeekendDay(day time.Weekday) bool <span class="cov0" title="0">{
        return day == time.Saturday || day == time.Sunday
}</span>

func (tu timeUtil) Millis(d time.Duration) float64 <span class="cov0" title="0">{
        return float64(d) / float64(time.Millisecond)
}</span>

const (
        _secondsPerDay = 60 * 60 * 24
)

func (tu timeUtil) DaysDiff(t1, t2 time.Time) (days int64) <span class="cov0" title="0">{
        t1n := t1.Unix()
        t2n := t2.Unix()
        diff := t1n - t2n
        return diff / (_secondsPerDay)
}</span>

// On returns the clock components of clock (hour,minute,second) on the date components of d.
func (tu timeUtil) OnDate(clock, date time.Time) time.Time <span class="cov0" title="0">{
        tzAdjusted := date.In(clock.Location())
        return time.Date(tzAdjusted.Year(), tzAdjusted.Month(), tzAdjusted.Day(), clock.Hour(), clock.Minute(), clock.Second(), clock.Nanosecond(), clock.Location())
}</span>

// ExplodeDuration returns all the constituent parts of a time.Duration.
func (tu timeUtil) ExplodeDuration(duration time.Duration) (
        hours time.Duration,
        minutes time.Duration,
        seconds time.Duration,
        milliseconds time.Duration,
        microseconds time.Duration,
) <span class="cov0" title="0">{
        hours = duration / time.Hour
        hoursRemainder := duration - (hours * time.Hour)
        minutes = hoursRemainder / time.Minute
        minuteRemainder := hoursRemainder - (minutes * time.Minute)
        seconds = minuteRemainder / time.Second
        secondsRemainder := minuteRemainder - (seconds * time.Second)
        milliseconds = secondsRemainder / time.Millisecond
        millisecondsRemainder := secondsRemainder - (milliseconds * time.Millisecond)
        microseconds = millisecondsRemainder / time.Microsecond
        return
}</span>

// RoundDuration rounds a duration to the given place.
func (tu timeUtil) RoundDuration(duration, roundTo time.Duration) time.Duration <span class="cov0" title="0">{
        hours, minutes, seconds, milliseconds, microseconds := tu.ExplodeDuration(duration)
        hours = hours * time.Hour
        minutes = minutes * time.Minute
        seconds = seconds * time.Second
        milliseconds = milliseconds * time.Millisecond
        microseconds = microseconds * time.Microsecond

        var total time.Duration
        if hours &gt;= roundTo </span><span class="cov0" title="0">{
                total = total + hours
        }</span>
        <span class="cov0" title="0">if minutes &gt;= roundTo </span><span class="cov0" title="0">{
                total = total + minutes
        }</span>
        <span class="cov0" title="0">if seconds &gt;= roundTo </span><span class="cov0" title="0">{
                total = total + seconds
        }</span>
        <span class="cov0" title="0">if milliseconds &gt;= roundTo </span><span class="cov0" title="0">{
                total = total + milliseconds
        }</span>
        <span class="cov0" title="0">if microseconds &gt;= roundTo </span><span class="cov0" title="0">{
                total = total + microseconds
        }</span>

        <span class="cov0" title="0">return total</span>
}

// ParseDuration reverses `FormatDuration`.
func (tu timeUtil) ParseDuration(duration string) time.Duration <span class="cov0" title="0">{
        integerValue, err := strconv.ParseInt(duration, 10, 64)
        if err == nil </span><span class="cov0" title="0">{
                return time.Duration(integerValue)
        }</span>

        <span class="cov0" title="0">var hours int64
        var minutes int64
        var seconds int64
        var milliseconds int64
        var microseconds int64

        state := 0
        lastIndex := len([]rune(duration)) - 1

        var numberValue string
        var labelValue string

        var consumeValues = func() </span><span class="cov0" title="0">{
                switch labelValue </span>{
                case "h":<span class="cov0" title="0">
                        hours = Parse.Int64(numberValue)</span>
                case "m":<span class="cov0" title="0">
                        minutes = Parse.Int64(numberValue)</span>
                case "s":<span class="cov0" title="0">
                        seconds = Parse.Int64(numberValue)</span>
                case "ms":<span class="cov0" title="0">
                        milliseconds = Parse.Int64(numberValue)</span>
                case "s":<span class="cov0" title="0">
                        microseconds = Parse.Int64(numberValue)</span>
                }
        }

        <span class="cov0" title="0">for index, c := range []rune(duration) </span><span class="cov0" title="0">{
                switch state </span>{
                case 0:<span class="cov0" title="0">
                        if unicode.IsDigit(c) </span><span class="cov0" title="0">{
                                numberValue = numberValue + string(c)
                        }</span> else<span class="cov0" title="0"> {
                                labelValue = string(c)
                                if index == lastIndex </span><span class="cov0" title="0">{
                                        consumeValues()
                                }</span> else<span class="cov0" title="0"> {
                                        state = 1
                                }</span>
                        }
                case 1:<span class="cov0" title="0">
                        if unicode.IsDigit(c) </span><span class="cov0" title="0">{
                                consumeValues()
                                numberValue = string(c)
                                state = 0
                        }</span> else<span class="cov0" title="0"> if index == lastIndex </span><span class="cov0" title="0">{
                                labelValue = labelValue + string(c)
                                consumeValues()
                        }</span> else<span class="cov0" title="0"> {
                                labelValue = labelValue + string(c)
                        }</span>
                }
        }

        <span class="cov0" title="0">return (time.Duration(hours) * time.Hour) +
                (time.Duration(minutes) * time.Minute) +
                (time.Duration(seconds) * time.Second) +
                (time.Duration(milliseconds) * time.Millisecond) +
                (time.Duration(microseconds) * time.Microsecond)</span>
}
</pre>
		
		<pre class="file" id="file124" style="display: none">package util

import (
        "errors"
        "math"
)

var (
        // Vector is a namespace for vector functions.
        Vector = vectorUtil{}
)

type vectorUtil struct{}

// MultiplyByElement multiplies two slices elementwise.
func (vu vectorUtil) MultiplyByElement(a []float64, b []float64) ([]float64, error) <span class="cov8" title="1">{
        if len(a) != len(b) </span><span class="cov8" title="1">{
                return nil, errors.New("Arrays must be the same length for element multiplication")
        }</span>

        <span class="cov8" title="1">result := make([]float64, len(a))
        for i := range a </span><span class="cov8" title="1">{
                result[i] = a[i] * b[i]
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// Normalize normalizes a slice, if it is a zero vector, we return a vector of same size with an error.
func (vu vectorUtil) Normalize(input []float64) ([]float64, error) <span class="cov8" title="1">{
        if len(input) == 0 </span><span class="cov0" title="0">{
                return input, nil
        }</span>

        <span class="cov8" title="1">result := make([]float64, len(input))
        m := vu.GetMagnitude(input)
        if Math.InEpsilon(m, 0) </span><span class="cov8" title="1">{
                return result, errors.New("zero vector")
        }</span>
        <span class="cov8" title="1">for i := range input </span><span class="cov8" title="1">{
                result[i] = input[i] / m
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// Magnitude returns the magnitude of a vector.
func (vu vectorUtil) GetMagnitude(a []float64) float64 <span class="cov8" title="1">{
        sum := float64(0)
        for _, elem := range a </span><span class="cov8" title="1">{
                sum += elem * elem
        }</span>
        <span class="cov8" title="1">return math.Sqrt(sum)</span>
}
</pre>
		
		<pre class="file" id="file125" style="display: none">package util

import (
        "encoding/json"
        "net"
        "net/http"
        "strings"

        "github.com/blend/go-sdk/exception"
)

// WriteJSON writes an object to a response as json.
func WriteJSON(w http.ResponseWriter, statusCode int, response interface{}) (int, error) <span class="cov0" title="0">{
        bytes, err := json.Marshal(response)
        if err == nil </span><span class="cov0" title="0">{
                w.Header().Set("Content-Type", "application/json; charset=utf-8")
                w.WriteHeader(statusCode)
                count, writeError := w.Write(bytes)
                if count == 0 </span><span class="cov0" title="0">{
                        return count, exception.New("WriteJson : Didnt write any bytes.")
                }</span>
                <span class="cov0" title="0">return count, writeError</span>
        }
        <span class="cov0" title="0">return 0, err</span>
}

// GetIP gets the origin/client ip for a request.
// X-FORWARDED-FOR is checked. If multiple IPs are included the first one is returned
// X-REAL-IP is checked. If multiple IPs are included the first one is returned
// Finally r.RemoteAddr is used
// Only benevolent services will allow access to the real IP
func GetIP(r *http.Request) string <span class="cov8" title="1">{
        tryHeader := func(key string) (string, bool) </span><span class="cov8" title="1">{
                if headerVal := r.Header.Get(key); len(headerVal) &gt; 0 </span><span class="cov8" title="1">{
                        if !strings.ContainsRune(headerVal, ',') </span><span class="cov8" title="1">{
                                return headerVal, true
                        }</span>
                        <span class="cov8" title="1">return strings.SplitN(headerVal, ",", 2)[0], true</span>
                }
                <span class="cov8" title="1">return "", false</span>
        }

        <span class="cov8" title="1">for _, header := range []string{"X-FORWARDED-FOR", "X-REAL-IP"} </span><span class="cov8" title="1">{
                if headerVal, ok := tryHeader(header); ok </span><span class="cov8" title="1">{
                        return headerVal
                }</span>
        }

        <span class="cov8" title="1">ip, _, _ := net.SplitHostPort(r.RemoteAddr)
        return ip</span>
}

// GetParamByName returns a named parameter from either the querystring, the headers,
// the cookies, the form or the post form of a request.
func GetParamByName(r *http.Request, name string) string <span class="cov8" title="1">{
        //check querystring
        queryValue := r.URL.Query().Get(name)
        if !String.IsEmpty(queryValue) </span><span class="cov8" title="1">{
                return queryValue
        }</span>

        //check headers
        <span class="cov8" title="1">headerValue := r.Header.Get(name)
        if !String.IsEmpty(headerValue) </span><span class="cov8" title="1">{
                return headerValue
        }</span>

        //check cookies
        <span class="cov8" title="1">cookie, cookieErr := r.Cookie(name)
        if cookieErr == nil &amp;&amp; !String.IsEmpty(cookie.Value) </span><span class="cov8" title="1">{
                return cookie.Value
        }</span>

        <span class="cov8" title="1">formValue := r.Form.Get(name)
        if !String.IsEmpty(formValue) </span><span class="cov8" title="1">{
                return formValue
        }</span>

        <span class="cov0" title="0">postFormValue := r.PostFormValue(name)
        if !String.IsEmpty(postFormValue) </span><span class="cov0" title="0">{
                return postFormValue
        }</span>

        <span class="cov0" title="0">return StringEmpty</span>
}
</pre>
		
		<pre class="file" id="file126" style="display: none">package util

import (
        "bytes"
        "encoding/xml"
        "io"
        "regexp"
)

var (
        cdataPrefix = []byte("&lt;![CDATA[")
        cdataSuffix = []byte("]]&gt;")
        cdataRe     = regexp.MustCompile("&lt;!\\[CDATA\\[(.*?)\\]\\]&gt;")
)

var (
        // XML is a namespace for xml utilities.
        XML = xmlUtil{}
)

type xmlUtil struct{}

// EncodeCDATA writes a data blob to a cdata tag.
func (xu xmlUtil) EncodeCDATA(data []byte) []byte <span class="cov8" title="1">{
        return bytes.Join([][]byte{cdataPrefix, data, cdataSuffix}, []byte{})
}</span>

// DecodeCDATA decodes a cdata tag to a byte array.
func (xu xmlUtil) DecodeCDATA(cdata []byte) []byte <span class="cov8" title="1">{
        matches := cdataRe.FindAllSubmatch(cdata, 1)
        if len(matches) == 0 </span><span class="cov8" title="1">{
                return cdata
        }</span>

        <span class="cov8" title="1">return matches[0][1]</span>
}

// DeserializeXML unmarshals xml to an object.
func (xu xmlUtil) Deserialize(object interface{}, body string) error <span class="cov8" title="1">{
        return xu.DeserializeFromReader(object, bytes.NewBufferString(body))
}</span>

// DeserializeXMLFromReader unmarshals xml to an object from a reader
func (xu xmlUtil) DeserializeFromReader(object interface{}, reader io.Reader) error <span class="cov8" title="1">{
        decoder := xml.NewDecoder(reader)
        return decoder.Decode(object)
}</span>

// DeserializeXMLFromReaderWithCharsetReader uses a charset reader to deserialize xml.
func (xu xmlUtil) DeserializeFromReaderWithCharsetReader(object interface{}, body io.Reader, charsetReader func(string, io.Reader) (io.Reader, error)) error <span class="cov0" title="0">{
        decoder := xml.NewDecoder(body)
        decoder.CharsetReader = charsetReader
        return decoder.Decode(object)
}</span>

// SerializeXML marshals an object to xml.
func (xu xmlUtil) Serialize(object interface{}) string <span class="cov8" title="1">{
        b, _ := xml.Marshal(object)
        return string(b)
}</span>

// SerializeXMLToReader marshals an object to a reader.
func (xu xmlUtil) SerializeToReader(object interface{}) io.Reader <span class="cov8" title="1">{
        b, _ := xml.Marshal(object)
        return bytes.NewBufferString(string(b))
}</span>
</pre>
		
		<pre class="file" id="file127" style="display: none">package uuid

import (
        "crypto/rand"
        "fmt"
        "io"
)

var (
        byteGroups = []int{8, 4, 4, 4, 12}

        byteGroupSeparatorOffsets = []int{8, 12, 16, 20}

        hextable = [16]byte{
                '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
                'a', 'b', 'c', 'd', 'e', 'f',
        }
)

func newUUID() UUID <span class="cov8" title="1">{
        return UUID(make([]byte, 16))
}</span>

// V4 Create a new UUID version 4.
func V4() UUID <span class="cov8" title="1">{
        uuid := newUUID()
        rand.Read(uuid)
        uuid[6] = (uuid[6] &amp; 0x0f) | 0x40 // set version 4
        uuid[8] = (uuid[8] &amp; 0x3f) | 0x80 // set variant 2
        return uuid
}</span>

// Parse parses a uuidv4 from a given string.
// valid forms are:
// - {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
// - xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
// - xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
func Parse(corpus string) (UUID, error) <span class="cov8" title="1">{
        if len(corpus) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("parse uuid: input is empty")
        }</span>
        <span class="cov8" title="1">if len(corpus)%2 == 1 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("parse uuid: input is an invalid length")
        }</span>

        <span class="cov8" title="1">uuid := newUUID()
        var data = []byte(corpus)
        var c byte
        hex := [2]byte{}
        var hexChar byte
        var isHexChar bool
        var hexIndex, uuidIndex, di int

        for i := 0; i &lt; len(data); i++ </span><span class="cov8" title="1">{
                c = data[i]
                if c == '{' &amp;&amp; i == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if c == '{' </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("parse uuid: illegal character at %d: %v", i, string(c))
                }</span>
                <span class="cov8" title="1">if c == '}' &amp;&amp; i != len(data)-1 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("parse uuid: illegal character at %d: %v", i, string(c))
                }</span>
                <span class="cov8" title="1">if c == '}' </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if c == '-' &amp;&amp; !(di == 8 || di == 12 || di == 16 || di == 20) </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("parse uuid: illegal character at %d: %v", i, string(c))
                }</span>
                <span class="cov8" title="1">if c == '-' </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">hexChar, isHexChar = fromHexChar(c)
                if !isHexChar </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("parse uuid: illegal character at %d: %v", i, string(c))
                }</span>

                <span class="cov8" title="1">hex[hexIndex] = hexChar
                if hexIndex == 1 </span><span class="cov8" title="1">{
                        uuid[uuidIndex] = hex[0]&lt;&lt;4 | hex[1]
                        uuidIndex++
                        hexIndex = 0
                }</span> else<span class="cov8" title="1"> {
                        hexIndex++
                }</span>
                <span class="cov8" title="1">di++</span>
        }
        <span class="cov8" title="1">if uuidIndex != 16 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("parse uuid: input is an invalid length")
        }</span>
        <span class="cov8" title="1">return uuid, nil</span>
}

func fromHexChar(c byte) (byte, bool) <span class="cov8" title="1">{
        switch </span>{
        case '0' &lt;= c &amp;&amp; c &lt;= '9':<span class="cov8" title="1">
                return c - '0', true</span>
        case 'a' &lt;= c &amp;&amp; c &lt;= 'f':<span class="cov8" title="1">
                return c - 'a' + 10, true</span>
        case 'A' &lt;= c &amp;&amp; c &lt;= 'F':<span class="cov0" title="0">
                return c - 'A' + 10, true</span>
        }

        <span class="cov8" title="1">return 0, false</span>
}

// UUID represents a unique identifier conforming to the RFC 4122 standard.
// UUIDs are a fixed 128bit (16 byte) binary blob.
type UUID []byte

// ToFullString returns a "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx" hex representation of a uuid.
func (uuid UUID) ToFullString() string <span class="cov8" title="1">{
        b := []byte(uuid)
        return fmt.Sprintf(
                "%08x-%04x-%04x-%04x-%012x",
                b[:4], b[4:6], b[6:8], b[8:10], b[10:],
        )
}</span>

// ToShortString returns a hex representation of the uuid.
func (uuid UUID) ToShortString() string <span class="cov8" title="1">{
        b := []byte(uuid)
        return fmt.Sprintf("%x", b[:])
}</span>

// String is an alias for `ToShortString`.
func (uuid UUID) String() string <span class="cov0" title="0">{
        return uuid.ToShortString()
}</span>

// Version returns the version byte of a uuid.
func (uuid UUID) Version() byte <span class="cov8" title="1">{
        return uuid[6] &gt;&gt; 4
}</span>

// Format allows for conditional expansion in printf statements
// based on the token and flags used.
func (uuid UUID) Format(s fmt.State, verb rune) <span class="cov0" title="0">{
        switch verb </span>{
        case 'v':<span class="cov0" title="0">
                if s.Flag('+') </span><span class="cov0" title="0">{
                        io.WriteString(s, uuid.ToFullString())
                        return
                }</span>
                <span class="cov0" title="0">io.WriteString(s, uuid.ToShortString())</span>
        case 's':<span class="cov0" title="0">
                io.WriteString(s, uuid.ToShortString())</span>
        case 'q':<span class="cov0" title="0">
                fmt.Fprintf(s, "%b", uuid.Version())</span>
        }
}

// IsV4 returns true iff uuid has version number 4, variant number 2, and length 16 bytes
func (uuid UUID) IsV4() bool <span class="cov8" title="1">{
        if len(uuid) != 16 </span><span class="cov8" title="1">{
                return false
        }</span>
        // check that version number is 4
        <span class="cov8" title="1">if (uuid[6]&amp;0xf0)^0x40 != 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        // check that variant is 2
        <span class="cov8" title="1">return (uuid[8]&amp;0xc0)^0x80 == 0</span>
}
</pre>
		
		<pre class="file" id="file128" style="display: none">package web

import (
        "context"
        "crypto/tls"
        "crypto/x509"
        "fmt"
        "io/ioutil"
        "net"
        "net/http"
        "strings"
        "sync/atomic"
        "time"

        "net/url"

        "github.com/blend/go-sdk/env"
        "github.com/blend/go-sdk/exception"
        "github.com/blend/go-sdk/logger"
)

// New returns a new app.
func New() *App <span class="cov8" title="1">{
        views := NewViewCache()
        vrp := &amp;ViewResultProvider{views: views}

        return &amp;App{
                auth:                  NewAuthManager(),
                state:                 map[string]interface{}{},
                statics:               map[string]Fileserver{},
                readTimeout:           DefaultReadTimeout,
                redirectTrailingSlash: true,
                recoverPanics:         true,
                defaultHeaders:        DefaultHeaders,
                views:                 views,
                viewProvider:          vrp,
                jsonProvider:          &amp;JSONResultProvider{},
                xmlProvider:           &amp;XMLResultProvider{},
                textProvider:          &amp;TextResultProvider{},
                started:               make(chan struct{}),
        }
}</span>

// NewFromEnv returns a new app from the environment.
func NewFromEnv() *App <span class="cov8" title="1">{
        return NewFromConfig(NewConfigFromEnv())
}</span>

// NewFromConfig returns a new app from a given config.
func NewFromConfig(cfg *Config) *App <span class="cov8" title="1">{
        app := New()

        app = app.WithBindAddr(cfg.GetBindAddr())
        app = app.WithRedirectTrailingSlash(cfg.GetRedirectTrailingSlash())
        app = app.WithHandleMethodNotAllowed(cfg.GetHandleMethodNotAllowed())
        app = app.WithHandleOptions(cfg.GetHandleOptions())
        app = app.WithRecoverPanics(cfg.GetRecoverPanics())
        app = app.WithDefaultHeaders(cfg.GetDefaultHeaders(DefaultHeaders))

        app = app.WithHSTS(cfg.GetHSTS())
        app = app.WithHSTSMaxAgeSeconds(cfg.GetHSTSMaxAgeSeconds())
        app = app.WithHSTSIncludeSubdomains(cfg.GetHSTSIncludeSubDomains())
        app = app.WithHSTSPreload(cfg.GetHSTSPreload())

        app = app.WithMaxHeaderBytes(cfg.GetMaxHeaderBytes())
        app = app.WithReadHeaderTimeout(cfg.GetReadHeaderTimeout())
        app = app.WithReadTimeout(cfg.GetReadTimeout())
        app = app.WithWriteTimeout(cfg.GetWriteTimeout())
        app = app.WithIdleTimeout(cfg.GetIdleTimeout())

        app = app.WithParsedBaseURL(cfg.GetBaseURL())
        app = app.WithAuth(NewAuthManagerFromConfig(cfg))
        app = app.WithViews(NewViewCacheFromConfig(&amp;cfg.Views))
        app = app.WithViewResultProvider(&amp;ViewResultProvider{views: app.Views()})

        tlsConfig, err := cfg.TLS.GetConfig()
        if err != nil </span><span class="cov0" title="0">{
                app = app.withPreStartError(err)
        }</span> else<span class="cov8" title="1"> {
                app = app.WithTLSConfig(tlsConfig)
        }</span>

        <span class="cov8" title="1">return app</span>
}

// App is the server for the app.
type App struct {
        baseURL  *url.URL
        bindAddr string

        log   *logger.Logger
        auth  *AuthManager
        views *ViewCache

        hsts                  bool
        hstsMaxAgeSeconds     int
        hstsIncludeSubdomains bool
        hstsPreload           bool

        tlsConfig *tls.Config

        defaultHeaders map[string]string

        startDelegate AppStartDelegate

        started chan struct{}
        running int32

        server   *http.Server
        listener *net.TCPListener

        // statics serve files at various routes
        statics map[string]Fileserver

        routes                  map[string]*node
        notFoundHandler         Handler
        methodNotAllowedHandler Handler
        panicAction             PanicAction
        redirectTrailingSlash   bool
        handleOptions           bool
        handleMethodNotAllowed  bool

        defaultMiddleware []Middleware

        defaultResultProvider ResultProvider
        viewProvider          *ViewResultProvider
        jsonProvider          *JSONResultProvider
        xmlProvider           *XMLResultProvider
        textProvider          *TextResultProvider

        maxHeaderBytes    int
        readTimeout       time.Duration
        readHeaderTimeout time.Duration
        writeTimeout      time.Duration
        idleTimeout       time.Duration

        state map[string]interface{}

        recoverPanics bool
        err           error
}

// Running returns if the app is running.
func (a *App) Running() (running bool) <span class="cov8" title="1">{
        return atomic.LoadInt32(&amp;a.running) == 1
}</span>

// WithErr sets the err that will abort app start.
func (a *App) WithErr(err error) *App <span class="cov0" title="0">{
        a.err = err
        return a
}</span>

// Err returns any errors that are generated before app start.
func (a *App) Err() error <span class="cov8" title="1">{
        return a.err
}</span>

// WithDefaultHeaders sets the default headers
func (a *App) WithDefaultHeaders(headers map[string]string) *App <span class="cov8" title="1">{
        a.defaultHeaders = headers
        return a
}</span>

// WithDefaultHeader adds a default header.
func (a *App) WithDefaultHeader(key string, value string) *App <span class="cov8" title="1">{
        a.defaultHeaders[key] = value
        return a
}</span>

// DefaultHeaders returns the default headers.
func (a *App) DefaultHeaders() map[string]string <span class="cov8" title="1">{
        return a.defaultHeaders
}</span>

// WithState sets app state and returns a reference to the app for building apps with a fluent api.
func (a *App) WithState(key string, value interface{}) *App <span class="cov0" title="0">{
        a.state[key] = value
        return a
}</span>

// GetState gets app state element by key.
func (a *App) GetState(key string) interface{} <span class="cov0" title="0">{
        if value, hasValue := a.state[key]; hasValue </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SetState sets app state.
func (a *App) SetState(key string, value interface{}) <span class="cov0" title="0">{
        a.state[key] = value
}</span>

// State is a bag for common app state.
func (a *App) State() State <span class="cov0" title="0">{
        return a.state
}</span>

// RedirectTrailingSlash returns if we should redirect missing trailing slashes to the correct route.
func (a *App) RedirectTrailingSlash() bool <span class="cov0" title="0">{
        return a.redirectTrailingSlash
}</span>

// WithRedirectTrailingSlash sets if we should redirect missing trailing slashes.
func (a *App) WithRedirectTrailingSlash(value bool) *App <span class="cov8" title="1">{
        a.redirectTrailingSlash = value
        return a
}</span>

// HandleMethodNotAllowed returns if we should handle unhandled verbs.
func (a *App) HandleMethodNotAllowed() bool <span class="cov8" title="1">{
        return a.handleMethodNotAllowed
}</span>

// WithHandleMethodNotAllowed sets if we should handlem ethod not allowed.
func (a *App) WithHandleMethodNotAllowed(handle bool) *App <span class="cov8" title="1">{
        a.handleMethodNotAllowed = handle
        return a
}</span>

// HandleOptions returns if we should handle OPTIONS requests.
func (a *App) HandleOptions() bool <span class="cov8" title="1">{
        return a.handleOptions
}</span>

// WithHandleOptions returns if we should handle OPTIONS requests.
func (a *App) WithHandleOptions(handle bool) *App <span class="cov8" title="1">{
        a.handleOptions = handle
        return a
}</span>

// RecoverPanics returns if the app recovers panics.
func (a *App) RecoverPanics() bool <span class="cov8" title="1">{
        return a.recoverPanics
}</span>

// WithRecoverPanics sets if the app should recover panics.
func (a *App) WithRecoverPanics(value bool) *App <span class="cov8" title="1">{
        a.recoverPanics = value
        return a
}</span>

// BaseURL returns the domain for the app.
func (a *App) BaseURL() *url.URL <span class="cov0" title="0">{
        return a.baseURL
}</span>

// WithBaseURL sets the `BaseURL` field and returns a reference to the app for building apps with a fluent api.
func (a *App) WithBaseURL(baseURL *url.URL) *App <span class="cov0" title="0">{
        a.SetBaseURL(baseURL)
        return a
}</span>

// SetBaseURL sets the base url for the app.
func (a *App) SetBaseURL(baseURL *url.URL) <span class="cov0" title="0">{
        a.baseURL = baseURL
}</span>

// WithParsedBaseURL sets the BaseURL from a string.
func (a *App) WithParsedBaseURL(baseURL string) *App <span class="cov8" title="1">{
        u, err := url.Parse(baseURL)
        if err != nil </span><span class="cov0" title="0">{
                return a.withPreStartError(err)
        }</span>
        <span class="cov8" title="1">a.baseURL = u
        return a</span>
}

// MaxHeaderBytes returns the app max header bytes.
func (a *App) MaxHeaderBytes() int <span class="cov8" title="1">{
        return a.maxHeaderBytes
}</span>

// WithMaxHeaderBytes sets the max header bytes value and returns a reference.
func (a *App) WithMaxHeaderBytes(byteCount int) *App <span class="cov8" title="1">{
        a.maxHeaderBytes = byteCount
        return a
}</span>

// ReadHeaderTimeout returns the read header timeout for the server.
func (a *App) ReadHeaderTimeout() time.Duration <span class="cov8" title="1">{
        return a.readHeaderTimeout
}</span>

// WithReadHeaderTimeout returns the read header timeout for the server.
func (a *App) WithReadHeaderTimeout(timeout time.Duration) *App <span class="cov8" title="1">{
        a.readHeaderTimeout = timeout
        return a
}</span>

// ReadTimeout returns the read timeout for the server.
func (a *App) ReadTimeout() time.Duration <span class="cov8" title="1">{
        return a.readTimeout
}</span>

// WithReadTimeout sets the read timeout for the server and returns a reference to the app for building apps with a fluent api.
func (a *App) WithReadTimeout(timeout time.Duration) *App <span class="cov8" title="1">{
        a.readTimeout = timeout
        return a
}</span>

// IdleTimeout is the time before we close a connection.
func (a *App) IdleTimeout() time.Duration <span class="cov8" title="1">{
        return a.idleTimeout
}</span>

// WithIdleTimeout sets the idle timeout.
func (a *App) WithIdleTimeout(timeout time.Duration) *App <span class="cov8" title="1">{
        a.idleTimeout = timeout
        return a
}</span>

// WriteTimeout returns the write timeout for the server.
func (a *App) WriteTimeout() time.Duration <span class="cov8" title="1">{
        return a.writeTimeout
}</span>

// WithWriteTimeout sets the write timeout for the server and returns a reference to the app for building apps with a fluent api.
func (a *App) WithWriteTimeout(timeout time.Duration) *App <span class="cov8" title="1">{
        a.writeTimeout = timeout
        return a
}</span>

// WithHSTS enables or disables issuing the strict transport security header.
func (a *App) WithHSTS(enabled bool) *App <span class="cov8" title="1">{
        a.hsts = enabled
        return a
}</span>

// HSTS returns if strict transport security is enabled.
func (a *App) HSTS() bool <span class="cov8" title="1">{
        return a.hsts
}</span>

// WithHSTSMaxAgeSeconds sets the hsts max age seconds.
func (a *App) WithHSTSMaxAgeSeconds(ageSeconds int) *App <span class="cov8" title="1">{
        a.hstsMaxAgeSeconds = ageSeconds
        return a
}</span>

// HSTSMaxAgeSeconds is the maximum lifetime browsers should honor the secure transport header.
func (a *App) HSTSMaxAgeSeconds() int <span class="cov8" title="1">{
        return a.hstsMaxAgeSeconds
}</span>

// WithHSTSIncludeSubdomains sets if we should include subdomains in hsts.
func (a *App) WithHSTSIncludeSubdomains(includeSubdomains bool) *App <span class="cov8" title="1">{
        a.hstsIncludeSubdomains = includeSubdomains
        return a
}</span>

// HSTSIncludeSubdomains returns if we should include subdomains in hsts.
func (a *App) HSTSIncludeSubdomains() bool <span class="cov8" title="1">{
        return a.hstsIncludeSubdomains
}</span>

// WithHSTSPreload sets if we preload hsts.
func (a *App) WithHSTSPreload(preload bool) *App <span class="cov8" title="1">{
        a.hstsPreload = preload
        return a
}</span>

// HSTSPreload returns if we should preload hsts.
func (a *App) HSTSPreload() bool <span class="cov8" title="1">{
        return a.hstsPreload
}</span>

// WithTLSConfig sets the tls config for the app.
func (a *App) WithTLSConfig(config *tls.Config) *App <span class="cov8" title="1">{
        a.SetTLSConfig(config)
        return a
}</span>

// SetTLSConfig sets the tls config.
func (a *App) SetTLSConfig(config *tls.Config) <span class="cov8" title="1">{
        a.tlsConfig = config
}</span>

// TLSConfig returns the app tls config.
func (a *App) TLSConfig() *tls.Config <span class="cov8" title="1">{
        return a.tlsConfig
}</span>

// WithTLSCertPair sets the app to use TLS when listening, and returns a reference to the app for building apps with a fluent api.
func (a *App) WithTLSCertPair(tlsCert, tlsKey []byte) *App <span class="cov0" title="0">{
        if err := a.SetTLSCertPair(tlsCert, tlsKey); err != nil </span><span class="cov0" title="0">{
                return a.withPreStartError(err)
        }</span>
        <span class="cov0" title="0">return a</span>
}

// SetTLSCertPair sets the app to use TLS with a given cert.
func (a *App) SetTLSCertPair(tlsCert, tlsKey []byte) error <span class="cov8" title="1">{
        cert, err := tls.X509KeyPair(tlsCert, tlsKey)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if a.tlsConfig == nil </span><span class="cov8" title="1">{
                a.tlsConfig = &amp;tls.Config{
                        Certificates: []tls.Certificate{cert},
                }
        }</span> else<span class="cov8" title="1"> {
                a.tlsConfig.Certificates = []tls.Certificate{cert}
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// WithTLSCertPairFromFiles sets the tls key pair from a given set of paths to files, and returns a reference to the app.
func (a *App) WithTLSCertPairFromFiles(tlsCertPath, tlsKeyPath string) *App <span class="cov0" title="0">{
        if err := a.SetTLSCertPairFromFiles(tlsCertPath, tlsKeyPath); err != nil </span><span class="cov0" title="0">{
                return a.withPreStartError(err)
        }</span>
        <span class="cov0" title="0">return a</span>
}

// SetTLSCertPairFromFiles reads a tls key pair from a given set of paths.
func (a *App) SetTLSCertPairFromFiles(tlsCertPath, tlsKeyPath string) error <span class="cov0" title="0">{
        cert, err := ioutil.ReadFile(tlsCertPath)
        if err != nil </span><span class="cov0" title="0">{
                return exception.Wrap(err)
        }</span>

        <span class="cov0" title="0">key, err := ioutil.ReadFile(tlsKeyPath)
        if err != nil </span><span class="cov0" title="0">{
                return exception.Wrap(err)
        }</span>

        <span class="cov0" title="0">return a.SetTLSCertPair(cert, key)</span>
}

// WithTLSFromEnv reads TLS settings from the environment, and returns a reference to the app for building apps with a fluent api.
func (a *App) WithTLSFromEnv() *App <span class="cov0" title="0">{
        if err := a.SetTLSFromEnv(); err != nil </span><span class="cov0" title="0">{
                return a.withPreStartError(err)
        }</span>
        <span class="cov0" title="0">return a</span>
}

// SetTLSFromEnv reads TLS settings from the environment.
func (a *App) SetTLSFromEnv() error <span class="cov0" title="0">{
        tlsCert := env.Env().Bytes(EnvironmentVariableTLSCert)
        tlsKey := env.Env().Bytes(EnvironmentVariableTLSKey)
        tlsCertPath := env.Env().String(EnvironmentVariableTLSCertFile)
        tlsKeyPath := env.Env().String(EnvironmentVariableTLSKeyFile)

        if len(tlsCert) &gt; 0 &amp;&amp; len(tlsKey) &gt; 0 </span><span class="cov0" title="0">{
                return a.SetTLSCertPair(tlsCert, tlsKey)
        }</span> else<span class="cov0" title="0"> if len(tlsCertPath) &gt; 0 &amp;&amp; len(tlsKeyPath) &gt; 0 </span><span class="cov0" title="0">{
                return a.SetTLSCertPairFromFiles(tlsCertPath, tlsKeyPath)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// WithTLSClientCertPool sets the client cert pool and returns a reference to the app.
func (a *App) WithTLSClientCertPool(certs ...[]byte) *App <span class="cov0" title="0">{
        if err := a.SetTLSClientCertPool(certs...); err != nil </span><span class="cov0" title="0">{
                return a.withPreStartError(err)
        }</span>
        <span class="cov0" title="0">return a</span>
}

// SetTLSClientCertPool set the client cert pool from a given set of pems.
func (a *App) SetTLSClientCertPool(certs ...[]byte) error <span class="cov8" title="1">{
        if a.tlsConfig == nil </span><span class="cov8" title="1">{
                a.tlsConfig = &amp;tls.Config{}
        }</span>
        <span class="cov8" title="1">a.tlsConfig.ClientCAs = x509.NewCertPool()
        for _, cert := range certs </span><span class="cov8" title="1">{
                ok := a.tlsConfig.ClientCAs.AppendCertsFromPEM(cert)
                if !ok </span><span class="cov8" title="1">{
                        return exception.New("invalid ca cert for client cert pool")
                }</span>
        }
        <span class="cov8" title="1">a.tlsConfig.BuildNameToCertificate()
        // This is a solution to enforce the server fetch the new config when a new
        // request comes in. The server would use the old ClientCAs pool if this is
        // not called.
        a.tlsConfig.GetConfigForClient = func(_ *tls.ClientHelloInfo) (*tls.Config, error) </span><span class="cov0" title="0">{
                return a.tlsConfig, nil
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// WithTLSClientCertVerification sets the verification level for client certs.
func (a *App) WithTLSClientCertVerification(verification tls.ClientAuthType) *App <span class="cov8" title="1">{
        if a.tlsConfig == nil </span><span class="cov8" title="1">{
                a.tlsConfig = &amp;tls.Config{}
        }</span>
        <span class="cov8" title="1">a.tlsConfig.ClientAuth = verification
        return a</span>
}

// WithPort sets the port for the bind address of the app, and returns a reference to the app.
func (a *App) WithPort(port int32) *App <span class="cov8" title="1">{
        a.SetPort(port)
        return a
}</span>

// SetPort sets the port the app listens on, typically to `:%d` which indicates listen on any interface.
func (a *App) SetPort(port int32) <span class="cov8" title="1">{
        a.bindAddr = fmt.Sprintf(":%v", port)
}</span>

// WithPortFromEnv sets the port from an environment variable, and returns a reference to the app.
func (a *App) WithPortFromEnv() *App <span class="cov8" title="1">{
        a.SetPortFromEnv()
        return a
}</span>

// SetPortFromEnv sets the port from an environment variable, and returns a reference to the app.
func (a *App) SetPortFromEnv() <span class="cov8" title="1">{
        if env.Env().Has(EnvironmentVariablePort) </span><span class="cov8" title="1">{
                port, err := env.Env().Int32(EnvironmentVariablePort)
                if err != nil </span><span class="cov0" title="0">{
                        a.err = err
                }</span>
                <span class="cov8" title="1">a.bindAddr = fmt.Sprintf(":%v", port)</span>
        }
}

// BindAddr returns the address the server will bind to.
func (a *App) BindAddr() string <span class="cov8" title="1">{
        return a.bindAddr
}</span>

// WithBindAddr sets the address the app listens on, and returns a reference to the app.
func (a *App) WithBindAddr(bindAddr string) *App <span class="cov8" title="1">{
        a.bindAddr = bindAddr
        return a
}</span>

// WithBindAddrFromEnv sets the address the app listens on, and returns a reference to the app.
func (a *App) WithBindAddrFromEnv() *App <span class="cov8" title="1">{
        a.bindAddr = env.Env().String(EnvironmentVariableBindAddr)
        return a
}</span>

// Logger returns the diagnostics agent for the app.
func (a *App) Logger() *logger.Logger <span class="cov8" title="1">{
        return a.log
}</span>

// WithLogger sets the app logger agent and returns a reference to the app.
// It also sets underlying loggers in any child resources like providers and the auth manager.
func (a *App) WithLogger(log *logger.Logger) *App <span class="cov8" title="1">{
        a.log = log
        if a.viewProvider != nil </span><span class="cov8" title="1">{
                a.viewProvider.log = log
        }</span>
        <span class="cov8" title="1">if a.jsonProvider != nil </span><span class="cov8" title="1">{
                a.jsonProvider.log = log
        }</span>
        <span class="cov8" title="1">if a.xmlProvider != nil </span><span class="cov8" title="1">{
                a.xmlProvider.log = log
        }</span>
        <span class="cov8" title="1">if a.textProvider != nil </span><span class="cov8" title="1">{
                a.textProvider.log = log
        }</span>
        <span class="cov8" title="1">if a.auth != nil </span><span class="cov8" title="1">{
                a.auth.log = log
        }</span>
        <span class="cov8" title="1">return a</span>
}

// WithDefaultMiddleware sets the application wide default middleware.
func (a *App) WithDefaultMiddleware(middleware ...Middleware) *App <span class="cov8" title="1">{
        a.defaultMiddleware = middleware
        return a
}</span>

// DefaultMiddleware returns the default middleware.
func (a *App) DefaultMiddleware() []Middleware <span class="cov8" title="1">{
        return a.defaultMiddleware
}</span>

// OnStart lets you register a task that is run before the server starts.
// Typically this delegate sets up the database connection and other init items.
func (a *App) OnStart(action AppStartDelegate) <span class="cov0" title="0">{
        a.startDelegate = action
}</span>

// CreateServer returns the basic http.Server for the app.
func (a *App) CreateServer() *http.Server <span class="cov8" title="1">{
        return &amp;http.Server{
                Addr:              a.BindAddr(),
                Handler:           a,
                MaxHeaderBytes:    a.maxHeaderBytes,
                ReadTimeout:       a.readTimeout,
                ReadHeaderTimeout: a.readHeaderTimeout,
                WriteTimeout:      a.writeTimeout,
                IdleTimeout:       a.idleTimeout,
                TLSConfig:         a.tlsConfig,
        }
}</span>

// WithServer sets the server.
func (a *App) WithServer(server *http.Server) *App <span class="cov0" title="0">{
        a.server = server
        return a
}</span>

// Server returns the underyling http server.
func (a *App) Server() *http.Server <span class="cov0" title="0">{
        return a.server
}</span>

// Listener returns the underlying listener.
func (a *App) Listener() *net.TCPListener <span class="cov8" title="1">{
        return a.listener
}</span>

// Start starts the server and binds to the given address.
func (a *App) Start() (err error) <span class="cov8" title="1">{
        start := time.Now()
        if a.log != nil </span><span class="cov8" title="1">{
                a.log.SyncTrigger(NewAppEvent(AppStart).WithApp(a))
                defer a.log.SyncTrigger(NewAppEvent(AppExit).WithApp(a).WithErr(err))
        }</span>

        // early exit if we already had an issue.
        <span class="cov8" title="1">if a.err != nil </span><span class="cov0" title="0">{
                err = a.err
                return
        }</span>

        <span class="cov8" title="1">if a.server == nil </span><span class="cov8" title="1">{
                a.server = a.CreateServer()
        }</span>

        <span class="cov8" title="1">if a.startDelegate != nil </span><span class="cov0" title="0">{
                err = a.startDelegate(a)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov8" title="1">err = a.StartupTasks()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">serverProtocol := "http"
        if a.server.TLSConfig != nil </span><span class="cov0" title="0">{
                serverProtocol = "https (tls)"
        }</span>

        <span class="cov8" title="1">a.syncInfof("%s server started, listening on %s", serverProtocol, a.bindAddr)
        if a.log != nil </span><span class="cov8" title="1">{
                if a.log.Flags() != nil </span><span class="cov8" title="1">{
                        a.syncInfof("%s server logging flags %s", serverProtocol, a.log.Flags().String())
                }</span>

        }

        <span class="cov8" title="1">if a.server.TLSConfig != nil &amp;&amp; a.server.TLSConfig.ClientCAs != nil </span><span class="cov0" title="0">{
                a.syncInfof("%s using client cert pool with (%d) client certs", serverProtocol, len(a.server.TLSConfig.ClientCAs.Subjects()))
        }</span>

        <span class="cov8" title="1">var listener net.Listener
        listener, err = net.Listen("tcp", a.bindAddr)
        if err != nil </span><span class="cov0" title="0">{
                err = exception.Wrap(err)
                return
        }</span>
        <span class="cov8" title="1">a.listener = listener.(*net.TCPListener)

        if a.log != nil </span><span class="cov8" title="1">{
                a.log.SyncTrigger(NewAppEvent(AppStartComplete).WithApp(a).WithElapsed(time.Since(start)))
        }</span>

        <span class="cov8" title="1">a.setRunning()
        keepAlive := TCPKeepAliveListener{a.listener}
        if a.server.TLSConfig != nil </span><span class="cov0" title="0">{
                err = exception.Wrap(a.server.ServeTLS(keepAlive, "", ""))
        }</span> else<span class="cov8" title="1"> {
                err = exception.Wrap(a.server.Serve(keepAlive))
        }</span>
        <span class="cov8" title="1">a.setStopped()
        return</span>
}

// Started returns a channel signalling the app has started.
func (a *App) Started() &lt;-chan struct{} <span class="cov8" title="1">{
        return a.started
}</span>

// Shutdown stops the server.
func (a *App) Shutdown() error <span class="cov8" title="1">{
        if !a.Running() </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        serverProtocol := "http"
        if a.server.TLSConfig != nil </span><span class="cov8" title="1">{
                serverProtocol = "https (tls)"
        }</span>

        <span class="cov8" title="1">a.syncInfof("%s server shutting down", serverProtocol)
        a.server.SetKeepAlivesEnabled(false)
        return exception.Wrap(a.server.Shutdown(ctx))</span>
}

// WithControllers registers given controllers and returns a reference to the app.
func (a *App) WithControllers(controllers ...Controller) *App <span class="cov0" title="0">{
        for _, c := range controllers </span><span class="cov0" title="0">{
                a.Register(c)
        }</span>
        <span class="cov0" title="0">return a</span>
}

// Register registers a controller with the app's router.
func (a *App) Register(c Controller) <span class="cov0" title="0">{
        c.Register(a)
}</span>

// --------------------------------------------------------------------------------
// Result Providers
// --------------------------------------------------------------------------------

// WithViewResultProvider sets the view result provider.
func (a *App) WithViewResultProvider(vrp *ViewResultProvider) *App <span class="cov8" title="1">{
        a.viewProvider = vrp
        return a
}</span>

// ViewResultProvider returns the view result provider.
func (a *App) ViewResultProvider() *ViewResultProvider <span class="cov0" title="0">{
        return a.viewProvider
}</span>

// WithJSONResultProvider sets the json result provider.
func (a *App) WithJSONResultProvider(jrp *JSONResultProvider) *App <span class="cov0" title="0">{
        a.jsonProvider = jrp
        return a
}</span>

// JSONResultProvider returns the json result provider.
func (a *App) JSONResultProvider() *JSONResultProvider <span class="cov0" title="0">{
        return a.jsonProvider
}</span>

// WithXMLResultProvider sets the xml result provider.
func (a *App) WithXMLResultProvider(xrp *XMLResultProvider) *App <span class="cov0" title="0">{
        a.xmlProvider = xrp
        return a
}</span>

// XMLResultProvider returns the xml result provider.
func (a *App) XMLResultProvider() *XMLResultProvider <span class="cov0" title="0">{
        return a.xmlProvider
}</span>

// WithTextResultProvider sets the text result provider.
func (a *App) WithTextResultProvider(trp *TextResultProvider) *App <span class="cov0" title="0">{
        a.textProvider = trp
        return a
}</span>

// TextResultProvider returns the text result provider.
func (a *App) TextResultProvider() *TextResultProvider <span class="cov0" title="0">{
        return a.textProvider
}</span>

// WithDefaultResultProvider sets the default result provider.
func (a *App) WithDefaultResultProvider(drp ResultProvider) *App <span class="cov0" title="0">{
        a.defaultResultProvider = drp
        return a
}</span>

// DefaultResultProvider returns the app wide default result provider.
func (a *App) DefaultResultProvider() ResultProvider <span class="cov0" title="0">{
        return a.defaultResultProvider
}</span>

// --------------------------------------------------------------------------------
// Auth Manager
// --------------------------------------------------------------------------------

// WithAuth sets the auth manager.
func (a *App) WithAuth(am *AuthManager) *App <span class="cov8" title="1">{
        a.auth = am
        return a
}</span>

// Auth returns the session manager.
func (a *App) Auth() *AuthManager <span class="cov8" title="1">{
        return a.auth
}</span>

// --------------------------------------------------------------------------------
// Views
// --------------------------------------------------------------------------------

// WithViews sets the view cache.
func (a *App) WithViews(vc *ViewCache) *App <span class="cov8" title="1">{
        a.views = vc
        return a
}</span>

// Views returns the view cache.
func (a *App) Views() *ViewCache <span class="cov8" title="1">{
        return a.views
}</span>

// --------------------------------------------------------------------------------
// Static Result Methods
// --------------------------------------------------------------------------------

// WithStaticRewriteRule adds a rewrite rule for a specific statically served path.
// It mutates the path for the incoming static file request to the fileserver according to the action.
func (a *App) WithStaticRewriteRule(route, match string, action RewriteAction) *App <span class="cov8" title="1">{
        mountedRoute := a.createStaticMountRoute(route)
        if static, hasRoute := a.statics[mountedRoute]; hasRoute </span><span class="cov8" title="1">{
                return a.withPreStartError(static.AddRewriteRule(match, action))
        }</span>
        <span class="cov0" title="0">return a.withPreStartError(exception.Newf("no static fileserver mounted at route").WithMessagef("route: %s", route))</span>
}

// WithStaticHeader adds a header for the given static path.
// These headers are automatically added to any result that the static path fileserver sends.
func (a *App) WithStaticHeader(route, key, value string) *App <span class="cov8" title="1">{
        mountedRoute := a.createStaticMountRoute(route)
        if static, hasRoute := a.statics[mountedRoute]; hasRoute </span><span class="cov8" title="1">{
                static.AddHeader(key, value)
                return a
        }</span>
        <span class="cov0" title="0">return a.withPreStartError(exception.Newf("no static fileserver mounted at route").WithMessagef("route: %s", mountedRoute))</span>
}

// WithStaticMiddleware adds static middleware for a given route.
func (a *App) WithStaticMiddleware(route string, middlewares ...Middleware) *App <span class="cov0" title="0">{
        mountedRoute := a.createStaticMountRoute(route)
        if static, hasRoute := a.statics[mountedRoute]; hasRoute </span><span class="cov0" title="0">{
                static.SetMiddleware(middlewares...)
                return a
        }</span>
        <span class="cov0" title="0">return a.withPreStartError(exception.Newf("no static fileserver mounted at route").WithMessagef("route: %s", mountedRoute))</span>
}

// ServeStatic serves files from the given file system root.
// If the path does not end with "/*filepath" that suffix will be added for you internally.
// For example if root is "/etc" and *filepath is "passwd", the local file
// "/etc/passwd" would be served.
func (a *App) ServeStatic(route, filepath string) <span class="cov8" title="1">{
        sfs := NewStaticFileServer(http.Dir(filepath))
        mountedRoute := a.createStaticMountRoute(route)
        a.statics[mountedRoute] = sfs
        a.Handle("GET", mountedRoute, a.renderAction(a.middlewarePipeline(sfs.Action)))
}</span>

// ServeStaticCached serves files from the given file system root.
// If the path does not end with "/*filepath" that suffix will be added for you internally.
func (a *App) ServeStaticCached(route, filepath string) <span class="cov0" title="0">{
        sfs := NewCachedStaticFileServer(http.Dir(filepath))
        mountedRoute := a.createStaticMountRoute(route)
        a.statics[mountedRoute] = sfs
        a.Handle("GET", mountedRoute, a.renderAction(a.middlewarePipeline(sfs.Action)))
}</span>

func (a *App) createStaticMountRoute(route string) string <span class="cov8" title="1">{
        mountedRoute := route
        if !strings.HasSuffix(mountedRoute, "*"+RouteTokenFilepath) </span><span class="cov8" title="1">{
                if strings.HasSuffix(mountedRoute, "/") </span><span class="cov8" title="1">{
                        mountedRoute = mountedRoute + "*" + RouteTokenFilepath
                }</span> else<span class="cov8" title="1"> {
                        mountedRoute = mountedRoute + "/*" + RouteTokenFilepath
                }</span>
        }
        <span class="cov8" title="1">return mountedRoute</span>
}

// --------------------------------------------------------------------------------
// Router internal methods
// --------------------------------------------------------------------------------

// WithNotFoundHandler sets the not found handler.
func (a *App) WithNotFoundHandler(handler Action) *App <span class="cov8" title="1">{
        a.notFoundHandler = a.renderAction(handler)
        return a
}</span>

// WithMethodNotAllowedHandler sets the not allowed handler.
func (a *App) WithMethodNotAllowedHandler(handler Action) *App <span class="cov0" title="0">{
        a.methodNotAllowedHandler = a.renderAction(handler)
        return a
}</span>

// WithPanicAction sets the panic action.
func (a *App) WithPanicAction(action PanicAction) *App <span class="cov8" title="1">{
        a.panicAction = action
        return a
}</span>

// --------------------------------------------------------------------------------
// Testing Methods
// --------------------------------------------------------------------------------

// Mock returns a request bulider to facilitate mocking requests.
func (a *App) Mock() *MockRequestBuilder <span class="cov8" title="1">{
        return NewMockRequestBuilder(a)
}</span>

// --------------------------------------------------------------------------------
// Route Registration / HTTP Methods
// --------------------------------------------------------------------------------

// GET registers a GET request handler.
func (a *App) GET(path string, action Action, middleware ...Middleware) <span class="cov8" title="1">{
        a.Handle("GET", path, a.renderAction(a.middlewarePipeline(action, middleware...)))
}</span>

// OPTIONS registers a OPTIONS request handler.
func (a *App) OPTIONS(path string, action Action, middleware ...Middleware) <span class="cov0" title="0">{
        a.Handle("OPTIONS", path, a.renderAction(a.middlewarePipeline(action, middleware...)))
}</span>

// HEAD registers a HEAD request handler.
func (a *App) HEAD(path string, action Action, middleware ...Middleware) <span class="cov0" title="0">{
        a.Handle("HEAD", path, a.renderAction(a.middlewarePipeline(action, middleware...)))
}</span>

// PUT registers a PUT request handler.
func (a *App) PUT(path string, action Action, middleware ...Middleware) <span class="cov0" title="0">{
        a.Handle("PUT", path, a.renderAction(a.middlewarePipeline(action, middleware...)))
}</span>

// PATCH registers a PATCH request handler.
func (a *App) PATCH(path string, action Action, middleware ...Middleware) <span class="cov0" title="0">{
        a.Handle("PATCH", path, a.renderAction(a.middlewarePipeline(action, middleware...)))
}</span>

// POST registers a POST request actions.
func (a *App) POST(path string, action Action, middleware ...Middleware) <span class="cov0" title="0">{
        a.Handle("POST", path, a.renderAction(a.middlewarePipeline(action, middleware...)))
}</span>

// DELETE registers a DELETE request handler.
func (a *App) DELETE(path string, action Action, middleware ...Middleware) <span class="cov0" title="0">{
        a.Handle("DELETE", path, a.renderAction(a.middlewarePipeline(action, middleware...)))
}</span>

// Handle adds a raw handler at a given method and path.
func (a *App) Handle(method, path string, handler Handler) <span class="cov8" title="1">{
        if len(path) == 0 </span><span class="cov0" title="0">{
                panic("path must not be empty")</span>
        }
        <span class="cov8" title="1">if path[0] != '/' </span><span class="cov0" title="0">{
                panic("path must begin with '/' in path '" + path + "'")</span>
        }
        <span class="cov8" title="1">if a.routes == nil </span><span class="cov8" title="1">{
                a.routes = make(map[string]*node)
        }</span>

        <span class="cov8" title="1">root := a.routes[method]
        if root == nil </span><span class="cov8" title="1">{
                root = new(node)
                a.routes[method] = root
        }</span>

        <span class="cov8" title="1">root.addRoute(method, path, handler)</span>
}

// Lookup finds the route data for a given method and path.
func (a *App) Lookup(method, path string) (route *Route, params RouteParameters, slashRedirect bool) <span class="cov8" title="1">{
        if root := a.routes[method]; root != nil </span><span class="cov8" title="1">{
                return root.getValue(path)
        }</span>
        <span class="cov8" title="1">return nil, nil, false</span>
}

// ServeHTTP makes the router implement the http.Handler interface.
func (a *App) ServeHTTP(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        if a.recoverPanics </span><span class="cov8" title="1">{
                defer a.recover(w, req)
        }</span>

        <span class="cov8" title="1">path := req.URL.Path
        if root := a.routes[req.Method]; root != nil </span><span class="cov8" title="1">{
                if route, params, tsr := root.getValue(path); route != nil </span><span class="cov8" title="1">{
                        route.Handler(w, req, route, params, nil)
                        return
                }</span> else<span class="cov0" title="0"> if req.Method != MethodConnect &amp;&amp; path != "/" </span><span class="cov0" title="0">{
                        code := http.StatusMovedPermanently // 301 // Permanent redirect, request with GET method
                        if req.Method != MethodGet </span><span class="cov0" title="0">{
                                code = http.StatusTemporaryRedirect // 307
                        }</span>

                        <span class="cov0" title="0">if tsr &amp;&amp; a.redirectTrailingSlash </span><span class="cov0" title="0">{
                                if len(path) &gt; 1 &amp;&amp; path[len(path)-1] == '/' </span><span class="cov0" title="0">{
                                        req.URL.Path = path[:len(path)-1]
                                }</span> else<span class="cov0" title="0"> {
                                        req.URL.Path = path + "/"
                                }</span>
                                <span class="cov0" title="0">http.Redirect(w, req, req.URL.String(), code)
                                return</span>
                        }
                }
        }

        <span class="cov0" title="0">if req.Method == MethodOptions </span><span class="cov0" title="0">{
                // Handle OPTIONS requests
                if a.handleOptions </span><span class="cov0" title="0">{
                        if allow := a.allowed(path, req.Method); len(allow) &gt; 0 </span><span class="cov0" title="0">{
                                w.Header().Set(HeaderAllow, allow)
                                return
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                // Handle 405
                if a.handleMethodNotAllowed </span><span class="cov0" title="0">{
                        if allow := a.allowed(path, req.Method); len(allow) &gt; 0 </span><span class="cov0" title="0">{
                                w.Header().Set(HeaderAllow, allow)
                                if a.methodNotAllowedHandler != nil </span><span class="cov0" title="0">{
                                        a.methodNotAllowedHandler(w, req, nil, nil, nil)
                                }</span> else<span class="cov0" title="0"> {
                                        http.Error(w,
                                                http.StatusText(http.StatusMethodNotAllowed),
                                                http.StatusMethodNotAllowed,
                                        )
                                }</span>
                                <span class="cov0" title="0">return</span>
                        }
                }
        }

        // Handle 404
        <span class="cov0" title="0">if a.notFoundHandler != nil </span><span class="cov0" title="0">{
                a.notFoundHandler(w, req, nil, nil, nil)
        }</span> else<span class="cov0" title="0"> {
                http.NotFound(w, req)
        }</span>
}

// --------------------------------------------------------------------------------
// Request Pipeline
// --------------------------------------------------------------------------------

// renderAction is the translation step from Action to Handler.
// this is where the bulk of the "pipeline" happens.
func (a *App) renderAction(action Action) Handler <span class="cov8" title="1">{
        return func(w http.ResponseWriter, r *http.Request, route *Route, p RouteParameters, state State) </span><span class="cov8" title="1">{
                var err error

                if len(a.defaultHeaders) &gt; 0 </span><span class="cov8" title="1">{
                        for key, value := range a.defaultHeaders </span><span class="cov8" title="1">{
                                w.Header().Set(key, value)
                        }</span>
                }

                <span class="cov8" title="1">if a.hsts </span><span class="cov8" title="1">{
                        a.addHSTSHeader(w)
                }</span>

                <span class="cov8" title="1">var response ResponseWriter
                if strings.Contains(r.Header.Get(HeaderAcceptEncoding), ContentEncodingGZIP) </span><span class="cov8" title="1">{
                        w.Header().Set(HeaderContentEncoding, ContentEncodingGZIP)
                        response = NewCompressedResponseWriter(w)
                }</span> else<span class="cov8" title="1"> {
                        w.Header().Set(HeaderContentEncoding, ContentEncodingIdentity)
                        response = NewRawResponseWriter(w)
                }</span>

                <span class="cov8" title="1">ctx := a.createCtx(response, r, route, p, state)
                ctx.onRequestStart()
                if a.log != nil </span><span class="cov8" title="1">{
                        a.log.Trigger(a.loggerRequestStartEvent(ctx))
                }</span>

                <span class="cov8" title="1">result := action(ctx)
                if result != nil </span><span class="cov8" title="1">{
                        err = result.Render(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                a.logError(err)
                        }</span>
                }

                <span class="cov8" title="1">ctx.onRequestEnd()
                ctx.setLoggedStatusCode(response.StatusCode())
                ctx.setLoggedContentLength(response.ContentLength())

                err = response.Close()
                if err != nil &amp;&amp; err != http.ErrBodyNotAllowed </span><span class="cov0" title="0">{
                        a.logError(err)
                }</span>

                // call the cancel func if it's set.
                <span class="cov8" title="1">if ctx.cancel != nil </span><span class="cov0" title="0">{
                        ctx.cancel()
                }</span>

                // effectively "request complete"
                <span class="cov8" title="1">if a.log != nil </span><span class="cov8" title="1">{
                        a.log.Trigger(a.loggerRequestEvent(ctx))
                }</span>
        }
}

// StartupTasks runs common startup tasks.
func (a *App) StartupTasks() error <span class="cov8" title="1">{
        return a.views.Initialize()
}</span>

func (a *App) addHSTSHeader(w http.ResponseWriter) <span class="cov8" title="1">{
        parts := []string{fmt.Sprintf(HSTSMaxAgeFormat, a.hstsMaxAgeSeconds)}
        if a.hstsIncludeSubdomains </span><span class="cov8" title="1">{
                parts = append(parts, HSTSIncludeSubDomains)
        }</span>
        <span class="cov8" title="1">if a.hstsPreload </span><span class="cov8" title="1">{
                parts = append(parts, HSTSPreload)
        }</span>
        <span class="cov8" title="1">w.Header().Set(HeaderStrictTransportSecurity, strings.Join(parts, "; "))</span>
}

func (a *App) loggerRequestStartEvent(ctx *Ctx) *logger.WebRequestEvent <span class="cov8" title="1">{
        event := logger.NewWebRequestStartEvent(ctx.Request()).
                WithState(ctx.state)

        if ctx.Route() != nil </span><span class="cov8" title="1">{
                event = event.WithRoute(ctx.Route().String())
        }</span>
        <span class="cov8" title="1">return event</span>
}

func (a *App) loggerRequestEvent(ctx *Ctx) *logger.WebRequestEvent <span class="cov8" title="1">{
        event := logger.NewWebRequestEvent(ctx.Request()).
                WithStatusCode(ctx.statusCode).
                WithElapsed(ctx.Elapsed()).
                WithContentLength(int64(ctx.contentLength)).
                WithState(ctx.state)

        if ctx.Route() != nil </span><span class="cov8" title="1">{
                event = event.WithRoute(ctx.Route().String())
        }</span>

        <span class="cov8" title="1">if ctx.Response().Header() != nil </span><span class="cov8" title="1">{
                event = event.WithContentType(ctx.Response().Header().Get(HeaderContentType))
                event = event.WithContentEncoding(ctx.Response().Header().Get(HeaderContentEncoding))
        }</span>
        <span class="cov8" title="1">return event</span>
}

func (a *App) recover(w http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        if rcv := recover(); rcv != nil </span><span class="cov0" title="0">{
                if a.log != nil </span><span class="cov0" title="0">{
                        a.log.Fatalf("%v", rcv)
                }</span>
                <span class="cov0" title="0">if a.panicAction != nil </span><span class="cov0" title="0">{
                        a.handlePanic(w, req, rcv)
                }</span>
        }
}

func (a *App) handlePanic(w http.ResponseWriter, r *http.Request, err interface{}) <span class="cov8" title="1">{
        a.renderAction(func(ctx *Ctx) Result </span><span class="cov8" title="1">{
                if a.log != nil </span><span class="cov0" title="0">{
                        a.log.Fatalf("%v", err)
                }</span>
                <span class="cov8" title="1">return a.panicAction(ctx, err)</span>
        })(w, r, nil, nil, nil)
}

func (a *App) createCtx(w ResponseWriter, r *http.Request, route *Route, p RouteParameters, s State) *Ctx <span class="cov8" title="1">{
        ctx := &amp;Ctx{
                response:        w,
                request:         r,
                app:             a,
                route:           route,
                routeParameters: p,
                state:           s,
                auth:            a.auth,
                log:             a.log,
                view:            a.viewProvider,
                json:            a.jsonProvider,
                xml:             a.xmlProvider,
                text:            a.textProvider,
                defaultResultProvider: a.defaultResultProvider,
        }

        if ctx.defaultResultProvider == nil </span><span class="cov8" title="1">{
                ctx.defaultResultProvider = a.textProvider
        }</span>
        <span class="cov8" title="1">if ctx.state == nil </span><span class="cov8" title="1">{
                ctx.state = State{}
        }</span>
        <span class="cov8" title="1">if a.state != nil &amp;&amp; len(a.state) &gt; 0 </span><span class="cov0" title="0">{
                for key, value := range a.state </span><span class="cov0" title="0">{
                        ctx.state[key] = value
                }</span>
        }

        <span class="cov8" title="1">return ctx</span>
}

func (a *App) middlewarePipeline(action Action, middleware ...Middleware) Action <span class="cov8" title="1">{
        if len(middleware) == 0 &amp;&amp; len(a.defaultMiddleware) == 0 </span><span class="cov8" title="1">{
                return action
        }</span>

        <span class="cov8" title="1">finalMiddleware := make([]Middleware, len(middleware)+len(a.defaultMiddleware))
        cursor := len(finalMiddleware) - 1
        for i := len(a.defaultMiddleware) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                finalMiddleware[cursor] = a.defaultMiddleware[i]
                cursor--
        }</span>

        <span class="cov8" title="1">for i := len(middleware) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                finalMiddleware[cursor] = middleware[i]
                cursor--
        }</span>

        <span class="cov8" title="1">return NestMiddleware(action, finalMiddleware...)</span>
}

func (a *App) allowed(path, reqMethod string) (allow string) <span class="cov0" title="0">{
        if path == "*" </span><span class="cov0" title="0">{ // server-wide
                for method := range a.routes </span><span class="cov0" title="0">{
                        if method == "OPTIONS" </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // add request method to list of allowed methods
                        <span class="cov0" title="0">if len(allow) == 0 </span><span class="cov0" title="0">{
                                allow = method
                        }</span> else<span class="cov0" title="0"> {
                                allow += ", " + method
                        }</span>
                }
                <span class="cov0" title="0">return</span>
        }
        <span class="cov0" title="0">for method := range a.routes </span><span class="cov0" title="0">{
                // Skip the requested method - we already tried this one
                if method == reqMethod || method == "OPTIONS" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">handle, _, _ := a.routes[method].getValue(path)
                if handle != nil </span><span class="cov0" title="0">{
                        // add request method to list of allowed methods
                        if len(allow) == 0 </span><span class="cov0" title="0">{
                                allow = method
                        }</span> else<span class="cov0" title="0"> {
                                allow += ", " + method
                        }</span>
                }
        }
        <span class="cov0" title="0">if len(allow) &gt; 0 </span><span class="cov0" title="0">{
                allow += ", OPTIONS"
        }</span>
        <span class="cov0" title="0">return</span>
}

func (a *App) withPreStartError(err error) *App <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                a.logError(err)
                if a.err == nil </span><span class="cov8" title="1">{
                        a.err = err
                }</span>
        }
        <span class="cov8" title="1">return a</span>
}

func (a *App) logError(err error) <span class="cov8" title="1">{
        if a.log == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                a.log.Error(err)
        }</span>
}

func (a *App) syncInfof(format string, args ...interface{}) <span class="cov8" title="1">{
        if a.log == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">a.log.SyncInfof(format, args...)</span>
}

func (a *App) syncFatalf(format string, args ...interface{}) <span class="cov0" title="0">{
        if a.log == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">a.log.SyncFatalf(format, args...)</span>
}

func (a *App) setRunning() <span class="cov8" title="1">{
        close(a.started)
        atomic.StoreInt32(&amp;a.running, 1)
}</span>

func (a *App) setStopped() <span class="cov8" title="1">{
        atomic.StoreInt32(&amp;a.running, 0)
}</span>
</pre>
		
		<pre class="file" id="file129" style="display: none">package web

import (
        "bytes"
        "fmt"
        "time"

        "github.com/blend/go-sdk/logger"
)

const (
        // AppStart fires when the app is starting.
        AppStart logger.Flag = "web.app.start"
        // AppStartComplete fires after the app has started.
        AppStartComplete logger.Flag = "web.app.start.complete"
        // AppExit fires when an app exits.
        AppExit logger.Flag = "web.app.exit"
)

const (
        // HealthzStart is a logger event.
        HealthzStart logger.Flag = "web.healthz.start"
        // HealthzStartComplete is a logger event.
        HealthzStartComplete logger.Flag = "web.healthz.start.complete"
        // HealthzExit is a logger event.
        HealthzExit logger.Flag = "web.healthz.exit"
)

const (
        // HTTPSUpgraderStart is a logger event.
        HTTPSUpgraderStart logger.Flag = "web.upgrader.start"
        // HTTPSUpgraderStartComplete is a logger event.
        HTTPSUpgraderStartComplete logger.Flag = "web.upgrader.start.complete"
        // HTTPSUpgraderExit is a logger event.
        HTTPSUpgraderExit logger.Flag = "web.upgrader.exit"
)

// NewAppEvent creates a new app start event.
func NewAppEvent(flag logger.Flag) *AppEvent <span class="cov8" title="1">{
        return &amp;AppEvent{
                flag: flag,
                ts:   time.Now().UTC(),
        }
}</span>

// NewAppEventListener returns a new app start event listener.
func NewAppEventListener(listener func(me *AppEvent)) logger.Listener <span class="cov8" title="1">{
        return func(e logger.Event) </span><span class="cov8" title="1">{
                if typed, isTyped := e.(*AppEvent); isTyped </span><span class="cov8" title="1">{
                        listener(typed)
                }</span>
        }
}

// AppEvent is an event.
type AppEvent struct {
        flag     logger.Flag
        ts       time.Time
        app      *App
        hz       *Healthz
        upgrader *HTTPSUpgrader
        elapsed  time.Duration
        err      error
}

// WithFlag sets the event flag.
func (ae *AppEvent) WithFlag(flag logger.Flag) *AppEvent <span class="cov0" title="0">{
        ae.flag = flag
        return ae
}</span>

// Flag returns the logger flag.
func (ae *AppEvent) Flag() logger.Flag <span class="cov8" title="1">{
        return ae.flag
}</span>

// WithTimestamp sets the event timestamp.
func (ae *AppEvent) WithTimestamp(ts time.Time) *AppEvent <span class="cov0" title="0">{
        ae.ts = ts
        return ae
}</span>

// Timestamp returns the timestamp for a
func (ae *AppEvent) Timestamp() time.Time <span class="cov0" title="0">{
        return ae.ts
}</span>

// WithApp sets the event app reference.
func (ae *AppEvent) WithApp(app *App) *AppEvent <span class="cov8" title="1">{
        ae.app = app
        return ae
}</span>

// App returns the app reference.
func (ae AppEvent) App() *App <span class="cov0" title="0">{
        return ae.app
}</span>

// WithHealthz sets the event hz reference.
func (ae *AppEvent) WithHealthz(hz *Healthz) *AppEvent <span class="cov8" title="1">{
        ae.hz = hz
        return ae
}</span>

// Healthz returns the healthz reference.
func (ae AppEvent) Healthz() *Healthz <span class="cov0" title="0">{
        return ae.hz
}</span>

// WithUpgrader sets the event hz reference.
func (ae *AppEvent) WithUpgrader(upgrader *HTTPSUpgrader) *AppEvent <span class="cov0" title="0">{
        ae.upgrader = upgrader
        return ae
}</span>

// Upgrader returns the https upgrader reference.
func (ae AppEvent) Upgrader() *HTTPSUpgrader <span class="cov0" title="0">{
        return ae.upgrader
}</span>

// WithErr sets the event error.
func (ae *AppEvent) WithErr(err error) *AppEvent <span class="cov8" title="1">{
        ae.err = err
        return ae
}</span>

// Err returns an underlying error.
func (ae *AppEvent) Err() error <span class="cov0" title="0">{
        return ae.err
}</span>

// WithElapsed sets the elapsed time on the event.
func (ae *AppEvent) WithElapsed(elapsed time.Duration) *AppEvent <span class="cov8" title="1">{
        ae.elapsed = elapsed
        return ae
}</span>

// Elapsed returns the elapsed time.
func (ae *AppEvent) Elapsed() time.Duration <span class="cov0" title="0">{
        return ae.elapsed
}</span>

// WriteText implements logger.TextWritable.
func (ae *AppEvent) WriteText(tf logger.TextFormatter, buf *bytes.Buffer) <span class="cov0" title="0">{
        if ae.elapsed &gt; 0 </span><span class="cov0" title="0">{
                if ae.err != nil </span><span class="cov0" title="0">{
                        buf.WriteString(tf.Colorize("failed", logger.ColorRed))
                        buf.WriteRune(logger.RuneNewline)
                        buf.WriteString(fmt.Sprintf("%+v", ae.err))
                }</span> else<span class="cov0" title="0"> {
                        buf.WriteString(tf.Colorize("complete", logger.ColorBlue))
                }</span>

                <span class="cov0" title="0">buf.WriteRune(logger.RuneSpace)
                buf.WriteString(fmt.Sprintf("(%v)", ae.elapsed))</span>
        }
}

// WriteJSON implements logger.JSONWritable.
func (ae *AppEvent) WriteJSON() logger.JSONObj <span class="cov0" title="0">{
        obj := logger.JSONObj{}
        if ae.err != nil </span><span class="cov0" title="0">{
                obj[logger.JSONFieldErr] = ae.err
        }</span>
        <span class="cov0" title="0">if ae.elapsed &gt; 0 </span><span class="cov0" title="0">{
                obj[logger.JSONFieldElapsed] = ae.elapsed
        }</span>
        <span class="cov0" title="0">return obj</span>
}
</pre>
		
		<pre class="file" id="file130" style="display: none">package web

import (
        "crypto/hmac"
        "net/url"
        "time"

        "github.com/blend/go-sdk/logger"
        "github.com/blend/go-sdk/util"
)

// NewAuthManager returns a new session manager.
func NewAuthManager() *AuthManager <span class="cov8" title="1">{
        return &amp;AuthManager{
                sessionCache:             NewSessionCache(),
                useSessionCache:          DefaultUseSessionCache,
                sessionTimeout:           DefaultSessionTimeout,
                sessionTimeoutIsAbsolute: DefaultSessionTimeoutIsAbsolute,
                cookieName:               DefaultCookieName,
                cookiePath:               DefaultCookiePath,
                secureCookieName:         DefaultSecureCookieName,
        }
}</span>

// NewAuthManagerFromConfig returns a new auth manager from a given config.
func NewAuthManagerFromConfig(cfg *Config) *AuthManager <span class="cov8" title="1">{
        return &amp;AuthManager{
                sessionCache:             NewSessionCache(),
                useSessionCache:          cfg.GetUseSessionCache(),
                sessionTimeout:           cfg.GetSessionTimeout(),
                sessionTimeoutIsAbsolute: cfg.GetSessionTimeoutIsAbsolute(),
                cookieHTTPSOnly:          cfg.GetCookieHTTPSOnly(),
                cookieName:               cfg.GetCookieName(),
                cookiePath:               cfg.GetCookiePath(),
                secret:                   cfg.GetAuthSecret(),
                secureCookieHTTPSOnly:    cfg.GetSecureCookieHTTPSOnly(),
                secureCookieName:         cfg.GetSecureCookieName(),
        }
}</span>

// AuthManager is a manager for sessions.
type AuthManager struct {
        useSessionCache      bool
        sessionCache         *SessionCache
        persistHandler       func(*Ctx, *Session, State) error
        fetchHandler         func(sessionID string, state State) (*Session, error)
        removeHandler        func(sessionID string, state State) error
        validateHandler      func(*Session, State) error
        loginRedirectHandler func(*Ctx) *url.URL

        log *logger.Logger

        sessionTimeout           time.Duration
        sessionTimeoutIsAbsolute bool
        sessionTimeoutProvider   func(rc *Ctx) *time.Time

        cookieName      string
        cookiePath      string
        cookieHTTPSOnly bool

        secret                []byte
        secureCookieName      string
        secureCookieHTTPSOnly bool
}

// --------------------------------------------------------------------------------
// Methods
// --------------------------------------------------------------------------------

// Login logs a userID in.
func (am *AuthManager) Login(userID string, ctx *Ctx) (session *Session, err error) <span class="cov8" title="1">{
        var sessionID string
        var secureSessionID string

        sessionID = am.createSessionID()
        if am.shouldIssueSecureSesssionID() </span><span class="cov8" title="1">{
                secureSessionID, err = am.createSecureSessionID(sessionID)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">session = NewSession(userID, sessionID)
        session.ExpiresUTC = am.GenerateSessionTimeout(ctx)

        if am.persistHandler != nil </span><span class="cov8" title="1">{
                err = am.persistHandler(ctx, session, ctx.state)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, am.err(err)
                }</span>
        }

        <span class="cov8" title="1">if am.useSessionCache </span><span class="cov8" title="1">{
                am.sessionCache.Upsert(session)
        }</span>

        <span class="cov8" title="1">am.injectCookie(ctx, am.CookieName(), sessionID, session.ExpiresUTC)
        if am.shouldIssueSecureSesssionID() </span><span class="cov8" title="1">{
                am.injectCookie(ctx, am.SecureCookieName(), secureSessionID, session.ExpiresUTC)
        }</span>
        <span class="cov8" title="1">return session, nil</span>
}

// Logout unauthenticates a session.
func (am *AuthManager) Logout(ctx *Ctx) error <span class="cov8" title="1">{
        sessionID := am.readSessionID(ctx)

        // remove from session cache if enabled
        if am.useSessionCache </span><span class="cov8" title="1">{
                am.sessionCache.Remove(sessionID)
        }</span>

        <span class="cov8" title="1">ctx.ExpireCookie(am.CookieName(), am.CookiePath())
        if am.shouldIssueSecureSesssionID() </span><span class="cov8" title="1">{
                ctx.ExpireCookie(am.SecureCookieName(), am.CookiePath())
        }</span>
        <span class="cov8" title="1">ctx.WithSession(nil)

        // remove the session from a backing store
        if am.removeHandler != nil </span><span class="cov8" title="1">{
                return am.err(am.removeHandler(sessionID, ctx.state))
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// VerifySession checks a sessionID to see if it's valid.
// It also handles updating a rolling expiry.
func (am *AuthManager) VerifySession(ctx *Ctx) (*Session, error) <span class="cov8" title="1">{
        sessionID := am.readSessionID(ctx)
        err := am.validateSessionID(sessionID)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var secureSessionID string
        if am.shouldIssueSecureSesssionID() </span><span class="cov8" title="1">{
                secureSessionID = am.readSecureSessionID(ctx)
                err := am.validateSecureSessionID(sessionID, secureSessionID)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">var session *Session
        if am.useSessionCache </span><span class="cov8" title="1">{
                session = am.sessionCache.Get(sessionID)
        }</span>

        <span class="cov8" title="1">if session == nil &amp;&amp; am.fetchHandler != nil </span><span class="cov8" title="1">{
                session, err = am.fetchHandler(sessionID, ctx.state)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">if session == nil || session.IsZero() || session.IsExpired() </span><span class="cov8" title="1">{
                ctx.ExpireCookie(am.CookieName(), DefaultCookiePath)
                if am.shouldIssueSecureSesssionID() </span><span class="cov8" title="1">{
                        ctx.ExpireCookie(am.SecureCookieName(), am.CookiePath())
                }</span>

                // if we have a remove handler and the sessionID is set
                <span class="cov8" title="1">if am.removeHandler != nil </span><span class="cov8" title="1">{
                        err = am.removeHandler(sessionID, ctx.state)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                // exit out, the session is bad
                <span class="cov8" title="1">return nil, nil</span>
        }

        <span class="cov8" title="1">if am.validateHandler != nil </span><span class="cov8" title="1">{
                err = am.validateHandler(session, ctx.state)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // check if we need to do a rolling expiry update
        // note this will be explicitly false by default
        // as we use absolte expiry by default.
        <span class="cov8" title="1">if am.shouldUpdateSessionExpiry() </span><span class="cov8" title="1">{
                session.ExpiresUTC = am.GenerateSessionTimeout(ctx)
                if am.persistHandler != nil </span><span class="cov8" title="1">{
                        err = am.persistHandler(ctx, session, ctx.state)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }

                <span class="cov8" title="1">am.injectCookie(ctx, am.CookieName(), sessionID, session.ExpiresUTC)
                if am.shouldIssueSecureSesssionID() </span><span class="cov0" title="0">{
                        am.injectCookie(ctx, am.SecureCookieName(), secureSessionID, session.ExpiresUTC)
                }</span>
        }

        <span class="cov8" title="1">if am.useSessionCache </span><span class="cov8" title="1">{
                am.sessionCache.Upsert(session)
        }</span>
        <span class="cov8" title="1">return session, nil</span>
}

// Redirect returns a redirect result for when auth fails and you need to
// send the user to a login page.
func (am *AuthManager) Redirect(ctx *Ctx) Result <span class="cov8" title="1">{
        if am.loginRedirectHandler != nil </span><span class="cov0" title="0">{
                redirectTo := am.loginRedirectHandler(ctx)
                if redirectTo != nil </span><span class="cov0" title="0">{
                        return ctx.Redirectf(redirectTo.String())
                }</span>
        }
        <span class="cov8" title="1">return ctx.DefaultResultProvider().NotAuthorized()</span>
}

// --------------------------------------------------------------------------------
// Properties
// --------------------------------------------------------------------------------

// WithUseSessionCache sets if we should use the session cache.
func (am *AuthManager) WithUseSessionCache(value bool) *AuthManager <span class="cov8" title="1">{
        am.SetUseSessionCache(value)
        return am
}</span>

// SetUseSessionCache sets the `UseSessionCache` property to the value.
func (am *AuthManager) SetUseSessionCache(value bool) <span class="cov8" title="1">{
        am.useSessionCache = value
}</span>

// UseSessionCache returns if we should use the session cache.
func (am *AuthManager) UseSessionCache() bool <span class="cov8" title="1">{
        return am.useSessionCache
}</span>

// WithSecret sets the secret for the auth manager.
func (am *AuthManager) WithSecret(secret []byte) *AuthManager <span class="cov8" title="1">{
        am.SetSecret(secret)
        return am
}</span>

// SetSecret sets the secret for the auth manager.
func (am *AuthManager) SetSecret(secret []byte) <span class="cov8" title="1">{
        am.secret = secret
}</span>

// Secret returns the auth manager secret.
func (am *AuthManager) Secret() []byte <span class="cov8" title="1">{
        return am.secret
}</span>

// WithCookiesAsSessionBound sets cookies to be issued with `session` liveness.
func (am *AuthManager) WithCookiesAsSessionBound() *AuthManager <span class="cov0" title="0">{
        am.SetCookiesAsSessionBound()
        return am
}</span>

// SetCookiesAsSessionBound sets the session issued cookies to be deleted after the browser closes.
func (am *AuthManager) SetCookiesAsSessionBound() <span class="cov0" title="0">{
        am.sessionTimeout = 0
        am.sessionTimeoutProvider = nil
}</span>

// CookiesAsSessionBound returns if cookies are issued with `session` liveness.
func (am *AuthManager) CookiesAsSessionBound() bool <span class="cov0" title="0">{
        return am.sessionTimeout == 0 &amp;&amp; am.sessionTimeoutProvider == nil
}</span>

// WithSessionTimeout sets the either rolling or absolute session timeout.
func (am *AuthManager) WithSessionTimeout(timeout time.Duration) *AuthManager <span class="cov0" title="0">{
        am.SetSessionTimeout(timeout)
        return am
}</span>

// SetSessionTimeout sets the static value for session timeout.
func (am *AuthManager) SetSessionTimeout(timeout time.Duration) <span class="cov8" title="1">{
        am.sessionTimeout = timeout
}</span>

// SessionTimeout returns the session timeout.
func (am *AuthManager) SessionTimeout() time.Duration <span class="cov0" title="0">{
        return am.sessionTimeout
}</span>

// WithAbsoluteSessionTimeout sets if the session timeout is absolute (vs. rolling).
func (am *AuthManager) WithAbsoluteSessionTimeout() *AuthManager <span class="cov0" title="0">{
        am.SetSessionTimeoutIsAbsolute(true)
        return am
}</span>

// WithRollingSessionTimeout sets if the session timeout to be rolling (i.e. rolling).
func (am *AuthManager) WithRollingSessionTimeout() *AuthManager <span class="cov8" title="1">{
        am.SetSessionTimeoutIsAbsolute(false)
        return am
}</span>

// SetSessionTimeoutIsAbsolute sets if the timeout for session should be an absolute (vs. rolling) time.
func (am *AuthManager) SetSessionTimeoutIsAbsolute(isAbsolute bool) <span class="cov8" title="1">{
        am.sessionTimeoutIsAbsolute = isAbsolute
}</span>

// SesssionTimeoutIsAbsolute returns if the session timeout is absolute (vs. rolling).
func (am *AuthManager) SesssionTimeoutIsAbsolute() bool <span class="cov0" title="0">{
        return am.sessionTimeoutIsAbsolute
}</span>

// SesssionTimeoutIsRolling returns if the session timeout is absolute (vs. rolling).
func (am *AuthManager) SesssionTimeoutIsRolling() bool <span class="cov8" title="1">{
        return !am.sessionTimeoutIsAbsolute
}</span>

// WithSessionTimeoutProvider sets the session timeout provider.
func (am *AuthManager) WithSessionTimeoutProvider(timeoutProvider func(rc *Ctx) *time.Time) *AuthManager <span class="cov8" title="1">{
        am.SetSessionTimeoutProvider(timeoutProvider)
        return am
}</span>

// SetSessionTimeoutProvider sets the session to expire with a given the given timeout provider.
func (am *AuthManager) SetSessionTimeoutProvider(timeoutProvider func(rc *Ctx) *time.Time) <span class="cov8" title="1">{
        am.sessionTimeoutProvider = timeoutProvider
}</span>

// SessionTimeoutProvider returns the session timeout provider.
func (am *AuthManager) SessionTimeoutProvider() func(rc *Ctx) *time.Time <span class="cov0" title="0">{
        return am.sessionTimeoutProvider
}</span>

// WithCookiesHTTPSOnly sets if we should issue cookies with the HTTPS flag on.
func (am *AuthManager) WithCookiesHTTPSOnly(isHTTPSOnly bool) *AuthManager <span class="cov8" title="1">{
        am.cookieHTTPSOnly = isHTTPSOnly
        return am
}</span>

// SetCookieHTTPSOnly overrides defaults when determining if we should use the HTTPS only cooikie option.
// The default depends on the app configuration (if tls is configured and enabled).
func (am *AuthManager) SetCookieHTTPSOnly(isHTTPSOnly bool) <span class="cov0" title="0">{
        am.cookieHTTPSOnly = isHTTPSOnly
}</span>

// CookiesHTTPSOnly returns if the cookie is for only https connections.
func (am *AuthManager) CookiesHTTPSOnly() bool <span class="cov8" title="1">{
        return am.cookieHTTPSOnly
}</span>

// WithCookieName sets the cookie name.
func (am *AuthManager) WithCookieName(paramName string) *AuthManager <span class="cov0" title="0">{
        am.SetCookieName(paramName)
        return am
}</span>

// SetCookieName sets the session cookie name.
func (am *AuthManager) SetCookieName(paramName string) <span class="cov8" title="1">{
        am.cookieName = paramName
}</span>

// CookieName returns the session param name.
func (am *AuthManager) CookieName() string <span class="cov8" title="1">{
        return am.cookieName
}</span>

// WithCookiePath sets the cookie path.
func (am *AuthManager) WithCookiePath(path string) *AuthManager <span class="cov0" title="0">{
        am.SetCookiePath(path)
        return am
}</span>

// SetCookiePath sets the session cookie path.
func (am *AuthManager) SetCookiePath(path string) <span class="cov0" title="0">{
        am.cookiePath = path
}</span>

// CookiePath returns the session param path.
func (am *AuthManager) CookiePath() string <span class="cov8" title="1">{
        if len(am.cookiePath) == 0 </span><span class="cov0" title="0">{
                return DefaultCookiePath
        }</span>
        <span class="cov8" title="1">return am.cookiePath</span>
}

// WithSecureCookieName sets the secure cookie name.
func (am *AuthManager) WithSecureCookieName(paramName string) *AuthManager <span class="cov0" title="0">{
        am.SetSecureCookieName(paramName)
        return am
}</span>

// SetSecureCookieName sets the session param name.
func (am *AuthManager) SetSecureCookieName(paramName string) <span class="cov0" title="0">{
        am.secureCookieName = paramName
}</span>

// SecureCookieName returns the session param name.
func (am *AuthManager) SecureCookieName() string <span class="cov8" title="1">{
        return am.secureCookieName
}</span>

// WithPersistHandler sets the persist handler.
func (am *AuthManager) WithPersistHandler(handler func(*Ctx, *Session, State) error) *AuthManager <span class="cov8" title="1">{
        am.SetPersistHandler(handler)
        return am
}</span>

// SetPersistHandler sets the persist handler.
// It must be able to both create sessions and update sessions if the expiry changes.
func (am *AuthManager) SetPersistHandler(handler func(*Ctx, *Session, State) error) <span class="cov8" title="1">{
        am.persistHandler = handler
}</span>

// PersistHandler returns the persist handler.
func (am *AuthManager) PersistHandler() func(*Ctx, *Session, State) error <span class="cov0" title="0">{
        return am.persistHandler
}</span>

// WithFetchHandler sets the fetch handler.
func (am *AuthManager) WithFetchHandler(handler func(sessionID string, state State) (*Session, error)) *AuthManager <span class="cov8" title="1">{
        am.fetchHandler = handler
        return am
}</span>

// SetFetchHandler sets the fetch handler.
func (am *AuthManager) SetFetchHandler(handler func(sessionID string, state State) (*Session, error)) <span class="cov8" title="1">{
        am.fetchHandler = handler
}</span>

// FetchHandler returns the fetch handler.
// It is used in `VerifySession` to satisfy session cache misses.
func (am *AuthManager) FetchHandler() func(sessionID string, state State) (*Session, error) <span class="cov0" title="0">{
        return am.fetchHandler
}</span>

// WithRemoveHandler sets the remove handler.
func (am *AuthManager) WithRemoveHandler(handler func(sessionID string, state State) error) *AuthManager <span class="cov8" title="1">{
        am.SetRemoveHandler(handler)
        return am
}</span>

// SetRemoveHandler sets the remove handler.
// It should remove a session from the backing store by a string sessionID.
func (am *AuthManager) SetRemoveHandler(handler func(sessionID string, state State) error) <span class="cov8" title="1">{
        am.removeHandler = handler
}</span>

// RemoveHandler returns the remove handler.
// It is used in validate session if the session is found to be invalid.
func (am *AuthManager) RemoveHandler() func(sessionID string, state State) error <span class="cov0" title="0">{
        return am.removeHandler
}</span>

// WithValidateHandler sets the validate handler.
func (am *AuthManager) WithValidateHandler(handler func(*Session, State) error) *AuthManager <span class="cov8" title="1">{
        am.SetValidateHandler(handler)
        return am
}</span>

// SetValidateHandler sets the validate handler.
// This is an optional handler that will evaluate the session when verifying requests that are session aware.
func (am *AuthManager) SetValidateHandler(handler func(*Session, State) error) <span class="cov8" title="1">{
        am.validateHandler = handler
}</span>

// ValidateHandler returns the validate handler.
func (am *AuthManager) ValidateHandler() func(*Session, State) error <span class="cov0" title="0">{
        return am.validateHandler
}</span>

// WithLoginRedirectHandler sets the login redirect handler.
func (am *AuthManager) WithLoginRedirectHandler(handler func(*Ctx) *url.URL) *AuthManager <span class="cov0" title="0">{
        am.SetLoginRedirectHandler(handler)
        return am
}</span>

// SetLoginRedirectHandler sets the handler to determin where to redirect on not authorized attempts.
// It should return (nil) if you want to just show the `not_authorized` template, provided one is configured.
func (am *AuthManager) SetLoginRedirectHandler(handler func(*Ctx) *url.URL) <span class="cov0" title="0">{
        am.loginRedirectHandler = handler
}</span>

// LoginRedirectHandler returns the login redirect handler.
func (am *AuthManager) LoginRedirectHandler() func(*Ctx) *url.URL <span class="cov0" title="0">{
        return am.loginRedirectHandler
}</span>

// SessionCache returns the session cache.
func (am *AuthManager) SessionCache() *SessionCache <span class="cov8" title="1">{
        return am.sessionCache
}</span>

// WithLogger sets the intance logger and returns a reference.
func (am *AuthManager) WithLogger(log *logger.Logger) *AuthManager <span class="cov0" title="0">{
        am.log = log
        return am
}</span>

// SetLogger sets the intance logger.
func (am *AuthManager) SetLogger(log *logger.Logger) <span class="cov0" title="0">{
        am.log = log
}</span>

// Logger returns the instance logger.
func (am *AuthManager) Logger() *logger.Logger <span class="cov0" title="0">{
        return am.log
}</span>

// --------------------------------------------------------------------------------
// Utility Methods
// --------------------------------------------------------------------------------

// GenerateSessionTimeout returns the absolute time the cookie would expire.
func (am *AuthManager) GenerateSessionTimeout(context *Ctx) *time.Time <span class="cov8" title="1">{
        if am.sessionTimeout &gt; 0 </span><span class="cov8" title="1">{
                return util.OptionalTime(time.Now().UTC().Add(am.sessionTimeout))
        }</span> else<span class="cov8" title="1"> if am.sessionTimeoutProvider != nil </span><span class="cov8" title="1">{
                return am.sessionTimeoutProvider(context)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (am *AuthManager) shouldIssueSecureSesssionID() bool <span class="cov8" title="1">{
        return len(am.secret) &gt; 0
}</span>

func (am AuthManager) shouldUpdateSessionExpiry() bool <span class="cov8" title="1">{
        return am.SesssionTimeoutIsRolling() &amp;&amp; (am.sessionTimeout &gt; 0 || am.sessionTimeoutProvider != nil)
}</span>

// CreateSessionID creates a new session id.
func (am AuthManager) createSessionID() string <span class="cov8" title="1">{
        return NewSessionID()
}</span>

// CreateSecureSessionID creates a secure session id.
func (am AuthManager) createSecureSessionID(sessionID string) (string, error) <span class="cov8" title="1">{
        return EncodeSignSessionID(sessionID, am.secret)
}</span>

// InjectCookie injects a session cookie into the context.
func (am *AuthManager) injectCookie(ctx *Ctx, name, value string, expire *time.Time) <span class="cov8" title="1">{
        path := am.CookiePath()
        https := am.CookiesHTTPSOnly()
        ctx.WriteNewCookie(name, value, expire, path, https)
}</span>

// readParam reads a param from a given request context from either the cookies or headers.
func (am *AuthManager) readParam(name string, ctx *Ctx) string <span class="cov8" title="1">{
        if cookie := ctx.GetCookie(name); cookie != nil </span><span class="cov8" title="1">{
                return cookie.Value
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// ReadSessionID reads a session id from a given request context.
func (am *AuthManager) readSessionID(ctx *Ctx) string <span class="cov8" title="1">{
        return am.readParam(am.CookieName(), ctx)
}</span>

// ReadSecureSessionID reads a secure session id from a given request context.
func (am *AuthManager) readSecureSessionID(ctx *Ctx) string <span class="cov8" title="1">{
        return am.readParam(am.SecureCookieName(), ctx)
}</span>

// ValidateSessionID verifies a session id.
func (am *AuthManager) validateSessionID(sessionID string) error <span class="cov8" title="1">{
        if len(sessionID) == 0 </span><span class="cov8" title="1">{
                return ErrSessionIDEmpty
        }</span>
        <span class="cov8" title="1">if len(sessionID) &gt; LenSessionIDBase64 </span><span class="cov8" title="1">{
                return ErrSessionIDTooLong
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ValidateSecureSessionID verifies a session id.
func (am *AuthManager) validateSecureSessionID(sessionID, secureSessionID string) error <span class="cov8" title="1">{
        if len(secureSessionID) == 0 </span><span class="cov8" title="1">{
                return ErrSecureSessionIDEmpty
        }</span>

        <span class="cov8" title="1">if len(secureSessionID) &gt; LenSessionIDBase64 </span><span class="cov8" title="1">{
                return ErrSecureSessionIDTooLong
        }</span>

        <span class="cov8" title="1">secureSessionIDDecoded, err := Base64Decode(secureSessionID)
        if err != nil </span><span class="cov0" title="0">{
                return ErrSecureSessionIDInvalid
        }</span>

        <span class="cov8" title="1">signedSessionID, err := SignSessionID(sessionID, am.secret)
        if err != nil </span><span class="cov0" title="0">{
                return ErrSecureSessionIDInvalid
        }</span>

        <span class="cov8" title="1">if !hmac.Equal(signedSessionID, secureSessionIDDecoded) </span><span class="cov8" title="1">{
                return ErrSecureSessionIDInvalid
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (am AuthManager) debugf(format string, args ...interface{}) <span class="cov0" title="0">{
        if am.log != nil </span><span class="cov0" title="0">{
                am.log.SyncDebugf(format, args...)
        }</span>
}

func (am AuthManager) err(err error) error <span class="cov8" title="1">{
        if am.log != nil &amp;&amp; err != nil </span><span class="cov0" title="0">{
                am.log.Error(err)
        }</span>
        <span class="cov8" title="1">return err</span>
}
</pre>
		
		<pre class="file" id="file131" style="display: none">package web

import (
        "bytes"
        "net/http"
        "time"
)

// CachedStaticFile is a memory mapped static file.
type CachedStaticFile struct {
        Path     string
        Size     int
        ModTime  time.Time
        Contents *bytes.Reader
}

// Render implements Result.
func (csf CachedStaticFile) Render(ctx *Ctx) error <span class="cov0" title="0">{
        http.ServeContent(ctx.Response(), ctx.Request(), csf.Path, csf.ModTime, csf.Contents)
        return nil
}</span>
</pre>
		
		<pre class="file" id="file132" style="display: none">package web

import (
        "bytes"
        "io/ioutil"
        "net/http"
        "os"
        "regexp"
        "sync"

        "github.com/blend/go-sdk/logger"
)

// NewCachedStaticFileServer returns a new static file cache.
func NewCachedStaticFileServer(fs http.FileSystem) *CachedStaticFileServer <span class="cov8" title="1">{
        return &amp;CachedStaticFileServer{
                fileSystem: fs,
                files:      map[string]*CachedStaticFile{},
        }
}</span>

// CachedStaticFileServer  is a cache of static files.
type CachedStaticFileServer struct {
        log          *logger.Logger
        fileSystem   http.FileSystem
        syncRoot     sync.Mutex
        rewriteRules []RewriteRule
        headers      http.Header
        middleware   Action
        files        map[string]*CachedStaticFile
}

// Log returns a logger reference.
func (csfs *CachedStaticFileServer) Log() *logger.Logger <span class="cov0" title="0">{
        return csfs.log
}</span>

// WithLogger sets the logger reference for the static file cache.
func (csfs *CachedStaticFileServer) WithLogger(log *logger.Logger) *CachedStaticFileServer <span class="cov0" title="0">{
        csfs.log = log
        return csfs
}</span>

// Files returns the underlying file cache.
// Pragma; this should only be used in debugging, as during runtime locks are required to interact with this cache.
func (csfs *CachedStaticFileServer) Files() map[string]*CachedStaticFile <span class="cov0" title="0">{
        return csfs.files
}</span>

// AddHeader adds a header to the static cache results.
func (csfs *CachedStaticFileServer) AddHeader(key, value string) <span class="cov8" title="1">{
        if csfs.headers == nil </span><span class="cov8" title="1">{
                csfs.headers = http.Header{}
        }</span>
        <span class="cov8" title="1">csfs.headers[key] = append(csfs.headers[key], value)</span>
}

// Headers returns the headers for the static server.
func (csfs *CachedStaticFileServer) Headers() http.Header <span class="cov8" title="1">{
        return csfs.headers
}</span>

// AddRewriteRule adds a static re-write rule.
func (csfs *CachedStaticFileServer) AddRewriteRule(match string, action RewriteAction) error <span class="cov8" title="1">{
        expr, err := regexp.Compile(match)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">csfs.rewriteRules = append(csfs.rewriteRules, RewriteRule{
                MatchExpression: match,
                expr:            expr,
                Action:          action,
        })
        return nil</span>
}

// RewriteRules returns the rewrite rules
func (csfs *CachedStaticFileServer) RewriteRules() []RewriteRule <span class="cov0" title="0">{
        return csfs.rewriteRules
}</span>

// SetMiddleware sets the middlewares.
func (csfs *CachedStaticFileServer) SetMiddleware(middlewares ...Middleware) <span class="cov8" title="1">{
        csfs.middleware = NestMiddleware(csfs.ServeFile, middlewares...)
}</span>

// GetCachedFile returns a file from the filesystem at a given path.
func (csfs *CachedStaticFileServer) GetCachedFile(filepath string) (*CachedStaticFile, error) <span class="cov8" title="1">{
        csfs.syncRoot.Lock()
        defer csfs.syncRoot.Unlock()

        if file, hasFile := csfs.files[filepath]; hasFile </span><span class="cov8" title="1">{
                return file, nil
        }</span>

        <span class="cov8" title="1">f, err := csfs.fileSystem.Open(filepath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer f.Close()

        d, err := f.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">contents, err := ioutil.ReadAll(f)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">newFile := &amp;CachedStaticFile{
                Path:     filepath,
                Size:     len(contents),
                ModTime:  d.ModTime(),
                Contents: bytes.NewReader(contents),
        }

        csfs.files[filepath] = newFile
        return newFile, nil</span>
}

// Action is the entrypoint for the static server.
func (csfs *CachedStaticFileServer) Action(r *Ctx) Result <span class="cov8" title="1">{
        if csfs.middleware != nil </span><span class="cov8" title="1">{
                return csfs.middleware(r)
        }</span>
        <span class="cov8" title="1">return csfs.ServeFile(r)</span>
}

// ServeFile writes the file to the response.
func (csfs *CachedStaticFileServer) ServeFile(r *Ctx) Result <span class="cov8" title="1">{
        filePath, err := r.RouteParam(RouteTokenFilepath)
        if err != nil </span><span class="cov0" title="0">{
                return r.DefaultResultProvider().InternalError(err)
        }</span>

        <span class="cov8" title="1">for key, values := range csfs.headers </span><span class="cov8" title="1">{
                for _, value := range values </span><span class="cov8" title="1">{
                        r.Response().Header().Set(key, value)
                }</span>
        }

        <span class="cov8" title="1">for _, rule := range csfs.rewriteRules </span><span class="cov8" title="1">{
                if matched, newFilePath := rule.Apply(filePath); matched </span><span class="cov8" title="1">{
                        filePath = newFilePath
                }</span>
        }

        <span class="cov8" title="1">f, err := csfs.GetCachedFile(filePath)
        if f == nil || os.IsNotExist(err) </span><span class="cov0" title="0">{
                return r.DefaultResultProvider().NotFound()
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return r.DefaultResultProvider().InternalError(err)
        }</span>

        <span class="cov8" title="1">http.ServeContent(r.Response(), r.Request(), filePath, f.ModTime, f.Contents)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file133" style="display: none">package web

import (
        "compress/gzip"
        "net/http"
)

// NewCompressedResponseWriter returns a new gzipped response writer.
func NewCompressedResponseWriter(w http.ResponseWriter) *CompressedResponseWriter <span class="cov8" title="1">{
        return &amp;CompressedResponseWriter{
                innerResponse: w,
        }
}</span>

// CompressedResponseWriter is a response writer that compresses output.
type CompressedResponseWriter struct {
        gzipWriter    *gzip.Writer
        innerResponse http.ResponseWriter
        statusCode    int
        contentLength int
}

func (crw *CompressedResponseWriter) ensureCompressedStream() <span class="cov8" title="1">{
        if crw.gzipWriter == nil </span><span class="cov8" title="1">{
                crw.gzipWriter = gzip.NewWriter(crw.innerResponse)
        }</span>
}

// Write writes the byes to the stream.
func (crw *CompressedResponseWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        crw.ensureCompressedStream()
        _, err := crw.gzipWriter.Write(b)
        crw.contentLength += len(b)
        return len(b), err
}</span>

// Header returns the headers for the response.
func (crw *CompressedResponseWriter) Header() http.Header <span class="cov8" title="1">{
        return crw.innerResponse.Header()
}</span>

// WriteHeader writes a status code.
func (crw *CompressedResponseWriter) WriteHeader(code int) <span class="cov8" title="1">{
        crw.statusCode = code
        crw.innerResponse.WriteHeader(code)
}</span>

// InnerResponse returns the backing http response.
func (crw *CompressedResponseWriter) InnerResponse() http.ResponseWriter <span class="cov0" title="0">{
        return crw.innerResponse
}</span>

// StatusCode returns the status code for the request.
func (crw *CompressedResponseWriter) StatusCode() int <span class="cov8" title="1">{
        return crw.statusCode
}</span>

// ContentLength returns the content length for the request.
func (crw *CompressedResponseWriter) ContentLength() int <span class="cov8" title="1">{
        return crw.contentLength
}</span>

// Flush pushes any buffered data out to the response.
func (crw *CompressedResponseWriter) Flush() error <span class="cov0" title="0">{
        crw.ensureCompressedStream()
        return crw.gzipWriter.Flush()
}</span>

// Close closes any underlying resources.
func (crw *CompressedResponseWriter) Close() error <span class="cov8" title="1">{
        if crw.gzipWriter != nil </span><span class="cov8" title="1">{
                err := crw.gzipWriter.Close()
                crw.gzipWriter = nil
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file134" style="display: none">package web

import (
        "fmt"
        "strings"
        "time"

        "github.com/blend/go-sdk/env"
        "github.com/blend/go-sdk/util"
)

// NewConfigFromEnv returns a new config from the environment.
func NewConfigFromEnv() *Config <span class="cov8" title="1">{
        var cfg Config
        if err := env.Env().ReadInto(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return &amp;cfg</span>
}

// Config is an object used to set up a web app.
type Config struct {
        Port     int32  `json:"port" yaml:"port" env:"PORT"`
        BindAddr string `json:"bindAddr" yaml:"bindAddr" env:"BIND_ADDR"`
        BaseURL  string `json:"baseURL" yaml:"baseURL" env:"BASE_URL"`

        RedirectTrailingSlash  *bool `json:"redirectTrailingSlash" yaml:"redirectTrailingSlash"`
        HandleOptions          *bool `json:"handleOptions" yaml:"handleOptions"`
        HandleMethodNotAllowed *bool `json:"handleMethodNotAllowed" yaml:"handleMethodNotAllowed"`
        RecoverPanics          *bool `json:"recoverPanics" yaml:"recoverPanics"`

        // HSTS determines if we should issue the Strict-Transport-Security header.
        HSTS                  *bool `json:"hsts" yaml:"hsts"`
        HSTSMaxAgeSeconds     int   `json:"hstsMaxAgeSeconds" yaml:"hstsMaxAgeSeconds"`
        HSTSIncludeSubDomains *bool `json:"hstsIncludeSubdomains" yaml:"hstsIncludeSubdomains"`
        HSTSPreload           *bool `json:"hstsPreload" yaml:"hstsPreload"`

        // UseSessionCache enables or disables the in memory session cache.
        // Note: If the session cache is disabled you *must* provide a fetch handler.
        UseSessionCache *bool `json:"useSessionCache" yaml:"useSessionCache" env:"USE_SESSION_CACHE"`
        // SessionTimeout is a fixed duration to use when calculating hard or rolling deadlines.
        SessionTimeout time.Duration `json:"sessionTimeout" yaml:"sessionTimeout" env:"SESSION_TIMEOUT"`
        // SessionTimeoutIsAbsolute determines if the session timeout is a hard deadline or if it gets pushed forward with usage.
        // The default is to use a hard deadline.
        SessionTimeoutIsAbsolute *bool `json:"sessionTimeoutIsAbsolute" yaml:"sessionTimeoutIsAbsolute" env:"SESSION_TIMEOUT_ABSOLUTE"`
        // CookieHTTPS determines if we should flip the `https only` flag on issued cookies.
        CookieHTTPSOnly *bool `json:"cookieHTTPSOnly" yaml:"cookieHTTPSOnly" env:"COOKIE_HTTPS_ONLY"`
        // CookieName is the name of the cookie to issue with sessions.
        CookieName string `json:"cookieName" yaml:"cookieName" env:"COOKIE_NAME"`
        // CookiePath is the path on the cookie to issue with sessions.
        CookiePath string `json:"cookiePath" yaml:"cookiePath" env:"COOKIE_PATH"`

        // AuthSecret is a key to use to encrypt the sessionID as a second factor cookie.
        AuthSecret string `json:"authSecret" yaml:"authSecret" env:"AUTH_SECRET"`
        // SecureCookieHTTPS determines if we should flip the `https only` flag on issued secure cookies.
        SecureCookieHTTPSOnly *bool `json:"secureCookieHTTPSOnly" yaml:"secureCookieHTTPSOnly" env:"SECURE_COOKIE_HTTPS_ONLY"`
        // SecureCookieName is the name of the secure cookie to issue with sessions.
        SecureCookieName string `json:"secureCookieName" yaml:"secureCookieName" env:"SECURE_COOKIE_NAME"`

        // DefaultHeaders are included on any responses. The app ships with a set of default headers, which you can augment with this property.
        DefaultHeaders map[string]string `json:"defaultHeaders" yaml:"defaultHeaders"`

        MaxHeaderBytes    int           `json:"maxHeaderBytes" yaml:"maxHeaderBytes" env:"MAX_HEADER_BYTES"`
        ReadTimeout       time.Duration `json:"readTimeout" yaml:"readTimeout" env:"READ_HEADER_TIMEOUT"`
        ReadHeaderTimeout time.Duration `json:"readHeaderTimeout" yaml:"readHeaderTimeout" env:"READ_HEADER_TIMEOUT"`
        WriteTimeout      time.Duration `json:"writeTimeout" yaml:"writeTimeout" env:"WRITE_TIMEOUT"`
        IdleTimeout       time.Duration `json:"idleTimeout" yaml:"idleTimeout" env:"IDLE_TIMEOUT"`

        TLS   TLSConfig       `json:"tls" yaml:"tls"`
        Views ViewCacheConfig `json:"views" yaml:"views"`
}

// GetBindAddr util.Coalesces the bind addr, the port, or the default.
func (c Config) GetBindAddr(defaults ...string) string <span class="cov8" title="1">{
        if len(c.BindAddr) &gt; 0 </span><span class="cov8" title="1">{
                return c.BindAddr
        }</span>
        <span class="cov8" title="1">if c.Port &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf(":%d", c.Port)
        }</span>
        <span class="cov8" title="1">if len(defaults) &gt; 0 </span><span class="cov0" title="0">{
                return defaults[0]
        }</span>
        <span class="cov8" title="1">return DefaultBindAddr</span>
}

// GetPort returns the int32 port for a given config.
// This is useful in things like kubernetes pod templates.
// If the config .Port is unset, it will parse the .BindAddr,
// or the DefaultBindAddr for the port number.
func (c Config) GetPort(defaults ...int32) int32 <span class="cov0" title="0">{
        if c.Port &gt; 0 </span><span class="cov0" title="0">{
                return c.Port
        }</span>
        <span class="cov0" title="0">if len(c.BindAddr) &gt; 0 </span><span class="cov0" title="0">{
                return PortFromBindAddr(c.BindAddr)
        }</span>
        <span class="cov0" title="0">return PortFromBindAddr(DefaultBindAddr)</span>
}

// GetBaseURL gets a property.
func (c Config) GetBaseURL(defaults ...string) string <span class="cov8" title="1">{
        return util.Coalesce.String(c.BaseURL, "", defaults...)
}</span>

// GetRedirectTrailingSlash returns if we automatically redirect for a missing trailing slash.
func (c Config) GetRedirectTrailingSlash(defaults ...bool) bool <span class="cov8" title="1">{
        return util.Coalesce.Bool(c.RedirectTrailingSlash, DefaultRedirectTrailingSlash, defaults...)
}</span>

// GetHandleOptions returns if we should handle OPTIONS verb requests.
func (c Config) GetHandleOptions(defaults ...bool) bool <span class="cov8" title="1">{
        return util.Coalesce.Bool(c.HandleOptions, DefaultHandleOptions, defaults...)
}</span>

// GetHandleMethodNotAllowed returns if we should handle method not allowed results.
func (c Config) GetHandleMethodNotAllowed(defaults ...bool) bool <span class="cov8" title="1">{
        return util.Coalesce.Bool(c.HandleMethodNotAllowed, DefaultHandleMethodNotAllowed, defaults...)
}</span>

// GetRecoverPanics returns if we should recover panics or not.
func (c Config) GetRecoverPanics(defaults ...bool) bool <span class="cov8" title="1">{
        return util.Coalesce.Bool(c.RecoverPanics, DefaultRecoverPanics, defaults...)
}</span>

// GetDefaultHeaders returns the default headers from the config.
func (c Config) GetDefaultHeaders(inherited ...map[string]string) map[string]string <span class="cov8" title="1">{
        output := map[string]string{}
        if len(inherited) &gt; 0 </span><span class="cov8" title="1">{
                for _, set := range inherited </span><span class="cov8" title="1">{
                        for key, value := range set </span><span class="cov8" title="1">{
                                output[key] = value
                        }</span>
                }
        }
        <span class="cov8" title="1">for key, value := range c.DefaultHeaders </span><span class="cov0" title="0">{
                output[key] = value
        }</span>
        <span class="cov8" title="1">return output</span>
}

// ListenTLS returns if the server will directly serve requests with tls.
func (c Config) ListenTLS() bool <span class="cov8" title="1">{
        return c.TLS.HasKeyPair()
}</span>

// BaseURLIsSecureScheme returns if the base url starts with a secure scheme.
func (c Config) BaseURLIsSecureScheme() bool <span class="cov8" title="1">{
        baseURL := c.GetBaseURL()
        if len(baseURL) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov0" title="0">return strings.HasPrefix(strings.ToLower(baseURL), SchemeHTTPS) || strings.HasPrefix(strings.ToLower(baseURL), SchemeSPDY)</span>
}

// IsSecure returns if the config specifies the app will eventually be handling https requests.
func (c Config) IsSecure() bool <span class="cov8" title="1">{
        return c.ListenTLS() || c.BaseURLIsSecureScheme()
}</span>

// GetHSTS returns a property or a default.
func (c Config) GetHSTS(inherited ...bool) bool <span class="cov8" title="1">{
        return util.Coalesce.Bool(c.HSTS, DefaultHSTS &amp;&amp; c.IsSecure(), inherited...)
}</span>

// GetHSTSMaxAgeSeconds returns a property or a default.
func (c Config) GetHSTSMaxAgeSeconds(inherited ...int) int <span class="cov8" title="1">{
        return util.Coalesce.Int(c.HSTSMaxAgeSeconds, DefaultHSTSMaxAgeSeconds, inherited...)
}</span>

// GetHSTSIncludeSubDomains returns a property or a default.
func (c Config) GetHSTSIncludeSubDomains(inherited ...bool) bool <span class="cov8" title="1">{
        return util.Coalesce.Bool(c.HSTSIncludeSubDomains, DefaultHSTSIncludeSubdomains, inherited...)
}</span>

// GetHSTSPreload returns a property or a default.
func (c Config) GetHSTSPreload(inherited ...bool) bool <span class="cov8" title="1">{
        return util.Coalesce.Bool(c.HSTSPreload, DefaultHSTSPreload, inherited...)
}</span>

// GetMaxHeaderBytes returns the maximum header size in bytes or a default.
func (c Config) GetMaxHeaderBytes(defaults ...int) int <span class="cov8" title="1">{
        return util.Coalesce.Int(c.MaxHeaderBytes, DefaultMaxHeaderBytes, defaults...)
}</span>

// GetReadTimeout gets a property.
func (c Config) GetReadTimeout(defaults ...time.Duration) time.Duration <span class="cov8" title="1">{
        return util.Coalesce.Duration(c.ReadTimeout, DefaultReadTimeout, defaults...)
}</span>

// GetReadHeaderTimeout gets a property.
func (c Config) GetReadHeaderTimeout(defaults ...time.Duration) time.Duration <span class="cov8" title="1">{
        return util.Coalesce.Duration(c.ReadHeaderTimeout, DefaultReadHeaderTimeout, defaults...)
}</span>

// GetWriteTimeout gets a property.
func (c Config) GetWriteTimeout(defaults ...time.Duration) time.Duration <span class="cov8" title="1">{
        return util.Coalesce.Duration(c.WriteTimeout, DefaultWriteTimeout, defaults...)
}</span>

// GetIdleTimeout gets a property.
func (c Config) GetIdleTimeout(defaults ...time.Duration) time.Duration <span class="cov8" title="1">{
        return util.Coalesce.Duration(c.IdleTimeout, DefaultIdleTimeout, defaults...)
}</span>

// GetUseSessionCache returns a property or a default.
func (c Config) GetUseSessionCache(defaults ...bool) bool <span class="cov8" title="1">{
        return util.Coalesce.Bool(c.UseSessionCache, DefaultUseSessionCache, defaults...)
}</span>

// GetSessionTimeout returns a property or a default.
func (c Config) GetSessionTimeout(defaults ...time.Duration) time.Duration <span class="cov8" title="1">{
        return util.Coalesce.Duration(c.SessionTimeout, DefaultSessionTimeout, defaults...)
}</span>

// GetSessionTimeoutIsAbsolute returns a property or a default.
func (c Config) GetSessionTimeoutIsAbsolute(defaults ...bool) bool <span class="cov8" title="1">{
        return util.Coalesce.Bool(c.SessionTimeoutIsAbsolute, DefaultSessionTimeoutIsAbsolute, defaults...)
}</span>

// GetCookieHTTPSOnly returns a property or a default.
func (c Config) GetCookieHTTPSOnly(defaults ...bool) bool <span class="cov8" title="1">{
        return util.Coalesce.Bool(c.CookieHTTPSOnly, c.IsSecure(), defaults...)
}</span>

// GetCookieName returns a property or a default.
func (c Config) GetCookieName(defaults ...string) string <span class="cov8" title="1">{
        return util.Coalesce.String(c.CookieName, DefaultCookieName, defaults...)
}</span>

// GetCookiePath returns a property or a default.
func (c Config) GetCookiePath(defaults ...string) string <span class="cov8" title="1">{
        return util.Coalesce.String(c.CookiePath, DefaultCookiePath, defaults...)
}</span>

// GetAuthSecret returns a property or a default.
func (c Config) GetAuthSecret(defaults ...[]byte) []byte <span class="cov8" title="1">{
        decoded, err := Base64Decode(c.AuthSecret)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return decoded</span>
}

// GetSecureCookieHTTPSOnly returns a property or a default.
func (c Config) GetSecureCookieHTTPSOnly(defaults ...bool) bool <span class="cov8" title="1">{
        return util.Coalesce.Bool(c.SecureCookieHTTPSOnly, c.GetCookieHTTPSOnly(), defaults...)
}</span>

// GetSecureCookieName returns a property or a default.
func (c Config) GetSecureCookieName(defaults ...string) string <span class="cov8" title="1">{
        return util.Coalesce.String(c.SecureCookieName, DefaultSecureCookieName, defaults...)
}</span>
</pre>
		
		<pre class="file" id="file135" style="display: none">package web

import "time"

const (
        // PackageName is the full name of this package.
        PackageName = "github.com/blend/go-sdk/web"

        // HeaderAllow is a common header.
        HeaderAllow = "Allow"

        // RouteTokenFilepath is a special route token.
        RouteTokenFilepath = "filepath"

        // RegexpAssetCacheFiles is a common regex for parsing css, js, and html file routes.
        RegexpAssetCacheFiles = `^(.*)\.([0-9]+)\.(css|js|html|htm)$`

        // HeaderAcceptEncoding is the "Accept-Encoding" header.
        // It indicates what types of encodings the request will accept responses as.
        // It typically enables or disables compressed (gzipped) responses.
        HeaderAcceptEncoding = "Accept-Encoding"

        // HeaderSetCookie is the header that sets cookies in a response.
        HeaderSetCookie = "Set-Cookie"

        // HeaderCookie is the request cookie header.
        HeaderCookie = "Cookie"

        // HeaderDate is the "Date" header.
        // It provides a timestamp the response was generated at.
        // It is typically used by client cache control to invalidate expired items.
        HeaderDate = "Date"

        // HeaderCacheControl is the "Cache-Control" header.
        // It indicates if and how clients should cache responses.
        // Typical values for this include "no-cache", "max-age", "min-fresh", and "max-stale" variants.
        HeaderCacheControl = "Cache-Control"

        // HeaderConnection is the "Connection" header.
        // It is used to indicate if the connection should remain open by the server
        // after the final response bytes are sent.
        // This allows the connection to be re-used, helping mitigate connection negotiation
        // penalites in making requests.
        HeaderConnection = "Connection"

        // HeaderContentEncoding is the "Content-Encoding" header.
        // It is used to indicate what the response encoding is.
        // Typical values are "gzip", "deflate", "compress", "br", and "identity" indicating no compression.
        HeaderContentEncoding = "Content-Encoding"

        // HeaderContentLength is the "Content-Length" header.
        // If provided, it specifies the size of the request or response.
        HeaderContentLength = "Content-Length"

        // HeaderContentType is the "Content-Type" header.
        // It specifies the MIME-type of the request or response.
        HeaderContentType = "Content-Type"

        // HeaderServer is the "Server" header.
        // It is an informational header to tell the client what server software was used.
        HeaderServer = "Server"

        // HeaderVary is the "Vary" header.
        // It is used to indicate what fields should be used by the client as cache keys.
        HeaderVary = "Vary"

        // HeaderXServedBy is the "X-Served-By" header.
        // It is an informational header that indicates what software was used to generate the response.
        HeaderXServedBy = "X-Served-By"

        // HeaderXFrameOptions is the "X-Frame-Options" header.
        // It indicates if a browser is allowed to render the response in a &lt;frame&gt; element or not.
        HeaderXFrameOptions = "X-Frame-Options"

        // HeaderXXSSProtection is the "X-Xss-Protection" header.
        // It is a feature of internet explorer, and indicates if the browser should allow
        // requests across domain boundaries.
        HeaderXXSSProtection = "X-Xss-Protection"

        // HeaderXContentTypeOptions is the "X-Content-Type-Options" header.
        HeaderXContentTypeOptions = "X-Content-Type-Options"

        // HeaderStrictTransportSecurity is the hsts header.
        HeaderStrictTransportSecurity = "Strict-Transport-Security"

        // ContentTypeApplicationJSON is a content type for JSON responses.
        // We specify chartset=utf-8 so that clients know to use the UTF-8 string encoding.
        ContentTypeApplicationJSON = "application/json; charset=UTF-8"

        // ContentTypeHTML is a content type for html responses.
        // We specify chartset=utf-8 so that clients know to use the UTF-8 string encoding.
        ContentTypeHTML = "text/html; charset=utf-8"

        //ContentTypeXML is a content type for XML responses.
        // We specify chartset=utf-8 so that clients know to use the UTF-8 string encoding.
        ContentTypeXML = "text/xml; charset=utf-8"

        // ContentTypeText is a content type for text responses.
        // We specify chartset=utf-8 so that clients know to use the UTF-8 string encoding.
        ContentTypeText = "text/plain; charset=utf-8"

        // ConnectionKeepAlive is a value for the "Connection" header and
        // indicates the server should keep the tcp connection open
        // after the last byte of the response is sent.
        ConnectionKeepAlive = "keep-alive"

        // ContentEncodingIdentity is the identity (uncompressed) content encoding.
        ContentEncodingIdentity = "identity"
        // ContentEncodingGZIP is the gzip (compressed) content encoding.
        ContentEncodingGZIP = "gzip"
)

const (
        // SchemeHTTP is a protocol scheme.
        SchemeHTTP = "http"

        // SchemeHTTPS is a protocol scheme.
        SchemeHTTPS = "https"

        // SchemeSPDY is a protocol scheme.
        SchemeSPDY = "spdy"
)

const (
        // MethodGet is an http verb.
        MethodGet = "GET"

        // MethodPost is an http verb.
        MethodPost = "POST"

        // MethodPut is an http verb.
        MethodPut = "PUT"

        // MethodDelete is an http verb.
        MethodDelete = "DELETE"

        // MethodConnect is an http verb.
        MethodConnect = "CONNECT"

        // MethodOptions is an http verb.
        MethodOptions = "OPTIONS"
)

const (
        // HSTSMaxAgeFormat is the format string for a max age token.
        HSTSMaxAgeFormat = "max-age=%d"

        // HSTSIncludeSubDomains is a header value token.
        HSTSIncludeSubDomains = "includeSubDomains"

        // HSTSPreload is a header value token.
        HSTSPreload = "preload"
)

// Environment Variables
const (
        // EnvironmentVariableBindAddr is an env var that determines (if set) what the bind address should be.
        EnvironmentVariableBindAddr = "BIND_ADDR"

        // EnvironmentVariableHealthzBindAddr is an env var that determines (if set) what the healthz sidecar bind address should be.
        EnvironmentVariableHealthzBindAddr = "HEALTHZ_BIND_ADDR"

        // EnvironmentVariableUpgraderBindAddr is an env var that determines (if set) what the bind address should be.
        EnvironmentVariableUpgraderBindAddr = "UPGRADER_BIND_ADDR"

        // EnvironmentVariablePort is an env var that determines what the default bind address port segment returns.
        EnvironmentVariablePort = "PORT"

        // EnvironmentVariableHealthzPort is an env var that determines what the default healthz bind address port segment returns.
        EnvironmentVariableHealthzPort = "HEALTHZ_PORT"

        // EnvironmentVariableUpgraderPort is an env var that determines what the default bind address port segment returns.
        EnvironmentVariableUpgraderPort = "UPGRADER_PORT"

        // EnvironmentVariableTLSCert is an env var that contains the TLS cert.
        EnvironmentVariableTLSCert = "TLS_CERT"

        // EnvironmentVariableTLSKey is an env var that contains the TLS key.
        EnvironmentVariableTLSKey = "TLS_KEY"

        // EnvironmentVariableTLSCertFile is an env var that contains the file path to the TLS cert.
        EnvironmentVariableTLSCertFile = "TLS_CERT_FILE"

        // EnvironmentVariableTLSKeyFile is an env var that contains the file path to the TLS key.
        EnvironmentVariableTLSKeyFile = "TLS_KEY_FILE"
)

// Defaults
const (
        // DefaultBindAddr is the default bind address.
        DefaultBindAddr = ":8080"
        // DefaultHealthzBindAddr is the default healthz bind address.
        DefaultHealthzBindAddr = ":8081"
        // DefaultRedirectTrailingSlash is the default if we should redirect for missing trailing slashes.
        DefaultRedirectTrailingSlash = true
        // DefaultHandleOptions is a default.
        DefaultHandleOptions = false
        // DefaultHandleMethodNotAllowed is a default.
        DefaultHandleMethodNotAllowed = false
        // DefaultRecoverPanics returns if we should recover panics by default.
        DefaultRecoverPanics = true

        // DefaultHSTS is the default for if hsts is enabled.
        DefaultHSTS = true
        // DefaultHSTSMaxAgeSeconds is the default hsts max age seconds.
        DefaultHSTSMaxAgeSeconds = 31536000
        // DefaultHSTSIncludeSubdomains is a default.
        DefaultHSTSIncludeSubdomains = true
        // DefaultHSTSPreload is a default.
        DefaultHSTSPreload = true
        // DefaultMaxHeaderBytes is a default that is unset.
        DefaultMaxHeaderBytes = 0
        // DefaultReadTimeout is a default.
        DefaultReadTimeout = 5 * time.Second
        // DefaultReadHeaderTimeout is a default.
        DefaultReadHeaderTimeout time.Duration = 0
        // DefaultWriteTimeout is a default.
        DefaultWriteTimeout time.Duration = 0
        // DefaultIdleTimeout is a default.
        DefaultIdleTimeout time.Duration = 0
        // DefaultCookieName is the default name of the field that contains the session id.
        DefaultCookieName = "SID"
        // DefaultSecureCookieName is the default name of the field that contains the secure session id.
        DefaultSecureCookieName = "SSID"
        // DefaultCookiePath is the default cookie path.
        DefaultCookiePath = "/"
        // DefaultSessionTimeout is the default absolute timeout for a session (here implying we should use session lived sessions).
        DefaultSessionTimeout time.Duration = 0
        // DefaultUseSessionCache is the default if we should use the auth manager session cache.
        DefaultUseSessionCache = true
        // DefaultSessionTimeoutIsAbsolute is the default if we should set absolute session expiries.
        DefaultSessionTimeoutIsAbsolute = true
)

// DefaultHeaders are the default headers added by go-web.
var DefaultHeaders = map[string]string{
        HeaderServer:    PackageName,
        HeaderXServedBy: PackageName,
}

// SessionLockPolicy is a lock policy.
type SessionLockPolicy int

const (
        // SessionUnsafe is a lock-free session policy.
        SessionUnsafe SessionLockPolicy = 0

        // SessionReadLock is a lock policy that acquires a read lock on session.
        SessionReadLock SessionLockPolicy = 1

        // SessionReadWriteLock is a lock policy that acquires both a read and a write lock on session.
        SessionReadWriteLock SessionLockPolicy = 2
)

const (
        // LenSessionID is the byte length of a session id.
        LenSessionID = 64
        // LenSessionIDBase64 is the length of a session id base64 encoded.
        LenSessionIDBase64 = 88

        // ErrSessionIDEmpty is thrown if a session id is empty.
        ErrSessionIDEmpty Error = "auth session id is empty"
        // ErrSessionIDTooLong is thrown if a session id is too long.
        ErrSessionIDTooLong Error = "auth session id is too long"
        // ErrSecureSessionIDEmpty is an error that is thrown if a given secure session id is invalid.
        ErrSecureSessionIDEmpty Error = "auth secure session id is empty"
        // ErrSecureSessionIDTooLong is an error that is thrown if a given secure session id is invalid.
        ErrSecureSessionIDTooLong Error = "auth secure session id is too long"
        // ErrSecureSessionIDInvalid is an error that is thrown if a given secure session id is invalid.
        ErrSecureSessionIDInvalid Error = "auth secure session id is invalid"

        // ErrUnsetViewTemplate is an error that is thrown if a given secure session id is invalid.
        ErrUnsetViewTemplate Error = "view result template is unset"
)

// IsErrSessionInvalid returns if an error is a session invalid error.
func IsErrSessionInvalid(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">switch err </span>{
        case ErrSessionIDEmpty,
                ErrSessionIDTooLong,
                ErrSecureSessionIDEmpty,
                ErrSecureSessionIDTooLong,
                ErrSecureSessionIDInvalid:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file136" style="display: none">package web

import (
        "context"
        "database/sql"
        "encoding/json"
        "encoding/xml"
        "fmt"
        "io/ioutil"
        "net/http"
        "strconv"
        "time"

        "strings"

        "github.com/blend/go-sdk/logger"
)

const (
        // PostBodySize is the maximum post body size we will typically consume.
        PostBodySize = int64(1 &lt;&lt; 26) //64mb

        // PostBodySizeMax is the absolute maximum file size the server can handle.
        PostBodySizeMax = int64(1 &lt;&lt; 32) //enormous.

        // StringEmpty is the empty string.
        StringEmpty = ""
)

// Request is an alias to Ctx.
// It is part of a longer term transition.
type Request = Ctx

// defaultResultProvider is used by bare ctx results, it generally
// won't stay the default for long, as it's overwritten by `App`.
var defaultResultProvider = &amp;TextResultProvider{}

// NewCtx returns a new hc context.
func NewCtx(w ResponseWriter, r *http.Request, p RouteParameters, s State) *Ctx <span class="cov8" title="1">{
        ctx := &amp;Ctx{
                response:        w,
                request:         r,
                routeParameters: p,
                state:           s,
                defaultResultProvider: defaultResultProvider,
        }

        if ctx.state == nil </span><span class="cov8" title="1">{
                ctx.state = State{}
        }</span>

        <span class="cov8" title="1">return ctx</span>
}

// Ctx is the struct that represents the context for an hc request.
type Ctx struct {
        response ResponseWriter
        request  *http.Request

        app  *App
        log  *logger.Logger
        auth *AuthManager

        postBody []byte

        view                  *ViewResultProvider
        json                  *JSONResultProvider
        xml                   *XMLResultProvider
        text                  *TextResultProvider
        defaultResultProvider ResultProvider

        state            State
        routeParameters  RouteParameters
        route            *Route
        statusCode       int
        contentLength    int
        requestStart     time.Time
        requestEnd       time.Time
        requestLogFormat string
        session          *Session

        ctx    context.Context
        cancel context.CancelFunc
}

// WithResponse sets the underlying response.
func (rc *Ctx) WithResponse(res ResponseWriter) *Ctx <span class="cov0" title="0">{
        rc.response = res
        return rc
}</span>

// Response returns the underyling response.
func (rc *Ctx) Response() ResponseWriter <span class="cov8" title="1">{
        return rc.response
}</span>

// WithRequest sets the underlying request.
func (rc *Ctx) WithRequest(req *http.Request) *Ctx <span class="cov0" title="0">{
        rc.request = req
        return rc
}</span>

// Request returns the underlying request.
func (rc *Ctx) Request() *http.Request <span class="cov8" title="1">{
        return rc.request
}</span>

// WithTx sets a transaction on the context.
func (rc *Ctx) WithTx(tx *sql.Tx, optionalKey ...string) *Ctx <span class="cov8" title="1">{
        WithTx(rc, tx, optionalKey...)
        return rc
}</span>

// WithContext sets the background context for the request.
func (rc *Ctx) WithContext(ctx context.Context) *Ctx <span class="cov0" title="0">{
        rc.ctx = ctx
        return rc
}</span>

// Background returns the background context for a request.
func (rc *Ctx) Background() context.Context <span class="cov0" title="0">{
        return rc.ctx
}</span>

// Cancel calls the cancel func if it's set.
func (rc *Ctx) Cancel() <span class="cov0" title="0">{
        if rc.cancel != nil </span><span class="cov0" title="0">{
                rc.cancel()
        }</span>
}

// WithApp sets the app reference for the ctx.
func (rc *Ctx) WithApp(app *App) *Ctx <span class="cov0" title="0">{
        rc.app = app
        return rc
}</span>

// App returns the app reference.
func (rc *Ctx) App() *App <span class="cov0" title="0">{
        return rc.app
}</span>

// WithAuth sets the request context auth.
func (rc *Ctx) WithAuth(authManager *AuthManager) *Ctx <span class="cov0" title="0">{
        rc.auth = authManager
        return rc
}</span>

// Auth returns the AuthManager for the request.
func (rc *Ctx) Auth() *AuthManager <span class="cov8" title="1">{
        return rc.auth
}</span>

// WithSession sets the session for the request.
func (rc *Ctx) WithSession(session *Session) *Ctx <span class="cov8" title="1">{
        rc.session = session
        return rc
}</span>

// Session returns the session (if any) on the request.
func (rc *Ctx) Session() *Session <span class="cov8" title="1">{
        return rc.session
}</span>

// View returns the view result provider.
func (rc *Ctx) View() *ViewResultProvider <span class="cov8" title="1">{
        return rc.view
}</span>

// JSON returns the JSON result provider.
func (rc *Ctx) JSON() *JSONResultProvider <span class="cov8" title="1">{
        return rc.json
}</span>

// XML returns the xml result provider.
func (rc *Ctx) XML() *XMLResultProvider <span class="cov0" title="0">{
        return rc.xml
}</span>

// Text returns the text result provider.
func (rc *Ctx) Text() *TextResultProvider <span class="cov8" title="1">{
        return rc.text
}</span>

// DefaultResultProvider returns the current result provider for the context. This is
// set by calling SetDefaultResultProvider or using one of the pre-built middleware
// steps that set it for you.
func (rc *Ctx) DefaultResultProvider() ResultProvider <span class="cov8" title="1">{
        return rc.defaultResultProvider
}</span>

// WithDefaultResultProvider sets the default result provider.
func (rc *Ctx) WithDefaultResultProvider(provider ResultProvider) *Ctx <span class="cov8" title="1">{
        rc.defaultResultProvider = provider
        return rc
}</span>

// State returns the full state bag.
func (rc *Ctx) State() State <span class="cov8" title="1">{
        return rc.state
}</span>

// StateValue returns an object in the state cache.
func (rc *Ctx) StateValue(key string) interface{} <span class="cov8" title="1">{
        if rc.state == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if value, hasValue := rc.state[key]; hasValue </span><span class="cov8" title="1">{
                return value
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// WithStateValue sets the state for a key to an object.
func (rc *Ctx) WithStateValue(key string, value interface{}) *Ctx <span class="cov8" title="1">{
        if rc.state == nil </span><span class="cov0" title="0">{
                rc.state = State{}
        }</span>
        <span class="cov8" title="1">rc.state[key] = value
        return rc</span>
}

// ParamString is a shortcut for ParamString that swallows the missing value error.
func (rc *Ctx) ParamString(name string) string <span class="cov0" title="0">{
        value, _ := rc.Param(name)
        return value
}</span>

// Param returns a parameter from the request.
func (rc *Ctx) Param(name string) (string, error) <span class="cov8" title="1">{
        if rc.routeParameters != nil </span><span class="cov0" title="0">{
                routeValue := rc.routeParameters.Get(name)
                if len(routeValue) &gt; 0 </span><span class="cov0" title="0">{
                        return routeValue, nil
                }</span>
        }
        <span class="cov8" title="1">if rc.request != nil </span><span class="cov8" title="1">{
                if rc.request.URL != nil </span><span class="cov8" title="1">{
                        queryValue := rc.request.URL.Query().Get(name)
                        if len(queryValue) &gt; 0 </span><span class="cov8" title="1">{
                                return queryValue, nil
                        }</span>
                }
                <span class="cov8" title="1">if rc.request.Header != nil </span><span class="cov8" title="1">{
                        headerValue := rc.request.Header.Get(name)
                        if len(headerValue) &gt; 0 </span><span class="cov8" title="1">{
                                return headerValue, nil
                        }</span>
                }

                <span class="cov8" title="1">formValue := rc.request.FormValue(name)
                if len(formValue) &gt; 0 </span><span class="cov8" title="1">{
                        return formValue, nil
                }</span>

                <span class="cov8" title="1">cookie, cookieErr := rc.request.Cookie(name)
                if cookieErr == nil &amp;&amp; len(cookie.Value) != 0 </span><span class="cov8" title="1">{
                        return cookie.Value, nil
                }</span>
        }

        <span class="cov0" title="0">return "", newParameterMissingError(name)</span>
}

// ParamInt returns a parameter from any location as an integer.
func (rc *Ctx) ParamInt(name string) (int, error) <span class="cov0" title="0">{
        paramValue, err := rc.Param(name)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return strconv.Atoi(paramValue)</span>
}

// ParamInt64 returns a parameter from any location as an int64.
func (rc *Ctx) ParamInt64(name string) (int64, error) <span class="cov0" title="0">{
        paramValue, err := rc.Param(name)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return strconv.ParseInt(paramValue, 10, 64)</span>
}

// ParamFloat64 returns a parameter from any location as a float64.
func (rc *Ctx) ParamFloat64(name string) (float64, error) <span class="cov0" title="0">{
        paramValue, err := rc.Param(name)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">return strconv.ParseFloat(paramValue, 64)</span>
}

// ParamTime returns a parameter from any location as a time with a given format.
func (rc *Ctx) ParamTime(name, format string) (time.Time, error) <span class="cov0" title="0">{
        paramValue, err := rc.Param(name)
        if err != nil </span><span class="cov0" title="0">{
                return time.Time{}, err
        }</span>
        <span class="cov0" title="0">return time.Parse(format, paramValue)</span>
}

// ParamBool returns a boolean value for a param.
func (rc *Ctx) ParamBool(name string) (bool, error) <span class="cov0" title="0">{
        paramValue, err := rc.Param(name)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">lower := strings.ToLower(paramValue)
        return lower == "true" || lower == "1" || lower == "yes", nil</span>
}

// PostBody returns the bytes in a post body.
func (rc *Ctx) PostBody() ([]byte, error) <span class="cov8" title="1">{
        var err error
        if len(rc.postBody) == 0 </span><span class="cov8" title="1">{
                if rc.request != nil &amp;&amp; rc.request.Body != nil </span><span class="cov8" title="1">{
                        defer rc.request.Body.Close()
                        rc.postBody, err = ioutil.ReadAll(rc.request.Body)
                }</span>
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return rc.postBody, nil</span>
}

// PostBodyAsString returns the post body as a string.
func (rc *Ctx) PostBodyAsString() (string, error) <span class="cov8" title="1">{
        body, err := rc.PostBody()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return string(body), nil</span>
}

// PostBodyAsJSON reads the incoming post body (closing it) and marshals it to the target object as json.
func (rc *Ctx) PostBodyAsJSON(response interface{}) error <span class="cov8" title="1">{
        body, err := rc.PostBody()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return json.Unmarshal(body, response)</span>
}

// PostBodyAsXML reads the incoming post body (closing it) and marshals it to the target object as xml.
func (rc *Ctx) PostBodyAsXML(response interface{}) error <span class="cov0" title="0">{
        body, err := rc.PostBody()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return xml.Unmarshal(body, response)</span>
}

// PostedFiles returns any files posted
func (rc *Ctx) PostedFiles() ([]PostedFile, error) <span class="cov8" title="1">{
        var files []PostedFile

        err := rc.request.ParseMultipartForm(PostBodySize)
        if err == nil </span><span class="cov8" title="1">{
                for key := range rc.request.MultipartForm.File </span><span class="cov8" title="1">{
                        fileReader, fileHeader, err := rc.request.FormFile(key)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">bytes, err := ioutil.ReadAll(fileReader)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">files = append(files, PostedFile{Key: key, FileName: fileHeader.Filename, Contents: bytes})</span>
                }
        } else<span class="cov8" title="1"> {
                err = rc.request.ParseForm()
                if err == nil </span><span class="cov8" title="1">{
                        for key := range rc.request.PostForm </span><span class="cov0" title="0">{
                                if fileReader, fileHeader, err := rc.request.FormFile(key); err == nil &amp;&amp; fileReader != nil </span><span class="cov0" title="0">{
                                        bytes, err := ioutil.ReadAll(fileReader)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                        <span class="cov0" title="0">files = append(files, PostedFile{Key: key, FileName: fileHeader.Filename, Contents: bytes})</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">return files, nil</span>
}

func newParameterMissingError(paramName string) error <span class="cov8" title="1">{
        return fmt.Errorf("`%s` parameter is missing", paramName)
}</span>

// RouteParamInt returns a route parameter as an integer.
func (rc *Ctx) RouteParamInt(key string) (int, error) <span class="cov8" title="1">{
        if value, hasKey := rc.routeParameters[key]; hasKey </span><span class="cov8" title="1">{
                return strconv.Atoi(value)
        }</span>
        <span class="cov0" title="0">return 0, newParameterMissingError(key)</span>
}

// RouteParamInt64 returns a route parameter as an integer.
func (rc *Ctx) RouteParamInt64(key string) (int64, error) <span class="cov8" title="1">{
        if value, hasKey := rc.routeParameters[key]; hasKey </span><span class="cov8" title="1">{
                return strconv.ParseInt(value, 10, 64)
        }</span>
        <span class="cov0" title="0">return 0, newParameterMissingError(key)</span>
}

// RouteParamFloat64 returns a route parameter as an float64.
func (rc *Ctx) RouteParamFloat64(key string) (float64, error) <span class="cov0" title="0">{
        if value, hasKey := rc.routeParameters[key]; hasKey </span><span class="cov0" title="0">{
                return strconv.ParseFloat(value, 64)
        }</span>
        <span class="cov0" title="0">return 0, newParameterMissingError(key)</span>
}

// RouteParam returns a string route parameter
func (rc *Ctx) RouteParam(key string) (string, error) <span class="cov8" title="1">{
        if value, hasKey := rc.routeParameters[key]; hasKey </span><span class="cov8" title="1">{
                return value, nil
        }</span>
        <span class="cov0" title="0">return StringEmpty, newParameterMissingError(key)</span>
}

// QueryParam returns a query parameter.
func (rc *Ctx) QueryParam(key string) (string, error) <span class="cov0" title="0">{
        if value := rc.request.URL.Query().Get(key); len(value) &gt; 0 </span><span class="cov0" title="0">{
                return value, nil
        }</span>
        <span class="cov0" title="0">return StringEmpty, newParameterMissingError(key)</span>
}

// QueryParamInt returns a query parameter as an integer.
func (rc *Ctx) QueryParamInt(key string) (int, error) <span class="cov0" title="0">{
        if value := rc.request.URL.Query().Get(key); len(value) &gt; 0 </span><span class="cov0" title="0">{
                return strconv.Atoi(value)
        }</span>
        <span class="cov0" title="0">return 0, newParameterMissingError(key)</span>
}

// QueryParamInt64 returns a query parameter as an int64.
func (rc *Ctx) QueryParamInt64(key string) (int64, error) <span class="cov0" title="0">{
        if value := rc.request.URL.Query().Get(key); len(value) &gt; 0 </span><span class="cov0" title="0">{
                return strconv.ParseInt(value, 10, 64)
        }</span>
        <span class="cov0" title="0">return 0, newParameterMissingError(key)</span>
}

// QueryParamFloat64 returns a query parameter as a float64.
func (rc *Ctx) QueryParamFloat64(key string) (float64, error) <span class="cov0" title="0">{
        if value := rc.request.URL.Query().Get(key); len(value) &gt; 0 </span><span class="cov0" title="0">{
                return strconv.ParseFloat(value, 64)
        }</span>
        <span class="cov0" title="0">return 0, newParameterMissingError(key)</span>
}

// QueryParamTime returns a query parameter as a time.Time.
func (rc *Ctx) QueryParamTime(key, format string) (time.Time, error) <span class="cov0" title="0">{
        if value := rc.request.URL.Query().Get(key); len(value) &gt; 0 </span><span class="cov0" title="0">{
                return time.Parse(format, value)
        }</span>
        <span class="cov0" title="0">return time.Time{}, newParameterMissingError(key)</span>
}

// HeaderParam returns a header parameter value.
func (rc *Ctx) HeaderParam(key string) (string, error) <span class="cov8" title="1">{
        if value := rc.request.Header.Get(key); len(value) &gt; 0 </span><span class="cov8" title="1">{
                return value, nil
        }</span>
        <span class="cov8" title="1">return StringEmpty, newParameterMissingError(key)</span>
}

// HeaderParamInt returns a header parameter value as an integer.
func (rc *Ctx) HeaderParamInt(key string) (int, error) <span class="cov0" title="0">{
        if value := rc.request.Header.Get(key); len(value) &gt; 0 </span><span class="cov0" title="0">{
                return strconv.Atoi(value)
        }</span>
        <span class="cov0" title="0">return 0, newParameterMissingError(key)</span>
}

// HeaderParamInt64 returns a header parameter value as an integer.
func (rc *Ctx) HeaderParamInt64(key string) (int64, error) <span class="cov0" title="0">{
        if value := rc.request.Header.Get(key); len(value) &gt; 0 </span><span class="cov0" title="0">{
                return strconv.ParseInt(value, 10, 64)
        }</span>
        <span class="cov0" title="0">return 0, newParameterMissingError(key)</span>
}

// HeaderParamFloat64 returns a header parameter value as an float64.
func (rc *Ctx) HeaderParamFloat64(key string) (float64, error) <span class="cov0" title="0">{
        if value := rc.request.Header.Get(key); len(value) &gt; 0 </span><span class="cov0" title="0">{
                return strconv.ParseFloat(value, 64)
        }</span>
        <span class="cov0" title="0">return 0, newParameterMissingError(key)</span>
}

// HeaderParamTime returns a header parameter value as an float64.
func (rc *Ctx) HeaderParamTime(key, format string) (time.Time, error) <span class="cov0" title="0">{
        if value := rc.request.Header.Get(key); len(value) &gt; 0 </span><span class="cov0" title="0">{
                return time.Parse(format, key)
        }</span>
        <span class="cov0" title="0">return time.Time{}, newParameterMissingError(key)</span>
}

// GetCookie returns a named cookie from the request.
func (rc *Ctx) GetCookie(name string) *http.Cookie <span class="cov8" title="1">{
        cookie, err := rc.request.Cookie(name)
        if err != nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return cookie</span>
}

// WriteCookie writes the cookie to the response.
func (rc *Ctx) WriteCookie(cookie *http.Cookie) <span class="cov8" title="1">{
        http.SetCookie(rc.response, cookie)
}</span>

func (rc *Ctx) getCookieDomain() string <span class="cov8" title="1">{
        if rc.app != nil &amp;&amp; rc.app.baseURL != nil </span><span class="cov0" title="0">{
                return rc.app.baseURL.Host
        }</span>
        <span class="cov8" title="1">return rc.request.Host</span>
}

// WriteNewCookie is a helper method for WriteCookie.
func (rc *Ctx) WriteNewCookie(name string, value string, expires *time.Time, path string, secure bool) <span class="cov8" title="1">{
        c := http.Cookie{
                Name:     name,
                HttpOnly: true,
                Value:    value,
                Path:     path,
                Secure:   secure,
                Domain:   rc.getCookieDomain(),
        }
        if expires != nil </span><span class="cov8" title="1">{
                c.Expires = *expires
        }</span>
        <span class="cov8" title="1">rc.WriteCookie(&amp;c)</span>
}

// ExtendCookieByDuration extends a cookie by a time duration (on the order of nanoseconds to hours).
func (rc *Ctx) ExtendCookieByDuration(name string, path string, duration time.Duration) <span class="cov0" title="0">{
        c := rc.GetCookie(name)
        if c == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">c.Path = path
        c.Domain = rc.getCookieDomain()
        c.Expires = c.Expires.Add(duration)
        rc.WriteCookie(c)</span>
}

// ExtendCookie extends a cookie by years, months or days.
func (rc *Ctx) ExtendCookie(name string, path string, years, months, days int) <span class="cov0" title="0">{
        c := rc.GetCookie(name)
        if c == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">c.Path = path
        c.Domain = rc.getCookieDomain()
        c.Expires.AddDate(years, months, days)
        rc.WriteCookie(c)</span>
}

// ExpireCookie expires a cookie.
func (rc *Ctx) ExpireCookie(name string, path string) <span class="cov8" title="1">{
        c := rc.GetCookie(name)
        if c == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">c.Path = path
        c.Value = NewSessionID()
        c.Domain = rc.getCookieDomain()
        c.Expires = time.Now().UTC().AddDate(-1, 0, 0)
        rc.WriteCookie(c)</span>
}

// --------------------------------------------------------------------------------
// Diagnostics
// --------------------------------------------------------------------------------

// Logger returns the diagnostics agent.
func (rc *Ctx) Logger() *logger.Logger <span class="cov0" title="0">{
        return rc.log
}</span>

// --------------------------------------------------------------------------------
// Basic result providers
// --------------------------------------------------------------------------------

// Raw returns a binary response body, sniffing the content type.
func (rc *Ctx) Raw(body []byte) *RawResult <span class="cov8" title="1">{
        sniffedContentType := http.DetectContentType(body)
        return rc.RawWithContentType(sniffedContentType, body)
}</span>

// RawWithContentType returns a binary response with a given content type.
func (rc *Ctx) RawWithContentType(contentType string, body []byte) *RawResult <span class="cov8" title="1">{
        return &amp;RawResult{ContentType: contentType, Body: body}
}</span>

// NoContent returns a service response.
func (rc *Ctx) NoContent() *NoContentResult <span class="cov0" title="0">{
        return &amp;NoContentResult{}
}</span>

// Static returns a static result.
func (rc *Ctx) Static(filePath string) *StaticResult <span class="cov8" title="1">{
        return NewStaticResultForFile(filePath)
}</span>

// Redirectf returns a redirect result.
func (rc *Ctx) Redirectf(format string, args ...interface{}) *RedirectResult <span class="cov0" title="0">{
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                return &amp;RedirectResult{
                        RedirectURI: fmt.Sprintf(format, args...),
                }
        }</span>
        <span class="cov0" title="0">return &amp;RedirectResult{
                RedirectURI: format,
        }</span>
}

// RedirectWithMethodf returns a redirect result with a given method.
func (rc *Ctx) RedirectWithMethodf(method, format string, args ...interface{}) *RedirectResult <span class="cov0" title="0">{
        return &amp;RedirectResult{
                Method:      method,
                RedirectURI: fmt.Sprintf(format, args...),
        }
}</span>

// --------------------------------------------------------------------------------
// Stats Methods used for logging.
// --------------------------------------------------------------------------------

// StatusCode returns the status code for the request, this is used for logging.
func (rc *Ctx) getLoggedStatusCode() int <span class="cov0" title="0">{
        return rc.statusCode
}</span>

// SetStatusCode sets the status code for the request, this is used for logging.
func (rc *Ctx) setLoggedStatusCode(code int) <span class="cov8" title="1">{
        rc.statusCode = code
}</span>

// ContentLength returns the content length for the request, this is used for logging.
func (rc *Ctx) getLoggedContentLength() int <span class="cov0" title="0">{
        return rc.contentLength
}</span>

// SetContentLength sets the content length, this is used for logging.
func (rc *Ctx) setLoggedContentLength(length int) <span class="cov8" title="1">{
        rc.contentLength = length
}</span>

// OnRequestStart will mark the start of request timing.
func (rc *Ctx) onRequestStart() <span class="cov8" title="1">{
        rc.requestStart = time.Now().UTC()
}</span>

// Start returns the request start time.
func (rc Ctx) Start() time.Time <span class="cov0" title="0">{
        return rc.requestStart
}</span>

// OnRequestEnd will mark the end of request timing.
func (rc *Ctx) onRequestEnd() <span class="cov8" title="1">{
        rc.requestEnd = time.Now().UTC()
}</span>

// Elapsed is the time delta between start and end.
func (rc *Ctx) Elapsed() time.Duration <span class="cov8" title="1">{
        if !rc.requestEnd.IsZero() </span><span class="cov8" title="1">{
                return rc.requestEnd.Sub(rc.requestStart)
        }</span>
        <span class="cov0" title="0">return time.Now().UTC().Sub(rc.requestStart)</span>
}

// Route returns the original route match for the request.
func (rc *Ctx) Route() *Route <span class="cov8" title="1">{
        return rc.route
}</span>

// PostedFile is a file that has been posted to an hc endpoint.
type PostedFile struct {
        Key      string
        FileName string
        Contents []byte
}
</pre>
		
		<pre class="file" id="file137" style="display: none">package web

// Error is a simple wrapper for strings to help with constant errors.
type Error string

func (e Error) Error() string <span class="cov8" title="1">{ return string(e) }</span>
</pre>
		
		<pre class="file" id="file138" style="display: none">package web

import (
        "context"
        "fmt"
        "net"
        "net/http"
        "sort"
        "strings"
        "sync"
        "time"

        "github.com/blend/go-sdk/env"
        "github.com/blend/go-sdk/exception"
        "github.com/blend/go-sdk/logger"
)

const (
        // VarzStarted is a common variable.
        VarzStarted = "startedUTC"
        // VarzRequests is a common variable.
        VarzRequests = "http_requests"
        // VarzRequests2xx is a common variable.
        VarzRequests2xx = "http_requests2xx"
        // VarzRequests3xx is a common variable.
        VarzRequests3xx = "http_requests3xx"
        // VarzRequests4xx is a common variable.
        VarzRequests4xx = "http_requests4xx"
        // VarzRequests5xx is a common variable.
        VarzRequests5xx = "http_requests5xx"
        // VarzErrors is a common variable.
        VarzErrors = "errors_total"
        // VarzFatals is a common variable.
        VarzFatals = "fatals_total"

        // ListenerHealthz is the uid of the healthz logger listeners.
        ListenerHealthz = "healthz"

        // ErrHealthzAppUnset is a common error.
        ErrHealthzAppUnset Error = "healthz app unset"
)

// NewHealthz returns a new healthz.
func NewHealthz(app *App) *Healthz <span class="cov8" title="1">{
        return &amp;Healthz{
                app:            app,
                defaultHeaders: map[string]string{},
                state:          State{},
                vars: map[string]interface{}{
                        VarzRequests:    int64(0),
                        VarzRequests2xx: int64(0),
                        VarzRequests3xx: int64(0),
                        VarzRequests4xx: int64(0),
                        VarzRequests5xx: int64(0),
                        VarzErrors:      int64(0),
                        VarzFatals:      int64(0),
                },
        }
}</span>

// NewHealthzFromEnv returns a new healthz from the env.
func NewHealthzFromEnv(app *App) *Healthz <span class="cov0" title="0">{
        return NewHealthzFromConfig(app, NewHealthzConfigFromEnv())
}</span>

// NewHealthzFromConfig returns a new healthz sidecar from a config.
func NewHealthzFromConfig(app *App, cfg *HealthzConfig) *Healthz <span class="cov0" title="0">{
        hz := NewHealthz(app)
        hz = hz.WithBindAddr(cfg.GetBindAddr())
        hz = hz.WithRecoverPanics(cfg.GetRecoverPanics())
        hz = hz.WithMaxHeaderBytes(cfg.GetMaxHeaderBytes())
        hz = hz.WithReadHeaderTimeout(cfg.GetReadHeaderTimeout())
        hz = hz.WithReadTimeout(cfg.GetReadTimeout())
        hz = hz.WithWriteTimeout(cfg.GetWriteTimeout())
        hz = hz.WithIdleTimeout(cfg.GetIdleTimeout())
        return hz
}</span>

// HealthzHost hosts an app with a healthz, starting both servers.
func HealthzHost(app *App, hz *Healthz) (err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = exception.Newf("%v", r)
                        return
                }</span>
        }()

        <span class="cov0" title="0">appQuit := make(chan struct{})
        hzQuit := make(chan struct{})
        go func() </span><span class="cov0" title="0">{
                err = app.Start()
                close(appQuit)
        }</span>()

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                err = hz.Start()
                close(hzQuit)
        }</span>()
        <span class="cov0" title="0">select </span>{
        case &lt;-appQuit:<span class="cov0" title="0">
                return</span>
        case &lt;-hzQuit:<span class="cov0" title="0">
                return</span>
        }
}

// Healthz is a sentinel / healthcheck sidecar that can run on a different
// port to the main app.
// It typically implements the following routes:
//         /healthz - overall health endpoint, 200 on healthy, 5xx on not.
//         /varz    - basic stats and metrics since start
//        /debug/vars - `pkg/expvar` output.
type Healthz struct {
        app        *App
        startedUTC time.Time
        bindAddr   string
        log        *logger.Logger

        defaultHeaders map[string]string
        server         *http.Server
        listener       *net.TCPListener

        maxHeaderBytes    int
        readTimeout       time.Duration
        readHeaderTimeout time.Duration
        writeTimeout      time.Duration
        idleTimeout       time.Duration

        state State

        varsLock sync.Mutex
        vars     map[string]interface{}

        recoverPanics bool
        err           error
}

// App returns the underlying app.
func (hz *Healthz) App() *App <span class="cov8" title="1">{
        return hz.app
}</span>

// Vars returns the underlying vars collection.
func (hz *Healthz) Vars() State <span class="cov0" title="0">{
        return hz.vars
}</span>

// Server returns the underlying server.
func (hz *Healthz) Server() *http.Server <span class="cov0" title="0">{
        return hz.server
}</span>

// Listener returns the underlying listener.
func (hz *Healthz) Listener() *net.TCPListener <span class="cov8" title="1">{
        return hz.listener
}</span>

// WithServer sets the underlying server.
func (hz *Healthz) WithServer(server *http.Server) *Healthz <span class="cov0" title="0">{
        hz.server = server
        return hz
}</span>

// WithErr sets the err that will abort app start.
func (hz *Healthz) WithErr(err error) *Healthz <span class="cov0" title="0">{
        hz.err = err
        return hz
}</span>

// Err returns any errors that are generated before app start.
func (hz *Healthz) Err() error <span class="cov0" title="0">{
        return hz.err
}</span>

// WithDefaultHeaders sets the default headers
func (hz *Healthz) WithDefaultHeaders(headers map[string]string) *Healthz <span class="cov0" title="0">{
        hz.defaultHeaders = headers
        return hz
}</span>

// WithDefaultHeader adds a default header.
func (hz *Healthz) WithDefaultHeader(key string, value string) *Healthz <span class="cov0" title="0">{
        hz.defaultHeaders[key] = value
        return hz
}</span>

// DefaultHeaders returns the default headers.
func (hz *Healthz) DefaultHeaders() map[string]string <span class="cov0" title="0">{
        return hz.defaultHeaders
}</span>

// WithState sets app state and returns a reference to the app for building apps with a fluent api.
func (hz *Healthz) WithState(key string, value interface{}) *Healthz <span class="cov0" title="0">{
        hz.state[key] = value
        return hz
}</span>

// GetState gets app state element by key.
func (hz *Healthz) GetState(key string) interface{} <span class="cov0" title="0">{
        if value, hasValue := hz.state[key]; hasValue </span><span class="cov0" title="0">{
                return value
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SetState sets app state.
func (hz *Healthz) SetState(key string, value interface{}) <span class="cov0" title="0">{
        hz.state[key] = value
}</span>

// State is a bag for common app state.
func (hz *Healthz) State() State <span class="cov0" title="0">{
        return hz.state
}</span>

// RecoverPanics returns if the app recovers panics.
func (hz *Healthz) RecoverPanics() bool <span class="cov0" title="0">{
        return hz.recoverPanics
}</span>

// WithRecoverPanics sets if the app should recover panics.
func (hz *Healthz) WithRecoverPanics(value bool) *Healthz <span class="cov0" title="0">{
        hz.recoverPanics = value
        return hz
}</span>

// MaxHeaderBytes returns the app max header bytes.
func (hz *Healthz) MaxHeaderBytes() int <span class="cov0" title="0">{
        return hz.maxHeaderBytes
}</span>

// WithMaxHeaderBytes sets the max header bytes value and returns a reference.
func (hz *Healthz) WithMaxHeaderBytes(byteCount int) *Healthz <span class="cov0" title="0">{
        hz.maxHeaderBytes = byteCount
        return hz
}</span>

// ReadHeaderTimeout returns the read header timeout for the server.
func (hz *Healthz) ReadHeaderTimeout() time.Duration <span class="cov0" title="0">{
        return hz.readHeaderTimeout
}</span>

// WithReadHeaderTimeout returns the read header timeout for the server.
func (hz *Healthz) WithReadHeaderTimeout(timeout time.Duration) *Healthz <span class="cov0" title="0">{
        hz.readHeaderTimeout = timeout
        return hz
}</span>

// ReadTimeout returns the read timeout for the server.
func (hz *Healthz) ReadTimeout() time.Duration <span class="cov0" title="0">{
        return hz.readTimeout
}</span>

// WithReadTimeout sets the read timeout for the server and returns a reference to the app for building apps with a fluent api.
func (hz *Healthz) WithReadTimeout(timeout time.Duration) *Healthz <span class="cov0" title="0">{
        hz.readTimeout = timeout
        return hz
}</span>

// IdleTimeout is the time before we close a connection.
func (hz *Healthz) IdleTimeout() time.Duration <span class="cov0" title="0">{
        return hz.idleTimeout
}</span>

// WithIdleTimeout sets the idle timeout.
func (hz *Healthz) WithIdleTimeout(timeout time.Duration) *Healthz <span class="cov0" title="0">{
        hz.idleTimeout = timeout
        return hz
}</span>

// WriteTimeout returns the write timeout for the server.
func (hz *Healthz) WriteTimeout() time.Duration <span class="cov0" title="0">{
        return hz.writeTimeout
}</span>

// WithWriteTimeout sets the write timeout for the server and returns a reference to the app for building apps with a fluent api.
func (hz *Healthz) WithWriteTimeout(timeout time.Duration) *Healthz <span class="cov0" title="0">{
        hz.writeTimeout = timeout
        return hz
}</span>

// WithPort sets the port for the bind address of the app, and returns a reference to the app.
func (hz *Healthz) WithPort(port int32) *Healthz <span class="cov0" title="0">{
        hz.SetPort(port)
        return hz
}</span>

// SetPort sets the port the app listens on, typically to `:%d` which indicates listen on any interface.
func (hz *Healthz) SetPort(port int32) <span class="cov0" title="0">{
        hz.bindAddr = fmt.Sprintf(":%v", port)
}</span>

// WithPortFromEnv sets the port from an environment variable, and returns a reference to the app.
func (hz *Healthz) WithPortFromEnv() *Healthz <span class="cov0" title="0">{
        hz.SetPortFromEnv()
        return hz
}</span>

// SetPortFromEnv sets the port from an environment variable, and returns a reference to the app.
func (hz *Healthz) SetPortFromEnv() <span class="cov0" title="0">{
        if env.Env().Has(EnvironmentVariablePort) </span><span class="cov0" title="0">{
                port, err := env.Env().Int32(EnvironmentVariablePort)
                if err != nil </span><span class="cov0" title="0">{
                        hz.err = err
                }</span>
                <span class="cov0" title="0">hz.bindAddr = fmt.Sprintf(":%v", port)</span>
        }
}

// BindAddr returns the address the server will bind to.
func (hz *Healthz) BindAddr() string <span class="cov8" title="1">{
        return hz.bindAddr
}</span>

// WithBindAddr sets the address the app listens on, and returns a reference to the app.
func (hz *Healthz) WithBindAddr(bindAddr string) *Healthz <span class="cov8" title="1">{
        hz.bindAddr = bindAddr
        return hz
}</span>

// WithBindAddrFromEnv sets the address the app listens on, and returns a reference to the app.
func (hz *Healthz) WithBindAddrFromEnv() *Healthz <span class="cov0" title="0">{
        hz.bindAddr = env.Env().String(EnvironmentVariableBindAddr)
        return hz
}</span>

// Logger returns the diagnostics agent for the app.
func (hz *Healthz) Logger() *logger.Logger <span class="cov0" title="0">{
        return hz.log
}</span>

// WithLogger sets the app logger agent and returns a reference to the app.
// It also sets underlying loggers in any child resources like providers and the auth manager.
func (hz *Healthz) WithLogger(log *logger.Logger) *Healthz <span class="cov8" title="1">{
        hz.log = log
        return hz
}</span>

// Start starts the server.
func (hz *Healthz) Start() (err error) <span class="cov8" title="1">{
        if hz.app == nil </span><span class="cov0" title="0">{
                err = exception.Wrap(ErrHealthzAppUnset)
                return
        }</span>
        <span class="cov8" title="1">start := time.Now()
        if hz.log != nil </span><span class="cov8" title="1">{
                hz.log.SyncTrigger(NewAppEvent(HealthzStart).WithHealthz(hz))
                defer hz.log.SyncTrigger(NewAppEvent(HealthzExit).WithHealthz(hz).WithErr(err))
        }</span>

        <span class="cov8" title="1">if hz.server == nil </span><span class="cov8" title="1">{
                hz.server = hz.CreateServer()
        }</span>
        <span class="cov8" title="1">hz.vars[VarzStarted] = time.Now().UTC()

        if hz.app.log != nil </span><span class="cov8" title="1">{
                hz.app.log.Listen(logger.WebRequest, ListenerHealthz, logger.NewWebRequestEventListener(hz.appWebRequestListener))
                hz.app.log.Listen(logger.Error, ListenerHealthz, logger.NewErrorEventListener(hz.appErrorListener))
                hz.app.log.Listen(logger.Fatal, ListenerHealthz, logger.NewErrorEventListener(hz.appErrorListener))
        }</span>

        <span class="cov8" title="1">if hz.log != nil </span><span class="cov8" title="1">{
                hz.log.SyncInfof("healthz server started, listening on %s", hz.server.Addr)
                if hz.log.Flags() != nil </span><span class="cov8" title="1">{
                        hz.log.SyncInfof("healthz server logging flags %s", hz.log.Flags().String())
                }</span>
        }

        <span class="cov8" title="1">var listener net.Listener
        listener, err = net.Listen("tcp", hz.bindAddr)
        if err != nil </span><span class="cov0" title="0">{
                err = exception.Wrap(err)
                return
        }</span>
        <span class="cov8" title="1">hz.listener = listener.(*net.TCPListener)

        if hz.log != nil </span><span class="cov8" title="1">{
                hz.log.SyncTrigger(NewAppEvent(HealthzStartComplete).WithHealthz(hz).WithElapsed(time.Since(start)))
        }</span>

        <span class="cov8" title="1">return hz.server.Serve(TCPKeepAliveListener{hz.listener})</span>
}

// Shutdown stops the server.
func (hz *Healthz) Shutdown() error <span class="cov8" title="1">{
        if hz.server == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if hz.log != nil </span><span class="cov8" title="1">{
                hz.log.SyncInfof("healthz server shutting down")
        }</span>
        <span class="cov8" title="1">hz.server.SetKeepAlivesEnabled(false)
        return exception.Wrap(hz.server.Shutdown(ctx))</span>
}

// CreateServer returns the basic http.Server for the app.
func (hz *Healthz) CreateServer() *http.Server <span class="cov8" title="1">{
        return &amp;http.Server{
                Addr:              hz.BindAddr(),
                Handler:           hz,
                MaxHeaderBytes:    hz.maxHeaderBytes,
                ReadTimeout:       hz.readTimeout,
                ReadHeaderTimeout: hz.readHeaderTimeout,
                WriteTimeout:      hz.writeTimeout,
                IdleTimeout:       hz.idleTimeout,
        }
}</span>

// ServeHTTP makes the router implement the http.Handler interface.
func (hz *Healthz) ServeHTTP(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if hz.recoverPanics </span><span class="cov0" title="0">{
                defer hz.recover(w, r)
        }</span>

        <span class="cov8" title="1">res := NewRawResponseWriter(w)
        res.Header().Set(HeaderContentEncoding, ContentEncodingIdentity)

        route := strings.ToLower(r.URL.Path)

        start := time.Now()
        if hz.log != nil </span><span class="cov8" title="1">{
                hz.log.Trigger(logger.NewWebRequestStartEvent(r).WithState(hz.state).WithRoute(route))

                defer func() </span><span class="cov8" title="1">{
                        hz.log.Trigger(logger.NewWebRequestEvent(r).
                                WithStatusCode(res.StatusCode()).
                                WithElapsed(time.Since(start)).
                                WithContentLength(int64(res.ContentLength())).
                                WithState(hz.state))
                }</span>()
        }

        <span class="cov8" title="1">if len(hz.defaultHeaders) &gt; 0 </span><span class="cov0" title="0">{
                for key, value := range hz.defaultHeaders </span><span class="cov0" title="0">{
                        res.Header().Set(key, value)
                }</span>
        }

        <span class="cov8" title="1">switch route </span>{
        case "/healthz":<span class="cov8" title="1">
                hz.healthzHandler(res, r)</span>
        case "/varz":<span class="cov0" title="0">
                hz.varzHandler(res, r)</span>
        default:<span class="cov0" title="0">
                http.NotFound(res, r)</span>
        }

        <span class="cov8" title="1">if err := res.Close(); err != nil &amp;&amp; err != http.ErrBodyNotAllowed &amp;&amp; hz.log != nil </span><span class="cov0" title="0">{
                hz.log.Error(err)
        }</span>
}

func (hz *Healthz) recover(w http.ResponseWriter, req *http.Request) <span class="cov0" title="0">{
        if rcv := recover(); rcv != nil </span><span class="cov0" title="0">{
                if hz.log != nil </span><span class="cov0" title="0">{
                        hz.log.Fatalf("%v", rcv)
                }</span>

                <span class="cov0" title="0">http.Error(w, fmt.Sprintf("%v", rcv), http.StatusInternalServerError)
                return</span>
        }
}

func (hz *Healthz) healthzHandler(w ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        if hz.app.Running() </span><span class="cov8" title="1">{
                w.WriteHeader(http.StatusOK)
                w.Header().Set(HeaderContentType, ContentTypeText)
                fmt.Fprintf(w, "OK!\n")
                return
        }</span>

        <span class="cov0" title="0">w.WriteHeader(http.StatusInternalServerError)
        w.Header().Set(HeaderContentType, ContentTypeText)
        fmt.Fprintf(w, "Failure!\n")
        return</span>
}

// /varz
// writes out the current stats
func (hz *Healthz) varzHandler(w ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        hz.varsLock.Lock()
        defer hz.varsLock.Unlock()

        keys := make([]string, len(hz.vars))

        var index int
        for key := range hz.vars </span><span class="cov0" title="0">{
                keys[index] = key
                index++
        }</span>

        <span class="cov0" title="0">sort.Strings(keys)

        w.WriteHeader(http.StatusOK)
        w.Header().Set(HeaderContentType, ContentTypeText)
        for _, key := range keys </span><span class="cov0" title="0">{
                fmt.Fprintf(w, "%s: %v\n", key, hz.vars[key])
        }</span>
}

func (hz *Healthz) appWebRequestListener(wre *logger.WebRequestEvent) <span class="cov0" title="0">{
        hz.varsLock.Lock()
        defer hz.varsLock.Unlock()

        hz.incrementVarUnsafe(VarzRequests)
        if wre.StatusCode() &gt;= http.StatusInternalServerError </span><span class="cov0" title="0">{
                hz.incrementVarUnsafe(VarzRequests5xx)
        }</span> else<span class="cov0" title="0"> if wre.StatusCode() &gt;= http.StatusBadRequest </span><span class="cov0" title="0">{
                hz.incrementVarUnsafe(VarzRequests4xx)
        }</span> else<span class="cov0" title="0"> if wre.StatusCode() &gt;= http.StatusMultipleChoices </span><span class="cov0" title="0">{
                hz.incrementVarUnsafe(VarzRequests3xx)
        }</span> else<span class="cov0" title="0"> {
                hz.incrementVarUnsafe(VarzRequests2xx)
        }</span>
}

func (hz *Healthz) appErrorListener(e *logger.ErrorEvent) <span class="cov0" title="0">{
        hz.varsLock.Lock()
        defer hz.varsLock.Unlock()

        switch e.Flag() </span>{
        case logger.Error:<span class="cov0" title="0">
                hz.incrementVarUnsafe(VarzErrors)
                return</span>
        case logger.Fatal:<span class="cov0" title="0">
                hz.incrementVarUnsafe(VarzFatals)
                return</span>
        }
}

func (hz *Healthz) incrementVarUnsafe(key string) <span class="cov0" title="0">{
        if value, hasValue := hz.vars[key]; hasValue </span><span class="cov0" title="0">{
                if typed, isTyped := value.(int64); isTyped </span><span class="cov0" title="0">{
                        hz.vars[key] = typed + 1
                }</span>
        } else<span class="cov0" title="0"> {
                hz.vars[key] = int64(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file139" style="display: none">package web

import (
        "fmt"
        "time"

        "github.com/blend/go-sdk/env"
        "github.com/blend/go-sdk/util"
)

// NewHealthzConfigFromEnv returns a new config from the environment.
func NewHealthzConfigFromEnv() *HealthzConfig <span class="cov0" title="0">{
        var cfg HealthzConfig
        if err := env.Env().ReadInto(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return &amp;cfg</span>
}

// HealthzConfig is an object used to set up a healthz sidecar.
type HealthzConfig struct {
        Port     int32  `json:"port" yaml:"port" env:"HEALTHZ_PORT"`
        BindAddr string `json:"bindAddr" yaml:"bindAddr" env:"HEALTHZ_BIND_ADDR"`

        // DefaultHeaders are included on any responses. The app ships with a set of default headers, which you can augment with this property.
        DefaultHeaders map[string]string `json:"defaultHeaders" yaml:"defaultHeaders"`

        RecoverPanics     *bool         `json:"recoverPanics" yaml:"recoverPanics"`
        MaxHeaderBytes    int           `json:"maxHeaderBytes" yaml:"maxHeaderBytes" env:"HEALTHZ_MAX_HEADER_BYTES"`
        ReadTimeout       time.Duration `json:"readTimeout" yaml:"readTimeout" env:"HEALTHZ_READ_HEADER_TIMEOUT"`
        ReadHeaderTimeout time.Duration `json:"readHeaderTimeout" yaml:"readHeaderTimeout" env:"HEALTHZ_READ_HEADER_TIMEOUT"`
        WriteTimeout      time.Duration `json:"writeTimeout" yaml:"writeTimeout" env:"HEALTHZ_WRITE_TIMEOUT"`
        IdleTimeout       time.Duration `json:"idleTimeout" yaml:"idleTimeout" env:"HEALTHZ_IDLE_TIMEOUT"`
}

// GetBindAddr util.Coalesces the bind addr, the port, or the default.
func (hc HealthzConfig) GetBindAddr(defaults ...string) string <span class="cov0" title="0">{
        if len(hc.BindAddr) &gt; 0 </span><span class="cov0" title="0">{
                return hc.BindAddr
        }</span>
        <span class="cov0" title="0">if hc.Port &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf(":%d", hc.Port)
        }</span>
        <span class="cov0" title="0">if len(defaults) &gt; 0 </span><span class="cov0" title="0">{
                return defaults[0]
        }</span>
        <span class="cov0" title="0">return DefaultHealthzBindAddr</span>
}

// GetPort returns the int32 port for a given config.
// This is useful in things like kubernetes pod templates.
// If the config .Port is unset, it will parse the .BindAddr,
// or the DefaultBindAddr for the port number.
func (hc HealthzConfig) GetPort(defaults ...int32) int32 <span class="cov0" title="0">{
        if hc.Port &gt; 0 </span><span class="cov0" title="0">{
                return hc.Port
        }</span>
        <span class="cov0" title="0">if len(hc.BindAddr) &gt; 0 </span><span class="cov0" title="0">{
                return PortFromBindAddr(hc.BindAddr)
        }</span>
        <span class="cov0" title="0">return PortFromBindAddr(DefaultHealthzBindAddr)</span>
}

// GetRecoverPanics returns if we should recover panics or not.
func (hc HealthzConfig) GetRecoverPanics(defaults ...bool) bool <span class="cov0" title="0">{
        return util.Coalesce.Bool(hc.RecoverPanics, DefaultRecoverPanics, defaults...)
}</span>

// GetMaxHeaderBytes returns the maximum header size in bytes or a default.
func (hc HealthzConfig) GetMaxHeaderBytes(defaults ...int) int <span class="cov0" title="0">{
        return util.Coalesce.Int(hc.MaxHeaderBytes, DefaultMaxHeaderBytes, defaults...)
}</span>

// GetReadTimeout gets a property.
func (hc HealthzConfig) GetReadTimeout(defaults ...time.Duration) time.Duration <span class="cov0" title="0">{
        return util.Coalesce.Duration(hc.ReadTimeout, DefaultReadTimeout, defaults...)
}</span>

// GetReadHeaderTimeout gets a property.
func (hc HealthzConfig) GetReadHeaderTimeout(defaults ...time.Duration) time.Duration <span class="cov0" title="0">{
        return util.Coalesce.Duration(hc.ReadHeaderTimeout, DefaultReadHeaderTimeout, defaults...)
}</span>

// GetWriteTimeout gets a property.
func (hc HealthzConfig) GetWriteTimeout(defaults ...time.Duration) time.Duration <span class="cov0" title="0">{
        return util.Coalesce.Duration(hc.WriteTimeout, DefaultWriteTimeout, defaults...)
}</span>

// GetIdleTimeout gets a property.
func (hc HealthzConfig) GetIdleTimeout(defaults ...time.Duration) time.Duration <span class="cov0" title="0">{
        return util.Coalesce.Duration(hc.IdleTimeout, DefaultIdleTimeout, defaults...)
}</span>
</pre>
		
		<pre class="file" id="file140" style="display: none">package web

import (
        "context"
        "fmt"
        "net/http"
        "time"

        "github.com/blend/go-sdk/env"
        "github.com/blend/go-sdk/exception"
        "github.com/blend/go-sdk/logger"
)

// NewHTTPSUpgrader returns a new HTTPSUpgrader which redirects HTTP to HTTPS
func NewHTTPSUpgrader() *HTTPSUpgrader <span class="cov8" title="1">{
        return &amp;HTTPSUpgrader{}
}</span>

// NewHTTPSUpgraderFromEnv returns a new https upgrader from enviroment variables.
func NewHTTPSUpgraderFromEnv() *HTTPSUpgrader <span class="cov0" title="0">{
        return NewHTTPSUpgraderFromConfig(NewHTTPSUpgraderConfigFromEnv())
}</span>

// NewHTTPSUpgraderFromConfig creates a new https upgrader from a config.
func NewHTTPSUpgraderFromConfig(cfg *HTTPSUpgraderConfig) *HTTPSUpgrader <span class="cov0" title="0">{
        return &amp;HTTPSUpgrader{
                bindAddr:          cfg.GetBindAddr(),
                maxHeaderBytes:    cfg.GetMaxHeaderBytes(),
                readTimeout:       cfg.GetReadTimeout(),
                readHeaderTimeout: cfg.GetReadHeaderTimeout(),
                writeTimeout:      cfg.GetWriteTimeout(),
                idleTimeout:       cfg.GetIdleTimeout(),
        }
}</span>

// HTTPSUpgrader redirects HTTP to HTTPS
type HTTPSUpgrader struct {
        bindAddr string

        server *http.Server

        maxHeaderBytes    int
        readTimeout       time.Duration
        readHeaderTimeout time.Duration
        writeTimeout      time.Duration
        idleTimeout       time.Duration

        err error
        log *logger.Logger
}

// WithBindAddr sets the address the app listens on, and returns a reference to the app.
func (hu *HTTPSUpgrader) WithBindAddr(bindAddr string) *HTTPSUpgrader <span class="cov0" title="0">{
        hu.bindAddr = bindAddr
        return hu
}</span>

// WithBindAddrFromEnv sets the address the app listens on, and returns a reference to the app.
func (hu *HTTPSUpgrader) WithBindAddrFromEnv() *HTTPSUpgrader <span class="cov0" title="0">{
        hu.bindAddr = env.Env().String(EnvironmentVariableBindAddr)
        return hu
}</span>

// BindAddr returns the address the server will bind to.
func (hu *HTTPSUpgrader) BindAddr() string <span class="cov0" title="0">{
        return hu.bindAddr
}</span>

// WithPort sets the port for the bind address of the app, and returns a reference to the app.
func (hu *HTTPSUpgrader) WithPort(port int32) *HTTPSUpgrader <span class="cov0" title="0">{
        hu.SetPort(port)
        return hu
}</span>

// SetPort sets the port the app listens on, typically to `:%d` which indicates listen on any interface.
func (hu *HTTPSUpgrader) SetPort(port int32) <span class="cov0" title="0">{
        hu.bindAddr = fmt.Sprintf(":%v", port)
}</span>

// WithPortFromEnv sets the port from an environment variable, and returns a reference to the app.
func (hu *HTTPSUpgrader) WithPortFromEnv() *HTTPSUpgrader <span class="cov0" title="0">{
        hu.SetPortFromEnv()
        return hu
}</span>

// SetPortFromEnv sets the port from an environment variable, and returns a reference to the app.
func (hu *HTTPSUpgrader) SetPortFromEnv() <span class="cov0" title="0">{
        if env.Env().Has(EnvironmentVariablePort) </span><span class="cov0" title="0">{
                port, err := env.Env().Int32(EnvironmentVariablePort)
                if err != nil </span><span class="cov0" title="0">{
                        hu.err = err
                }</span>
                <span class="cov0" title="0">hu.bindAddr = fmt.Sprintf(":%v", port)</span>
        }
}

// WithLogger sets the underlying logger.
func (hu *HTTPSUpgrader) WithLogger(log *logger.Logger) *HTTPSUpgrader <span class="cov0" title="0">{
        hu.log = log
        return hu
}</span>

// Logger returns the underlying logger.
func (hu *HTTPSUpgrader) Logger() *logger.Logger <span class="cov0" title="0">{
        return hu.log
}</span>

// MaxHeaderBytes returns the app max header bytes.
func (hu *HTTPSUpgrader) MaxHeaderBytes() int <span class="cov0" title="0">{
        return hu.maxHeaderBytes
}</span>

// WithMaxHeaderBytes sets the max header bytes value and returns a reference.
func (hu *HTTPSUpgrader) WithMaxHeaderBytes(byteCount int) *HTTPSUpgrader <span class="cov0" title="0">{
        hu.maxHeaderBytes = byteCount
        return hu
}</span>

// ReadHeaderTimeout returns the read header timeout for the server.
func (hu *HTTPSUpgrader) ReadHeaderTimeout() time.Duration <span class="cov0" title="0">{
        return hu.readHeaderTimeout
}</span>

// WithReadHeaderTimeout returns the read header timeout for the server.
func (hu *HTTPSUpgrader) WithReadHeaderTimeout(timeout time.Duration) *HTTPSUpgrader <span class="cov0" title="0">{
        hu.readHeaderTimeout = timeout
        return hu
}</span>

// ReadTimeout returns the read timeout for the server.
func (hu *HTTPSUpgrader) ReadTimeout() time.Duration <span class="cov0" title="0">{
        return hu.readTimeout
}</span>

// WithReadTimeout sets the read timeout for the server and returns a reference to the app for building apps with a fluent api.
func (hu *HTTPSUpgrader) WithReadTimeout(timeout time.Duration) *HTTPSUpgrader <span class="cov0" title="0">{
        hu.readTimeout = timeout
        return hu
}</span>

// IdleTimeout is the time before we close a connection.
func (hu *HTTPSUpgrader) IdleTimeout() time.Duration <span class="cov0" title="0">{
        return hu.idleTimeout
}</span>

// WithIdleTimeout sets the idle timeout.
func (hu *HTTPSUpgrader) WithIdleTimeout(timeout time.Duration) *HTTPSUpgrader <span class="cov0" title="0">{
        hu.idleTimeout = timeout
        return hu
}</span>

// WriteTimeout returns the write timeout for the server.
func (hu *HTTPSUpgrader) WriteTimeout() time.Duration <span class="cov0" title="0">{
        return hu.writeTimeout
}</span>

// WithWriteTimeout sets the write timeout for the server and returns a reference to the app for building apps with a fluent api.
func (hu *HTTPSUpgrader) WithWriteTimeout(timeout time.Duration) *HTTPSUpgrader <span class="cov0" title="0">{
        hu.writeTimeout = timeout
        return hu
}</span>

// Server returns the basic http.Server for the app.
func (hu *HTTPSUpgrader) Server() *http.Server <span class="cov0" title="0">{
        return &amp;http.Server{
                Addr:              hu.BindAddr(),
                Handler:           hu,
                MaxHeaderBytes:    hu.maxHeaderBytes,
                ReadTimeout:       hu.readTimeout,
                ReadHeaderTimeout: hu.readHeaderTimeout,
                WriteTimeout:      hu.writeTimeout,
                IdleTimeout:       hu.idleTimeout,
        }
}</span>

// ServeHTTP redirects HTTP to HTTPS
func (hu *HTTPSUpgrader) ServeHTTP(rw http.ResponseWriter, req *http.Request) <span class="cov8" title="1">{
        start := time.Now()
        response := []byte("Upgrade Required")
        if hu.log != nil </span><span class="cov0" title="0">{
                defer hu.log.Trigger(logger.NewWebRequestEvent(req).
                        WithStatusCode(http.StatusMovedPermanently).
                        WithContentLength(int64(len(response))).
                        WithContentType(ContentTypeText).
                        WithElapsed(time.Since(start)))
        }</span>

        <span class="cov8" title="1">newURL := *req.URL
        newURL.Scheme = SchemeHTTPS
        if len(newURL.Host) == 0 </span><span class="cov8" title="1">{
                newURL.Host = req.Host
        }</span>

        <span class="cov8" title="1">http.Redirect(rw, req, newURL.String(), http.StatusMovedPermanently)</span>
}

// Start starts the server and binds to the given address.
func (hu *HTTPSUpgrader) Start() error <span class="cov0" title="0">{
        return hu.StartWithServer(hu.Server())
}</span>

// StartWithServer starts the app on a custom server.
// This lets you configure things like TLS keys and
// other options.
func (hu *HTTPSUpgrader) StartWithServer(server *http.Server) (err error) <span class="cov0" title="0">{
        // early exit if we already had an issue.
        if hu.err != nil </span><span class="cov0" title="0">{
                err = hu.err
                return
        }</span>
        <span class="cov0" title="0">hu.log.SyncInfof("https upgrade server started, listening on %s", server.Addr)
        hu.server = server
        err = exception.Wrap(server.ListenAndServe())
        return</span>
}

// Shutdown stops the server.
func (hu *HTTPSUpgrader) Shutdown() error <span class="cov0" title="0">{
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        hu.log.SyncInfof("https upgrade server shutting down")
        hu.server.SetKeepAlivesEnabled(false)
        return exception.Wrap(hu.server.Shutdown(ctx))
}</span>
</pre>
		
		<pre class="file" id="file141" style="display: none">package web

import (
        "fmt"
        "time"

        "github.com/blend/go-sdk/env"
        "github.com/blend/go-sdk/util"
)

// NewHTTPSUpgraderConfigFromEnv returns an https upgrader config populated from the environment.
func NewHTTPSUpgraderConfigFromEnv() *HTTPSUpgraderConfig <span class="cov0" title="0">{
        var cfg HTTPSUpgraderConfig
        if err := env.Env().ReadInto(&amp;cfg); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return &amp;cfg</span>
}

// HTTPSUpgraderConfig is the config for the https upgrader server.
type HTTPSUpgraderConfig struct {
        Port     int32  `json:"port" yaml:"port" env:"UPGRADE_PORT"`
        BindAddr string `json:"bindAddr" yaml:"bindAddr" env:"UPGRADE_BIND_ADDR"`

        MaxHeaderBytes    int           `json:"maxHeaderBytes" yaml:"maxHeaderBytes" env:"MAX_HEADER_BYTES"`
        ReadTimeout       time.Duration `json:"readTimeout" yaml:"readTimeout" env:"READ_HEADER_TIMEOUT"`
        ReadHeaderTimeout time.Duration `json:"readHeaderTimeout" yaml:"readHeaderTimeout" env:"READ_HEADER_TIMEOUT"`
        WriteTimeout      time.Duration `json:"writeTimeout" yaml:"writeTimeout" env:"WRITE_TIMEOUT"`
        IdleTimeout       time.Duration `json:"idleTimeout" yaml:"idleTimeout" env:"IDLE_TIMEOUT"`
}

// GetBindAddr coalesces the bind addr, the port, or the default.
func (c HTTPSUpgraderConfig) GetBindAddr(defaults ...string) string <span class="cov0" title="0">{
        if len(c.BindAddr) &gt; 0 </span><span class="cov0" title="0">{
                return c.BindAddr
        }</span>
        <span class="cov0" title="0">if c.Port &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Sprintf(":%d", c.Port)
        }</span>
        <span class="cov0" title="0">if len(defaults) &gt; 0 </span><span class="cov0" title="0">{
                return defaults[0]
        }</span>
        <span class="cov0" title="0">return DefaultBindAddr</span>
}

// GetPort returns the int32 port for a given config.
// This is useful in things like kubernetes pod templates.
// If the config .Port is unset, it will parse the .BindAddr,
// or the DefaultBindAddr for the port number.
func (c HTTPSUpgraderConfig) GetPort(defaults ...int32) int32 <span class="cov0" title="0">{
        if c.Port &gt; 0 </span><span class="cov0" title="0">{
                return c.Port
        }</span>
        <span class="cov0" title="0">if len(c.BindAddr) &gt; 0 </span><span class="cov0" title="0">{
                return PortFromBindAddr(c.BindAddr)
        }</span>
        <span class="cov0" title="0">return PortFromBindAddr(DefaultBindAddr)</span>
}

// GetMaxHeaderBytes returns the maximum header size in bytes or a default.
func (c HTTPSUpgraderConfig) GetMaxHeaderBytes(defaults ...int) int <span class="cov0" title="0">{
        return util.Coalesce.Int(c.MaxHeaderBytes, DefaultMaxHeaderBytes, defaults...)
}</span>

// GetReadTimeout gets a property.
func (c HTTPSUpgraderConfig) GetReadTimeout(defaults ...time.Duration) time.Duration <span class="cov0" title="0">{
        return util.Coalesce.Duration(c.ReadTimeout, DefaultReadTimeout, defaults...)
}</span>

// GetReadHeaderTimeout gets a property.
func (c HTTPSUpgraderConfig) GetReadHeaderTimeout(defaults ...time.Duration) time.Duration <span class="cov0" title="0">{
        return util.Coalesce.Duration(c.ReadHeaderTimeout, DefaultReadHeaderTimeout, defaults...)
}</span>

// GetWriteTimeout gets a property.
func (c HTTPSUpgraderConfig) GetWriteTimeout(defaults ...time.Duration) time.Duration <span class="cov0" title="0">{
        return util.Coalesce.Duration(c.WriteTimeout, DefaultWriteTimeout, defaults...)
}</span>

// GetIdleTimeout gets a property.
func (c HTTPSUpgraderConfig) GetIdleTimeout(defaults ...time.Duration) time.Duration <span class="cov0" title="0">{
        return util.Coalesce.Duration(c.IdleTimeout, DefaultIdleTimeout, defaults...)
}</span>
</pre>
		
		<pre class="file" id="file142" style="display: none">package web

// JSONResult is a json result.
type JSONResult struct {
        StatusCode int
        Response   interface{}
}

// Render renders the result
func (ar *JSONResult) Render(ctx *Ctx) error <span class="cov8" title="1">{
        return WriteJSON(ctx.Response(), ctx.Request(), ar.StatusCode, ar.Response)
}</span>
</pre>
		
		<pre class="file" id="file143" style="display: none">package web

import (
        "net/http"

        "github.com/blend/go-sdk/logger"
)

// NewJSONResultProvider Creates a new JSONResults object.
func NewJSONResultProvider(log *logger.Logger) *JSONResultProvider <span class="cov0" title="0">{
        return &amp;JSONResultProvider{log: log}
}</span>

// JSONResultProvider are context results for api methods.
type JSONResultProvider struct {
        log *logger.Logger
}

// NotFound returns a service response.
func (jrp *JSONResultProvider) NotFound() Result <span class="cov8" title="1">{
        return &amp;JSONResult{
                StatusCode: http.StatusNotFound,
                Response:   "Not Found",
        }
}</span>

// NotAuthorized returns a service response.
func (jrp *JSONResultProvider) NotAuthorized() Result <span class="cov0" title="0">{
        return &amp;JSONResult{
                StatusCode: http.StatusForbidden,
                Response:   "Not Authorized",
        }
}</span>

// InternalError returns a service response.
func (jrp *JSONResultProvider) InternalError(err error) Result <span class="cov0" title="0">{
        if jrp.log != nil </span><span class="cov0" title="0">{
                jrp.log.Fatal(err)
        }</span>

        <span class="cov0" title="0">return &amp;JSONResult{
                StatusCode: http.StatusInternalServerError,
                Response:   err.Error(),
        }</span>
}

// BadRequest returns a service response.
func (jrp *JSONResultProvider) BadRequest(err error) Result <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                return &amp;JSONResult{
                        StatusCode: http.StatusBadRequest,
                        Response:   err,
                }
        }</span>
        <span class="cov0" title="0">return &amp;JSONResult{
                StatusCode: http.StatusBadRequest,
                Response:   "Bad Request",
        }</span>
}

// OK returns a service response.
func (jrp *JSONResultProvider) OK() Result <span class="cov0" title="0">{
        return &amp;JSONResult{
                StatusCode: http.StatusOK,
                Response:   "OK!",
        }
}</span>

// Result returns a json response.
func (jrp *JSONResultProvider) Result(response interface{}) Result <span class="cov8" title="1">{
        return &amp;JSONResult{
                StatusCode: http.StatusOK,
                Response:   response,
        }
}</span>
</pre>
		
		<pre class="file" id="file144" style="display: none">package web

import (
        "context"
        "time"
)

// Cancel injects the context for a given action with a cancel func.
func Cancel(action Action) Action <span class="cov0" title="0">{
        return func(ctx *Ctx) Result </span><span class="cov0" title="0">{
                ctx.ctx, ctx.cancel = context.WithCancel(context.Background())
                return action(ctx)
        }</span>
}

// Timeout injects the context for a given action with a timeout context.
func Timeout(d time.Duration) Middleware <span class="cov0" title="0">{
        return func(action Action) Action </span><span class="cov0" title="0">{
                return func(ctx *Ctx) Result </span><span class="cov0" title="0">{
                        ctx.ctx, ctx.cancel = context.WithTimeout(context.Background(), d)
                        return action(ctx)
                }</span>
        }
}

// ViewProviderAsDefault sets the context.DefaultResultProvider() equal to context.View().
func ViewProviderAsDefault(action Action) Action <span class="cov8" title="1">{
        return func(ctx *Ctx) Result </span><span class="cov8" title="1">{
                return action(ctx.WithDefaultResultProvider(ctx.View()))
        }</span>
}

// JSONProviderAsDefault sets the context.DefaultResultProvider() equal to context.JSON().
func JSONProviderAsDefault(action Action) Action <span class="cov8" title="1">{
        return func(ctx *Ctx) Result </span><span class="cov8" title="1">{
                return action(ctx.WithDefaultResultProvider(ctx.JSON()))
        }</span>
}

// XMLProviderAsDefault sets the context.DefaultResultProvider() equal to context.XML().
func XMLProviderAsDefault(action Action) Action <span class="cov0" title="0">{
        return func(ctx *Ctx) Result </span><span class="cov0" title="0">{
                return action(ctx.WithDefaultResultProvider(ctx.XML()))
        }</span>
}

// TextProviderAsDefault sets the context.DefaultResultProvider() equal to context.Text().
func TextProviderAsDefault(action Action) Action <span class="cov0" title="0">{
        return func(ctx *Ctx) Result </span><span class="cov0" title="0">{
                return action(ctx.WithDefaultResultProvider(ctx.Text()))
        }</span>
}
</pre>
		
		<pre class="file" id="file145" style="display: none">package web

import (
        "bytes"
        "database/sql"
        "encoding/json"
        "encoding/xml"
        "fmt"
        "io"
        "io/ioutil"
        "mime/multipart"
        "net/http"
        "net/url"
        "strings"
        "time"

        "github.com/blend/go-sdk/exception"
)

// NewMockRequestBuilder returns a new mock request builder for a given app.
func NewMockRequestBuilder(app *App) *MockRequestBuilder <span class="cov8" title="1">{
        return &amp;MockRequestBuilder{
                app:         app,
                verb:        "GET",
                queryString: url.Values{},
                formValues:  url.Values{},
                headers:     http.Header{},
                state:       State{},
        }
}</span>

// MockRequestBuilder facilitates creating mock requests.
type MockRequestBuilder struct {
        app *App

        verb        string
        path        string
        queryString url.Values
        formValues  url.Values
        headers     http.Header
        cookies     []*http.Cookie
        postBody    []byte

        postedFiles map[string]PostedFile

        err error

        state State
}

// Get is a shortcut for WithVerb("GET") WithPathf(pathFormat, args...)
func (mrb *MockRequestBuilder) Get(pathFormat string, args ...interface{}) *MockRequestBuilder <span class="cov8" title="1">{
        return mrb.WithVerb("GET").WithPathf(pathFormat, args...)
}</span>

// Post is a shortcut for WithVerb("POST") WithPathf(pathFormat, args...)
func (mrb *MockRequestBuilder) Post(pathFormat string, args ...interface{}) *MockRequestBuilder <span class="cov0" title="0">{
        return mrb.WithVerb("POST").WithPathf(pathFormat, args...)
}</span>

// Put is a shortcut for WithVerb("PUT") WithPathf(pathFormat, args...)
func (mrb *MockRequestBuilder) Put(pathFormat string, args ...interface{}) *MockRequestBuilder <span class="cov0" title="0">{
        return mrb.WithVerb("PUT").WithPathf(pathFormat, args...)
}</span>

// Patch is a shortcut for WithVerb("PATCH") WithPathf(pathFormat, args...)
func (mrb *MockRequestBuilder) Patch(pathFormat string, args ...interface{}) *MockRequestBuilder <span class="cov0" title="0">{
        return mrb.WithVerb("PATCH").WithPathf(pathFormat, args...)
}</span>

// Delete is a shortcut for WithVerb("DELETE") WithPathf(pathFormat, args...)
func (mrb *MockRequestBuilder) Delete(pathFormat string, args ...interface{}) *MockRequestBuilder <span class="cov0" title="0">{
        return mrb.WithVerb("DELETE").WithPathf(pathFormat, args...)
}</span>

// WithVerb sets the verb for the request.
func (mrb *MockRequestBuilder) WithVerb(verb string) *MockRequestBuilder <span class="cov8" title="1">{
        mrb.verb = strings.ToUpper(verb)
        return mrb
}</span>

// WithPathf sets the path for the request.
func (mrb *MockRequestBuilder) WithPathf(pathFormat string, args ...interface{}) *MockRequestBuilder <span class="cov8" title="1">{
        mrb.path = fmt.Sprintf(pathFormat, args...)

        // url.Parse always includes the '/' path prefix.
        if !strings.HasPrefix(mrb.path, "/") </span><span class="cov0" title="0">{
                mrb.path = fmt.Sprintf("/%s", mrb.path)
        }</span>

        <span class="cov8" title="1">return mrb</span>
}

// WithQueryString adds a querystring param for the request.
func (mrb *MockRequestBuilder) WithQueryString(key, value string) *MockRequestBuilder <span class="cov8" title="1">{
        mrb.queryString.Add(key, value)
        return mrb
}</span>

// WithFormValue adds a form value for the request.
func (mrb *MockRequestBuilder) WithFormValue(key, value string) *MockRequestBuilder <span class="cov8" title="1">{
        mrb.formValues.Add(key, value)
        return mrb
}</span>

// WithHeader adds a header for the request.
func (mrb *MockRequestBuilder) WithHeader(key, value string) *MockRequestBuilder <span class="cov8" title="1">{
        mrb.headers.Add(key, value)
        return mrb
}</span>

// WithCookie adds a cookie for the request.
func (mrb *MockRequestBuilder) WithCookie(cookie *http.Cookie) *MockRequestBuilder <span class="cov8" title="1">{
        mrb.cookies = append(mrb.cookies, cookie)
        return mrb
}</span>

// WithCookieValue adds a basic name+value cookie for the request.
func (mrb *MockRequestBuilder) WithCookieValue(name, value string) *MockRequestBuilder <span class="cov8" title="1">{
        mrb.cookies = append(mrb.cookies, NewBasicCookie(name, value))
        return mrb
}</span>

// WithPostBody sets the post body for the request.
func (mrb *MockRequestBuilder) WithPostBody(postBody []byte) *MockRequestBuilder <span class="cov8" title="1">{
        mrb.postBody = postBody
        return mrb
}</span>

// WithPostBodyAsJSON sets the post body for the request by serializing an object to JSON.
func (mrb *MockRequestBuilder) WithPostBodyAsJSON(object interface{}) *MockRequestBuilder <span class="cov0" title="0">{
        bytes, _ := json.Marshal(object)
        mrb.postBody = bytes
        return mrb
}</span>

// WithPostedFile includes a file as a post parameter.
func (mrb *MockRequestBuilder) WithPostedFile(postedFile PostedFile) *MockRequestBuilder <span class="cov8" title="1">{
        if mrb.postedFiles == nil </span><span class="cov8" title="1">{
                mrb.postedFiles = map[string]PostedFile{}
        }</span>
        <span class="cov8" title="1">mrb.postedFiles[postedFile.Key] = postedFile
        return mrb</span>
}

// WithTx sets the transaction for the request.
func (mrb *MockRequestBuilder) WithTx(tx *sql.Tx, keys ...string) *MockRequestBuilder <span class="cov8" title="1">{
        WithTx(mrb, tx, keys...)
        return mrb
}</span>

// State returns the underlying state.
func (mrb *MockRequestBuilder) State() State <span class="cov8" title="1">{
        return mrb.state
}</span>

// WithStateValue sets the state for a key to an object.
func (mrb *MockRequestBuilder) WithStateValue(key string, value interface{}) *MockRequestBuilder <span class="cov8" title="1">{
        if mrb.state == nil </span><span class="cov0" title="0">{
                mrb.state = State{}
        }</span>
        <span class="cov8" title="1">mrb.state[key] = value
        return mrb</span>
}

// GetStateValue returns an object in the state cache.
func (mrb *MockRequestBuilder) GetStateValue(key string) interface{} <span class="cov0" title="0">{
        if mrb.state == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">if item, hasItem := mrb.state[key]; hasItem </span><span class="cov0" title="0">{
                return item
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Request returns the mock request builder settings as an http.Request.
func (mrb *MockRequestBuilder) Request() (*http.Request, error) <span class="cov8" title="1">{
        req := &amp;http.Request{}

        reqURL, err := url.Parse(fmt.Sprintf("http://localhost%s", mrb.path))

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">reqURL.RawQuery = mrb.queryString.Encode()
        req.Method = mrb.verb
        req.URL = reqURL
        req.RequestURI = reqURL.String()
        req.Form = mrb.formValues
        req.Header = http.Header{}

        for key, values := range mrb.headers </span><span class="cov8" title="1">{
                for _, value := range values </span><span class="cov8" title="1">{
                        req.Header.Add(key, value)
                }</span>
        }

        <span class="cov8" title="1">for _, cookie := range mrb.cookies </span><span class="cov8" title="1">{
                req.AddCookie(cookie)
        }</span>

        <span class="cov8" title="1">if len(mrb.postedFiles) &gt; 0 </span><span class="cov8" title="1">{
                b := bytes.NewBuffer(nil)
                w := multipart.NewWriter(b)
                for _, file := range mrb.postedFiles </span><span class="cov8" title="1">{
                        fw, err := w.CreateFormFile(file.Key, file.FileName)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">_, err = io.Copy(fw, bytes.NewBuffer(file.Contents))
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
                // Don't forget to set the content type, this will contain the boundary.
                <span class="cov8" title="1">req.Header.Set("Content-Type", w.FormDataContentType())

                err = w.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">req.Body = ioutil.NopCloser(b)</span>
        } else<span class="cov8" title="1"> if len(mrb.postBody) &gt; 0 </span><span class="cov8" title="1">{
                req.Body = ioutil.NopCloser(bytes.NewBuffer(mrb.postBody))
        }</span>

        <span class="cov8" title="1">return req, nil</span>
}

// LookupRoute returns the corresponding route for the mocked request.
func (mrb *MockRequestBuilder) LookupRoute() (route *Route, params RouteParameters) <span class="cov8" title="1">{
        var tsr bool
        path := mrb.path
        route, params, tsr = mrb.app.Lookup(mrb.verb, path)
        if tsr </span><span class="cov0" title="0">{
                path = path + "/"
                route, params, tsr = mrb.app.Lookup(mrb.verb, path)
        }</span>
        <span class="cov8" title="1">return</span>
}

// CreateCtx returns the mock request as a request context.
func (mrb *MockRequestBuilder) CreateCtx(p RouteParameters) (*Ctx, error) <span class="cov8" title="1">{
        r, err := mrb.Request()

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">w := NewMockResponseWriter(bytes.NewBuffer(nil))
        if mrb.app == nil </span><span class="cov8" title="1">{
                return NewCtx(w, r, p, mrb.state), nil
        }</span>

        <span class="cov8" title="1">var rc *Ctx
        route, _ := mrb.LookupRoute()
        if route != nil </span><span class="cov0" title="0">{
                rc = mrb.app.createCtx(w, r, route, p, mrb.state)
        }</span> else<span class="cov8" title="1"> {
                rc = mrb.app.createCtx(w, r, nil, nil, mrb.state)
        }</span>

        <span class="cov8" title="1">return rc, nil</span>
}

// Response runs the mock request.
func (mrb *MockRequestBuilder) Response() (res *http.Response, err error) <span class="cov8" title="1">{
        if mrb.err != nil </span><span class="cov0" title="0">{
                err = mrb.err
                return
        }</span>

        <span class="cov8" title="1">req, err := mrb.Request()
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">var route *Route
        var params RouteParameters
        route, params = mrb.LookupRoute()
        if route == nil &amp;&amp; mrb.app.notFoundHandler != nil </span><span class="cov8" title="1">{
                res = mrb.runHandler(mrb.app.notFoundHandler, req, route, params)
                return
        }</span> else<span class="cov8" title="1"> if route == nil </span><span class="cov0" title="0">{
                err = exception.Newf("No route registered for %s %s", mrb.verb, mrb.path)
                return
        }</span>

        <span class="cov8" title="1">res = mrb.runHandler(route.Handler, req, route, params)
        return</span>
}

func (mrb *MockRequestBuilder) runHandler(handler Handler, req *http.Request, route *Route, params RouteParameters) (res *http.Response) <span class="cov8" title="1">{
        if mrb.app != nil &amp;&amp; mrb.app.recoverPanics &amp;&amp; mrb.app.panicAction != nil </span><span class="cov8" title="1">{
                defer func() </span><span class="cov8" title="1">{
                        if r := recover(); r != nil </span><span class="cov8" title="1">{
                                buffer := bytes.NewBuffer(nil)
                                w := NewMockResponseWriter(buffer)
                                mrb.app.handlePanic(w, req, r)
                                res = mrb.createResponse(buffer, w)
                        }</span>
                }()
        }

        <span class="cov8" title="1">buffer := bytes.NewBuffer(nil)
        w := NewMockResponseWriter(buffer)
        handler(w, req, route, params, mrb.state)
        res = mrb.createResponse(buffer, w)
        return res</span>
}

func (mrb *MockRequestBuilder) createResponse(buffer *bytes.Buffer, w ResponseWriter) *http.Response <span class="cov8" title="1">{
        res := &amp;http.Response{
                Body:          ioutil.NopCloser(bytes.NewBuffer(buffer.Bytes())),
                ContentLength: int64(w.ContentLength()),
                Header:        http.Header{},
                StatusCode:    w.StatusCode(),
                Proto:         "http",
                ProtoMajor:    1,
                ProtoMinor:    1,
        }
        for key, values := range w.Header() </span><span class="cov8" title="1">{
                for _, value := range values </span><span class="cov8" title="1">{
                        res.Header.Add(key, value)
                }</span>
        }
        <span class="cov8" title="1">return res</span>
}

// JSON executes the mock request and reads the response to the given object as json.
func (mrb *MockRequestBuilder) JSON(object interface{}) error <span class="cov8" title="1">{
        res, err := mrb.Response()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer res.Body.Close()
        contents, err := ioutil.ReadAll(res.Body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return json.Unmarshal(contents, object)</span>
}

// JSONWithMeta executes the mock request and reads the response to the given object as json.
func (mrb *MockRequestBuilder) JSONWithMeta(object interface{}) (*ResponseMeta, error) <span class="cov0" title="0">{
        res, err := mrb.Response()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()
        contents, err := ioutil.ReadAll(res.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return NewResponseMeta(res), json.Unmarshal(contents, object)</span>
}

// XML executes the mock request and reads the response to the given object as json.
func (mrb *MockRequestBuilder) XML(object interface{}) error <span class="cov0" title="0">{
        res, err := mrb.Response()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()
        contents, err := ioutil.ReadAll(res.Body)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return xml.Unmarshal(contents, object)</span>
}

// XMLWithMeta executes the mock request and reads the response to the given object as json.
func (mrb *MockRequestBuilder) XMLWithMeta(object interface{}) (*ResponseMeta, error) <span class="cov0" title="0">{
        res, err := mrb.Response()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer res.Body.Close()
        contents, err := ioutil.ReadAll(res.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return NewResponseMeta(res), xml.Unmarshal(contents, object)</span>
}

// Bytes returns the response as bytes.
func (mrb *MockRequestBuilder) Bytes() ([]byte, error) <span class="cov8" title="1">{
        res, err := mrb.Response()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer res.Body.Close()
        return ioutil.ReadAll(res.Body)</span>
}

// BytesWithMeta returns the response as bytes with meta information.
func (mrb *MockRequestBuilder) BytesWithMeta() ([]byte, *ResponseMeta, error) <span class="cov8" title="1">{
        res, err := mrb.Response()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">defer res.Body.Close()
        contents, err := ioutil.ReadAll(res.Body)
        return contents, NewResponseMeta(res), err</span>
}

// Execute just runs the request.
// It internally calls `Bytes()` which fully consumes the response.
func (mrb *MockRequestBuilder) Execute() error <span class="cov8" title="1">{
        _, err := mrb.Bytes()
        return err
}</span>

// ExecuteWithMeta returns basic metadata for a response.
func (mrb *MockRequestBuilder) ExecuteWithMeta() (*ResponseMeta, error) <span class="cov8" title="1">{
        res, err := mrb.Response()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if res.Body != nil </span><span class="cov8" title="1">{
                defer res.Body.Close()
                _, err = ioutil.ReadAll(res.Body)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return NewResponseMeta(res), nil</span>
}

// NewRequestMeta returns a new meta object for a request.
func NewRequestMeta(req *http.Request) *RequestMeta <span class="cov0" title="0">{
        return &amp;RequestMeta{
                Verb:    req.Method,
                URL:     req.URL,
                Headers: req.Header,
        }
}</span>

// NewRequestMetaWithBody returns a new meta object for a request and reads the body.
func NewRequestMetaWithBody(req *http.Request) (*RequestMeta, error) <span class="cov0" title="0">{
        body, err := ioutil.ReadAll(req.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer req.Body.Close()
        return &amp;RequestMeta{
                Verb:    req.Method,
                URL:     req.URL,
                Headers: req.Header,
                Body:    body,
        }, nil</span>
}

// RequestMeta is the metadata for a request.
type RequestMeta struct {
        StartTime time.Time
        Verb      string
        URL       *url.URL
        Headers   http.Header
        Body      []byte
}

// NewResponseMeta creates a new ResponseMeta.
func NewResponseMeta(res *http.Response) *ResponseMeta <span class="cov8" title="1">{
        return &amp;ResponseMeta{
                StatusCode:    res.StatusCode,
                Headers:       res.Header,
                ContentLength: res.ContentLength,
        }
}</span>

// ResponseMeta is a metadata response struct
type ResponseMeta struct {
        StatusCode    int
        ContentLength int64
        Headers       http.Header
}
</pre>
		
		<pre class="file" id="file146" style="display: none">package web

import (
        "bytes"
        "io"
        "net/http"
)

// NewMockResponseWriter returns a mocked response writer.
func NewMockResponseWriter(buffer io.Writer) *MockResponseWriter <span class="cov8" title="1">{
        return &amp;MockResponseWriter{
                innerWriter: buffer,
                contents:    bytes.NewBuffer([]byte{}),
                headers:     http.Header{},
        }
}</span>

// MockResponseWriter is an object that satisfies response writer but uses an internal buffer.
type MockResponseWriter struct {
        innerWriter   io.Writer
        contents      *bytes.Buffer
        statusCode    int
        contentLength int
        headers       http.Header
}

// Write writes data and adds to ContentLength.
func (res *MockResponseWriter) Write(buffer []byte) (int, error) <span class="cov8" title="1">{
        bytesWritten, err := res.innerWriter.Write(buffer)
        res.contentLength += bytesWritten
        defer func() </span><span class="cov8" title="1">{
                res.contents.Write(buffer)
        }</span>()
        <span class="cov8" title="1">return bytesWritten, err</span>
}

// Header returns the response headers.
func (res *MockResponseWriter) Header() http.Header <span class="cov8" title="1">{
        return res.headers
}</span>

// WriteHeader sets the status code.
func (res *MockResponseWriter) WriteHeader(statusCode int) <span class="cov8" title="1">{
        res.statusCode = statusCode
}</span>

// InnerResponse returns the backing httpresponse writer.
func (res *MockResponseWriter) InnerResponse() http.ResponseWriter <span class="cov0" title="0">{
        return res
}</span>

// StatusCode returns the status code.
func (res *MockResponseWriter) StatusCode() int <span class="cov8" title="1">{
        return res.statusCode
}</span>

// ContentLength returns the content length.
func (res *MockResponseWriter) ContentLength() int <span class="cov8" title="1">{
        return res.contentLength
}</span>

// Bytes returns the raw response.
func (res *MockResponseWriter) Bytes() []byte <span class="cov0" title="0">{
        return res.contents.Bytes()
}</span>

// Flush is a no-op.
func (res *MockResponseWriter) Flush() error <span class="cov0" title="0">{
        return nil
}</span>

// Close is a no-op.
func (res *MockResponseWriter) Close() error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file147" style="display: none">package web

import "net/http"

// NoContentResult returns a no content response.
type NoContentResult struct{}

// Render renders a static result.
func (ncr *NoContentResult) Render(ctx *Ctx) error <span class="cov0" title="0">{
        ctx.Response().WriteHeader(http.StatusNoContent)
        _, err := ctx.Response().Write([]byte{})
        return err
}</span>
</pre>
		
		<pre class="file" id="file148" style="display: none">package web

import (
        "github.com/blend/go-sdk/logger"
)

var noContent = &amp;NoContentResult{}

// NoContentResultProvider is a provider that returns `http.StatusNoContent`
// for all responses.
type NoContentResultProvider struct {
        log *logger.Logger
}

// NotFound returns a no content response.
func (ncr *NoContentResultProvider) NotFound() Result <span class="cov0" title="0">{
        return noContent
}</span>

// NotAuthorized returns a no content response.
func (ncr *NoContentResultProvider) NotAuthorized() Result <span class="cov0" title="0">{
        return noContent
}</span>

// InternalError returns a no content response.
func (ncr *NoContentResultProvider) InternalError(err error) Result <span class="cov0" title="0">{
        if ncr.log != nil </span><span class="cov0" title="0">{
                ncr.log.Fatal(err)
        }</span>
        <span class="cov0" title="0">return noContent</span>
}

// BadRequest returns a no content response.
func (ncr *NoContentResultProvider) BadRequest(err error) Result <span class="cov0" title="0">{
        return noContent
}</span>

// Result returns a no content response.
func (ncr *NoContentResultProvider) Result(response interface{}) Result <span class="cov0" title="0">{
        return noContent
}</span>
</pre>
		
		<pre class="file" id="file149" style="display: none">package web

import (
        "net/http"
)

// NewRawResponseWriter creates a new uncompressed response writer.
func NewRawResponseWriter(w http.ResponseWriter) *RawResponseWriter <span class="cov8" title="1">{
        return &amp;RawResponseWriter{
                innerResponse: w,
        }
}</span>

// RawResponseWriter  a better response writer
type RawResponseWriter struct {
        innerResponse http.ResponseWriter
        contentLength int
        statusCode    int
}

// Write writes the data to the response.
func (rw *RawResponseWriter) Write(b []byte) (int, error) <span class="cov8" title="1">{
        written, err := rw.innerResponse.Write(b)
        rw.contentLength += written
        return written, err
}</span>

// Header accesses the response header collection.
func (rw *RawResponseWriter) Header() http.Header <span class="cov8" title="1">{
        return rw.innerResponse.Header()
}</span>

// WriteHeader is actually a terrible name and this writes the status code.
func (rw *RawResponseWriter) WriteHeader(code int) <span class="cov8" title="1">{
        rw.statusCode = code
        rw.innerResponse.WriteHeader(code)
}</span>

// InnerResponse returns the backing writer.
func (rw *RawResponseWriter) InnerResponse() http.ResponseWriter <span class="cov0" title="0">{
        return rw.innerResponse
}</span>

// StatusCode returns the status code.
func (rw *RawResponseWriter) StatusCode() int <span class="cov8" title="1">{
        return rw.statusCode
}</span>

// ContentLength returns the content length
func (rw *RawResponseWriter) ContentLength() int <span class="cov8" title="1">{
        return rw.contentLength
}</span>

// Close disposes of the response writer.
func (rw *RawResponseWriter) Close() error <span class="cov8" title="1">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file150" style="display: none">package web

import "net/http"

// RawResult is for when you just want to dump bytes.
type RawResult struct {
        StatusCode  int
        ContentType string
        Body        []byte
}

// Render renders the result.
func (rr *RawResult) Render(ctx *Ctx) error <span class="cov8" title="1">{
        if len(rr.ContentType) != 0 </span><span class="cov8" title="1">{
                ctx.Response().Header().Set("Content-Type", rr.ContentType)
        }</span>
        <span class="cov8" title="1">if rr.StatusCode == 0 </span><span class="cov8" title="1">{
                ctx.Response().WriteHeader(http.StatusOK)
        }</span> else<span class="cov8" title="1"> {
                ctx.Response().WriteHeader(rr.StatusCode)
        }</span>
        <span class="cov8" title="1">_, err := ctx.Response().Write(rr.Body)
        return err</span>
}
</pre>
		
		<pre class="file" id="file151" style="display: none">package web

import "net/http"

// RedirectResult is a result that should cause the browser to redirect.
type RedirectResult struct {
        Method      string `json:"redirect_method"`
        RedirectURI string `json:"redirect_uri"`
}

// Render writes the result to the response.
func (rr *RedirectResult) Render(ctx *Ctx) error <span class="cov0" title="0">{
        if len(rr.Method) &gt; 0 </span><span class="cov0" title="0">{
                ctx.Request().Method = rr.Method
                http.Redirect(ctx.Response(), ctx.Request(), rr.RedirectURI, http.StatusFound)
        }</span> else<span class="cov0" title="0"> {
                http.Redirect(ctx.Response(), ctx.Request(), rr.RedirectURI, http.StatusTemporaryRedirect)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file152" style="display: none">package web

import "regexp"

// RewriteAction is an action for a rewrite rule.
type RewriteAction func(filePath string, matchedPieces ...string) string

// RewriteRule is a rule for re-writing incoming static urls.
type RewriteRule struct {
        MatchExpression string
        expr            *regexp.Regexp
        Action          RewriteAction
}

// Apply runs the filter, returning a bool if it matched, and the resulting path.
func (rr RewriteRule) Apply(filePath string) (bool, string) <span class="cov8" title="1">{
        if rr.expr.MatchString(filePath) </span><span class="cov8" title="1">{
                pieces := extractSubMatches(rr.expr, filePath)
                return true, rr.Action(filePath, pieces...)
        }</span>

        <span class="cov8" title="1">return false, filePath</span>
}

// ExtractSubMatches returns sub matches for an expr because go's regexp library is weird.
func extractSubMatches(re *regexp.Regexp, corpus string) []string <span class="cov8" title="1">{
        allResults := re.FindAllStringSubmatch(corpus, -1)
        results := []string{}
        for _, resultSet := range allResults </span><span class="cov8" title="1">{
                for _, result := range resultSet </span><span class="cov8" title="1">{
                        results = append(results, result)
                }</span>
        }

        <span class="cov8" title="1">return results</span>
}
</pre>
		
		<pre class="file" id="file153" style="display: none">package web

import (
        "fmt"
        "net/http"
)

// Handler is the most basic route handler.
type Handler func(http.ResponseWriter, *http.Request, *Route, RouteParameters, State)

// WrapHandler wraps an http.Handler as a Handler.
func WrapHandler(handler http.Handler) Handler <span class="cov0" title="0">{
        return func(w http.ResponseWriter, r *http.Request, _ *Route, _ RouteParameters, _ State) </span><span class="cov0" title="0">{
                handler.ServeHTTP(w, r)
        }</span>
}

// PanicHandler is a handler for panics that also takes an error.
type PanicHandler func(http.ResponseWriter, *http.Request, interface{})

// Route is an entry in the route tree.
type Route struct {
        Handler
        Method string
        Path   string
        Params []string
}

// String returns a string representation of the route.
// Namely: Method_Path
func (r Route) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s_%s", r.Method, r.Path)
}</span>
</pre>
		
		<pre class="file" id="file154" style="display: none">package web

// RouteParameters are parameters sourced from parsing the request path (route).
type RouteParameters map[string]string

// Get gets a value for a key.
func (rp RouteParameters) Get(key string) string <span class="cov8" title="1">{
        return rp[key]
}</span>

// Has returns if the collection has a key or not.
func (rp RouteParameters) Has(key string) bool <span class="cov0" title="0">{
        _, ok := rp[key]
        return ok
}</span>

// Set stores a value for a key.
func (rp RouteParameters) Set(key, value string) <span class="cov0" title="0">{
        rp[key] = value
}</span>
</pre>
		
		<pre class="file" id="file155" style="display: none">package web

import (
        "sync"
        "time"
)

// NewSession returns a new session object.
func NewSession(userID string, sessionID string) *Session <span class="cov8" title="1">{
        return &amp;Session{
                UserID:     userID,
                SessionID:  sessionID,
                CreatedUTC: time.Now().UTC(),
                State:      map[string]interface{}{},
                Mutex:      &amp;sync.RWMutex{},
        }
}</span>

// Session is an active session
type Session struct {
        UserID     string                 `json:"userID" yaml:"userID"`
        SessionID  string                 `json:"sessionID" yaml:"sessionID"`
        CreatedUTC time.Time              `json:"createdUTC" yaml:"createdUTC"`
        ExpiresUTC *time.Time             `json:"expiresUTC" yaml:"expiresUTC"`
        State      map[string]interface{} `json:"state,omitempty" yaml:"state,omitempty"`
        Mutex      *sync.RWMutex          `json:"-" yaml:"-"`
}

// IsExpired returns if the session is expired.
func (s *Session) IsExpired() bool <span class="cov8" title="1">{
        if s == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if s.ExpiresUTC == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return s.ExpiresUTC.Before(time.Now().UTC())</span>
}

func (s *Session) ensureMutex() <span class="cov8" title="1">{
        if s.Mutex == nil </span><span class="cov8" title="1">{
                s.Mutex = &amp;sync.RWMutex{}
        }</span>
}

// IsZero returns if the object is set or not.
// It will return true if either the userID or the sessionID are unset.
func (s *Session) IsZero() bool <span class="cov8" title="1">{
        if s == nil </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">return len(s.UserID) == 0 || len(s.SessionID) == 0</span>
}

// Lock locks the session.
func (s *Session) Lock() <span class="cov0" title="0">{
        s.ensureMutex()
        s.Mutex.Lock()
}</span>

// Unlock unlocks the session.
func (s *Session) Unlock() <span class="cov0" title="0">{
        s.ensureMutex()
        s.Mutex.Unlock()
}</span>

// RLock read locks the session.
func (s *Session) RLock() <span class="cov8" title="1">{
        s.ensureMutex()
        s.Mutex.RLock()
}</span>

// RUnlock read unlocks the session.
func (s *Session) RUnlock() <span class="cov8" title="1">{
        s.ensureMutex()
        s.Mutex.RUnlock()
}</span>
</pre>
		
		<pre class="file" id="file156" style="display: none">package web

import (
        "sync"
)

// NewSessionCache returns a new session cache.
func NewSessionCache() *SessionCache <span class="cov8" title="1">{
        return &amp;SessionCache{
                SessionLock: &amp;sync.Mutex{},
                Sessions:    map[string]*Session{},
        }
}</span>

// SessionCache is a memory ledger of active sessions.
type SessionCache struct {
        SessionLock *sync.Mutex
        Sessions    map[string]*Session
}

// Upsert adds or updates a session to the cache.
func (sc *SessionCache) Upsert(session *Session) <span class="cov8" title="1">{
        sc.SessionLock.Lock()
        defer sc.SessionLock.Unlock()
        sc.Sessions[session.SessionID] = session
}</span>

// Remove removes a session from the cache.
func (sc *SessionCache) Remove(sessionID string) <span class="cov8" title="1">{
        sc.SessionLock.Lock()
        defer sc.SessionLock.Unlock()
        delete(sc.Sessions, sessionID)
}</span>

// Get gets a session.
func (sc *SessionCache) Get(sessionID string) *Session <span class="cov8" title="1">{
        sc.SessionLock.Lock()
        defer sc.SessionLock.Unlock()

        if session, hasSession := sc.Sessions[sessionID]; hasSession </span><span class="cov8" title="1">{
                return session
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// IsActive returns if a sessionID is active.
func (sc *SessionCache) IsActive(sessionID string) bool <span class="cov8" title="1">{
        sc.SessionLock.Lock()
        defer sc.SessionLock.Unlock()

        session, hasSession := sc.Sessions[sessionID]
        if hasSession </span><span class="cov8" title="1">{
                return !session.IsExpired()
        }</span>
        <span class="cov8" title="1">return hasSession</span>
}
</pre>
		
		<pre class="file" id="file157" style="display: none">package web

// SessionAware is an action that injects the session into the context, it acquires a read lock on session.
func SessionAware(action Action) Action <span class="cov8" title="1">{
        return sessionMiddleware(action, nil, SessionReadLock)
}</span>

// SessionAwareMutating is an action that injects the session into the context and requires a write lock.
func SessionAwareMutating(action Action) Action <span class="cov0" title="0">{
        return sessionMiddleware(action, nil, SessionReadWriteLock)
}</span>

// SessionAwareUnsafe is an action that injects the session into the context without acquiring any (read or write) locks.
func SessionAwareUnsafe(action Action) Action <span class="cov0" title="0">{
        return sessionMiddleware(action, nil, SessionUnsafe)
}</span>

// SessionRequired is an action that requires a session to be present
// or identified in some form on the request, and acquires a read lock on session.
func SessionRequired(action Action) Action <span class="cov8" title="1">{
        return sessionMiddleware(action, AuthManagerRedirect, SessionReadLock)
}</span>

// SessionRequiredMutating is an action that requires the session to present and also requires a write lock.
func SessionRequiredMutating(action Action) Action <span class="cov0" title="0">{
        return sessionMiddleware(action, AuthManagerRedirect, SessionReadWriteLock)
}</span>

// SessionRequiredUnsafe is an action that requires the session to present and does not acquire any (read or write) locks.
func SessionRequiredUnsafe(action Action) Action <span class="cov0" title="0">{
        return sessionMiddleware(action, AuthManagerRedirect, SessionUnsafe)
}</span>

// AuthManagerRedirect is a redirect.
func AuthManagerRedirect(ctx *Ctx) Result <span class="cov8" title="1">{
        return ctx.Auth().Redirect(ctx)
}</span>

// SessionMiddleware creates a custom session middleware.
func SessionMiddleware(notAuthorized Action, lockPolicy SessionLockPolicy) Middleware <span class="cov0" title="0">{
        return func(action Action) Action </span><span class="cov0" title="0">{
                return sessionMiddleware(action, notAuthorized, lockPolicy)
        }</span>
}

// SessionMiddleware returns a session middleware.
func sessionMiddleware(action, notAuthorized Action, lockPolicy SessionLockPolicy) Action <span class="cov8" title="1">{
        return func(ctx *Ctx) Result </span><span class="cov8" title="1">{
                session, err := ctx.Auth().VerifySession(ctx)
                if err != nil &amp;&amp; !IsErrSessionInvalid(err) </span><span class="cov0" title="0">{
                        return ctx.DefaultResultProvider().InternalError(err)
                }</span>

                <span class="cov8" title="1">if session == nil </span><span class="cov8" title="1">{
                        if notAuthorized != nil </span><span class="cov8" title="1">{
                                return notAuthorized(ctx)
                        }</span>
                        <span class="cov8" title="1">return action(ctx)</span>
                }

                <span class="cov8" title="1">switch lockPolicy </span>{
                case SessionReadLock:<span class="cov8" title="1">
                        </span><span class="cov8" title="1">{
                                session.RLock()
                                defer session.RUnlock()
                                break</span>
                        }
                case SessionReadWriteLock:<span class="cov0" title="0">
                        </span><span class="cov0" title="0">{
                                session.Lock()
                                defer session.Unlock()
                                break</span>
                        }
                }

                <span class="cov8" title="1">ctx.WithSession(session)
                return action(ctx)</span>
        }
}
</pre>
		
		<pre class="file" id="file158" style="display: none">package web

import "database/sql"

const (
        // StateKeyTx is the app state key for a transaction.
        StateKeyTx = "tx"
)

// State is the collection of state objects on a context.
type State map[string]interface{}

// StateProvider provide states, an example is Ctx
type StateProvider interface {
        State() State
}

// StateValueProvider is a type that provides a state value.
type StateValueProvider interface {
        StateValue(key string) interface{}
}

// Tx returns the transaction for the request.
// keys is an optional parameter used for additional arbitrary transactions
func Tx(sp StateProvider, optionalKey ...string) *sql.Tx <span class="cov8" title="1">{
        if sp == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return TxFromState(sp.State(), optionalKey...)</span>
}

// TxFromState returns a tx from a state bag.
func TxFromState(state State, keys ...string) *sql.Tx <span class="cov8" title="1">{
        if state == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">key := StateKeyTx
        if len(keys) &gt; 0 </span><span class="cov8" title="1">{
                key = keys[0]
        }</span>
        <span class="cov8" title="1">if typed, isTyped := state[key].(*sql.Tx); isTyped </span><span class="cov8" title="1">{
                return typed
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// WithTx sets a transaction on the state provider.
func WithTx(sp StateProvider, tx *sql.Tx, keys ...string) StateProvider <span class="cov8" title="1">{
        if sp == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">state := sp.State()
        if state == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">WithTxForState(state, tx, keys...)
        return sp</span>
}

// WithTxForState injects a tx into a statebag.
func WithTxForState(state State, tx *sql.Tx, keys ...string) <span class="cov8" title="1">{
        key := StateKeyTx
        if len(keys) &gt; 0 </span><span class="cov8" title="1">{
                key = keys[0]
        }</span>
        <span class="cov8" title="1">state[key] = tx</span>
}
</pre>
		
		<pre class="file" id="file159" style="display: none">package web

import (
        "net/http"
        "os"
        "regexp"

        "github.com/blend/go-sdk/logger"
)

// NewStaticFileServer returns a new static file cache.
func NewStaticFileServer(fs http.FileSystem) *StaticFileServer <span class="cov8" title="1">{
        return &amp;StaticFileServer{
                fileSystem: fs,
        }
}</span>

// StaticFileServer is a cache of static files.
type StaticFileServer struct {
        log          *logger.Logger
        fileSystem   http.FileSystem
        rewriteRules []RewriteRule
        middleware   Action
        headers      http.Header
}

// Log returns a logger reference.
func (sc *StaticFileServer) Log() *logger.Logger <span class="cov0" title="0">{
        return sc.log
}</span>

// WithLogger sets the logger reference for the static file cache.
func (sc *StaticFileServer) WithLogger(log *logger.Logger) *StaticFileServer <span class="cov0" title="0">{
        sc.log = log
        return sc
}</span>

// AddHeader adds a header to the static cache results.
func (sc *StaticFileServer) AddHeader(key, value string) <span class="cov8" title="1">{
        if sc.headers == nil </span><span class="cov8" title="1">{
                sc.headers = http.Header{}
        }</span>
        <span class="cov8" title="1">sc.headers[key] = append(sc.headers[key], value)</span>
}

// Headers returns the headers for the static server.
func (sc *StaticFileServer) Headers() http.Header <span class="cov8" title="1">{
        return sc.headers
}</span>

// AddRewriteRule adds a static re-write rule.
func (sc *StaticFileServer) AddRewriteRule(match string, action RewriteAction) error <span class="cov8" title="1">{
        expr, err := regexp.Compile(match)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">sc.rewriteRules = append(sc.rewriteRules, RewriteRule{
                MatchExpression: match,
                expr:            expr,
                Action:          action,
        })
        return nil</span>
}

// SetMiddleware sets the middlewares.
func (sc *StaticFileServer) SetMiddleware(middlewares ...Middleware) <span class="cov8" title="1">{
        sc.middleware = NestMiddleware(sc.ServeFile, middlewares...)
}</span>

// RewriteRules returns the rewrite rules
func (sc *StaticFileServer) RewriteRules() []RewriteRule <span class="cov8" title="1">{
        return sc.rewriteRules
}</span>

// Action is the entrypoint for the static server.
// It will run middleware if specified before serving the file.
func (sc *StaticFileServer) Action(r *Ctx) Result <span class="cov8" title="1">{
        if sc.middleware != nil </span><span class="cov8" title="1">{
                return sc.middleware(r)
        }</span>
        <span class="cov8" title="1">return sc.ServeFile(r)</span>
}

// ServeFile writes the file to the response without running middleware.
func (sc *StaticFileServer) ServeFile(r *Ctx) Result <span class="cov8" title="1">{
        for key, values := range sc.headers </span><span class="cov8" title="1">{
                for _, value := range values </span><span class="cov8" title="1">{
                        r.Response().Header().Set(key, value)
                }</span>
        }

        <span class="cov8" title="1">filePath, err := r.RouteParam("filepath")
        if err != nil </span><span class="cov0" title="0">{
                return r.DefaultResultProvider().InternalError(err)
        }</span>

        <span class="cov8" title="1">for _, rule := range sc.rewriteRules </span><span class="cov8" title="1">{
                if matched, newFilePath := rule.Apply(filePath); matched </span><span class="cov8" title="1">{
                        filePath = newFilePath
                }</span>
        }

        <span class="cov8" title="1">f, err := sc.fileSystem.Open(filePath)
        if f == nil || os.IsNotExist(err) </span><span class="cov0" title="0">{
                return r.DefaultResultProvider().NotFound()
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return r.DefaultResultProvider().InternalError(err)
        }</span>
        <span class="cov8" title="1">defer f.Close()

        d, err := f.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return r.DefaultResultProvider().InternalError(err)
        }</span>

        <span class="cov8" title="1">http.ServeContent(r.Response(), r.Request(), filePath, d.ModTime(), f)
        return nil</span>

}
</pre>
		
		<pre class="file" id="file160" style="display: none">package web

import (
        "net/http"
        "path"
)

// NewStaticResultForFile returns a static result for an individual file.
func NewStaticResultForFile(filePath string) *StaticResult <span class="cov8" title="1">{
        file := path.Base(filePath)
        root := path.Dir(filePath)
        return &amp;StaticResult{
                FilePath:   file,
                FileSystem: http.Dir(root),
        }
}</span>

// StaticResult represents a static output.
type StaticResult struct {
        FilePath     string
        FileSystem   http.FileSystem
        RewriteRules []RewriteRule
        Headers      http.Header
}

// Render renders a static result.
func (sr StaticResult) Render(ctx *Ctx) error <span class="cov8" title="1">{
        filePath := sr.FilePath
        for _, rule := range sr.RewriteRules </span><span class="cov0" title="0">{
                if matched, newFilePath := rule.Apply(filePath); matched </span><span class="cov0" title="0">{
                        filePath = newFilePath
                }</span>
        }

        <span class="cov8" title="1">for key, values := range sr.Headers </span><span class="cov0" title="0">{
                for _, value := range values </span><span class="cov0" title="0">{
                        ctx.Response().Header().Add(key, value)
                }</span>
        }

        <span class="cov8" title="1">f, err := sr.FileSystem.Open(sr.FilePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer f.Close()

        d, err := f.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">http.ServeContent(ctx.Response(), ctx.Request(), filePath, d.ModTime(), f)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file161" style="display: none">package web

import (
        "net"
        "time"
)

const (
        // DefaultTCPKeepAliveListenerPeriod is the default keep alive period for the tcp listener.
        DefaultTCPKeepAliveListenerPeriod = 3 * time.Minute
)

// TCPKeepAliveListener sets TCP keep-alive timeouts on accepted
// connections. It's used by ListenAndServe and ListenAndServeTLS so
// dead TCP connections (e.g. closing laptop mid-download) eventually
// go away.
type TCPKeepAliveListener struct {
        *net.TCPListener
}

// Accept accepts the connection.
func (ln TCPKeepAliveListener) Accept() (net.Conn, error) <span class="cov8" title="1">{
        tc, err := ln.AcceptTCP()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">tc.SetKeepAlive(true)
        tc.SetKeepAlivePeriod(DefaultTCPKeepAliveListenerPeriod)
        return tc, nil</span>
}
</pre>
		
		<pre class="file" id="file162" style="display: none">package web

import (
        "fmt"
        "net/http"

        "github.com/blend/go-sdk/logger"
)

// NewTextResultProvider returns a new text result provider.
func NewTextResultProvider(log *logger.Logger) *TextResultProvider <span class="cov0" title="0">{
        return &amp;TextResultProvider{log: log}
}</span>

// TextResultProvider is the default response provider if none is specified.
type TextResultProvider struct {
        log *logger.Logger
}

// NotFound returns a text response.
func (trp *TextResultProvider) NotFound() Result <span class="cov0" title="0">{
        return &amp;RawResult{
                StatusCode:  http.StatusNotFound,
                ContentType: ContentTypeText,
                Body:        []byte("Not Found"),
        }
}</span>

// NotAuthorized returns a text response.
func (trp *TextResultProvider) NotAuthorized() Result <span class="cov8" title="1">{
        return &amp;RawResult{
                StatusCode:  http.StatusForbidden,
                ContentType: ContentTypeText,
                Body:        []byte("Not Authorized"),
        }
}</span>

// InternalError returns a text response.
func (trp *TextResultProvider) InternalError(err error) Result <span class="cov8" title="1">{
        if trp.log != nil </span><span class="cov0" title="0">{
                trp.log.Fatal(err)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return &amp;RawResult{
                        StatusCode:  http.StatusInternalServerError,
                        ContentType: ContentTypeText,
                        Body:        []byte(err.Error()),
                }
        }</span>

        <span class="cov0" title="0">return &amp;RawResult{
                StatusCode:  http.StatusInternalServerError,
                ContentType: ContentTypeText,
                Body:        []byte("An internal server error occurred."),
        }</span>
}

// BadRequest returns a text response.
func (trp *TextResultProvider) BadRequest(err error) Result <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                return &amp;RawResult{
                        StatusCode:  http.StatusBadRequest,
                        ContentType: ContentTypeText,
                        Body:        []byte(fmt.Sprintf("Bad Request: %v", err)),
                }
        }</span>
        <span class="cov0" title="0">return &amp;RawResult{
                StatusCode:  http.StatusBadRequest,
                ContentType: ContentTypeText,
                Body:        []byte("Bad Request"),
        }</span>
}

// Result returns a plaintext result.
func (trp *TextResultProvider) Result(response interface{}) Result <span class="cov8" title="1">{
        return &amp;RawResult{
                StatusCode:  http.StatusOK,
                ContentType: ContentTypeText,
                Body:        []byte(fmt.Sprintf("%s", response)),
        }
}</span>
</pre>
		
		<pre class="file" id="file163" style="display: none">package web

import (
        "crypto/tls"
        "crypto/x509"
        "io/ioutil"

        "github.com/blend/go-sdk/exception"
        "github.com/blend/go-sdk/util"
)

// TLSConfig is a config for app tls settings.
type TLSConfig struct {
        Cert     []byte `json:"cert" yaml:"cert" env:"TLS_CERT"`
        CertPath string `json:"certPath" yaml:"certPath" env:"TLS_CERT_PATH"`
        Key      []byte `json:"key" yaml:"key" env:"TLS_KEY"`
        KeyPath  string `json:"keyPath" yaml:"keyPath" env:"TLS_KEY_PATH"`

        CAPaths []string `json:"caPaths" yaml:"caPaths" env:"TLS_CA_PATHS,csv"`
}

// GetCert returns a tls cert.
func (tc TLSConfig) GetCert(defaults ...[]byte) []byte <span class="cov8" title="1">{
        return util.Coalesce.Bytes(tc.Cert, nil, defaults...)
}</span>

// GetCertPath returns a tls cert path.
func (tc TLSConfig) GetCertPath(defaults ...string) string <span class="cov8" title="1">{
        return util.Coalesce.String(tc.CertPath, "", defaults...)
}</span>

// GetKey returns a tls key.
func (tc TLSConfig) GetKey(defaults ...[]byte) []byte <span class="cov0" title="0">{
        return util.Coalesce.Bytes(tc.Key, nil, defaults...)
}</span>

// GetKeyPath returns a tls key path.
func (tc TLSConfig) GetKeyPath(defaults ...string) string <span class="cov8" title="1">{
        return util.Coalesce.String(tc.KeyPath, "", defaults...)
}</span>

// GetCAPaths returns a list of ca paths to add.
func (tc TLSConfig) GetCAPaths(defaults ...[]string) []string <span class="cov8" title="1">{
        return util.Coalesce.Strings(tc.CAPaths, nil, defaults...)
}</span>

// GetConfig returns a stdlib tls config for the config.
func (tc TLSConfig) GetConfig() (*tls.Config, error) <span class="cov8" title="1">{
        if !tc.HasKeyPair() </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">var cert tls.Certificate
        var err error

        if len(tc.GetCertPath()) &gt; 0 </span><span class="cov8" title="1">{
                cert, err = tls.LoadX509KeyPair(
                        tc.GetCertPath(),
                        tc.GetKeyPath(),
                )
        }</span> else<span class="cov0" title="0"> {
                cert, err = tls.X509KeyPair(tc.GetCert(), tc.GetKey())
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>

        <span class="cov8" title="1">if len(tc.GetCAPaths()) == 0 </span><span class="cov8" title="1">{
                return &amp;tls.Config{
                        Certificates: []tls.Certificate{cert},
                }, nil
        }</span>

        <span class="cov0" title="0">certPool, err := x509.SystemCertPool()
        if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>
        <span class="cov0" title="0">for _, caPath := range tc.GetCAPaths() </span><span class="cov0" title="0">{
                caCert, err := ioutil.ReadFile(caPath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, exception.Wrap(err)
                }</span>
                <span class="cov0" title="0">certPool.AppendCertsFromPEM(caCert)</span>
        }

        <span class="cov0" title="0">return &amp;tls.Config{
                Certificates: []tls.Certificate{cert},
                RootCAs:      certPool,
        }, nil</span>
}

// HasKeyPair returns if the config names a keypair.
func (tc TLSConfig) HasKeyPair() bool <span class="cov8" title="1">{
        if len(tc.GetCert()) &gt; 0 &amp;&amp; len(tc.GetKey()) &gt; 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">if len(tc.GetCertPath()) &gt; 0 &amp;&amp; len(tc.GetKeyPath()) &gt; 0 </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file164" style="display: none">// Copyright 2013 Julien Schmidt. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be found
// in the LICENSE file.

package web

import (
        "strings"
        "unicode"
        "unicode/utf8"
)

type nodeType uint8

const (
        static nodeType = iota // default
        root
        param
        catchAll
)

type node struct {
        nodeType
        path       string
        isWildcard bool
        maxParams  uint8
        indices    string
        children   []*node
        route      *Route
        priority   uint32
}

// incrementChildPriority increments priority of the given child and reorders if necessary
func (n *node) incrementChildPriority(index int) int <span class="cov8" title="1">{
        n.children[index].priority++
        priority := n.children[index].priority

        // adjust position (move to front)
        newIndex := index
        for newIndex &gt; 0 &amp;&amp; n.children[newIndex-1].priority &lt; priority </span><span class="cov8" title="1">{
                // swap node positions
                temp := n.children[newIndex-1]
                n.children[newIndex-1] = n.children[newIndex]
                n.children[newIndex] = temp
                newIndex--
        }</span>

        // build new index char string
        <span class="cov8" title="1">if newIndex != index </span><span class="cov8" title="1">{
                n.indices = n.indices[:newIndex] + // unchanged prefix, might be empty
                        n.indices[index:index+1] + // the index char we move
                        n.indices[newIndex:index] + n.indices[index+1:] // rest without char at 'pos'
        }</span>

        <span class="cov8" title="1">return newIndex</span>
}

// addRoute adds a node with the given handle to the path.
// Not concurrency-safe!
func (n *node) addRoute(method, path string, handler Handler) <span class="cov8" title="1">{
        fullPath := path
        n.priority++
        numParams := countParams(path)

        // non-empty tree
        if len(n.path) &gt; 0 || len(n.children) &gt; 0 </span><span class="cov8" title="1">{
        walk:
                for </span><span class="cov8" title="1">{
                        // Update maxParams of the current node
                        if numParams &gt; n.maxParams </span><span class="cov8" title="1">{
                                n.maxParams = numParams
                        }</span>

                        // Find the longest common prefix.
                        // This also implies that the common prefix contains no ':' or '*'
                        // since the existing key can't contain those chars.
                        <span class="cov8" title="1">i := 0
                        max := min(len(path), len(n.path))
                        for i &lt; max &amp;&amp; path[i] == n.path[i] </span><span class="cov8" title="1">{
                                i++
                        }</span>

                        // Split edge
                        <span class="cov8" title="1">if i &lt; len(n.path) </span><span class="cov8" title="1">{
                                child := node{
                                        path:       n.path[i:],
                                        isWildcard: n.isWildcard,
                                        nodeType:   static,
                                        indices:    n.indices,
                                        children:   n.children,
                                        route:      n.route,
                                        priority:   n.priority - 1,
                                }

                                // Update maxParams (max of all children)
                                for i := range child.children </span><span class="cov8" title="1">{
                                        if child.children[i].maxParams &gt; child.maxParams </span><span class="cov8" title="1">{
                                                child.maxParams = child.children[i].maxParams
                                        }</span>
                                }

                                <span class="cov8" title="1">n.children = []*node{&amp;child}
                                // []byte for proper unicode char conversion, see #65
                                n.indices = string([]byte{n.path[i]})
                                n.path = path[:i]
                                n.route = nil
                                n.isWildcard = false</span>
                        }

                        // Make new node a child of this node
                        <span class="cov8" title="1">if i &lt; len(path) </span><span class="cov8" title="1">{
                                path = path[i:]

                                if n.isWildcard </span><span class="cov8" title="1">{
                                        n = n.children[0]
                                        n.priority++

                                        // Update maxParams of the child node
                                        if numParams &gt; n.maxParams </span><span class="cov8" title="1">{
                                                n.maxParams = numParams
                                        }</span>
                                        <span class="cov8" title="1">numParams--

                                        // Check if the wildcard matches
                                        if len(path) &gt;= len(n.path) &amp;&amp; n.path == path[:len(n.path)] </span><span class="cov8" title="1">{
                                                // check for longer wildcard, e.g. :name and :names
                                                if len(n.path) &gt;= len(path) || path[len(n.path)] == '/' </span><span class="cov8" title="1">{
                                                        continue walk</span>
                                                }
                                        }

                                        <span class="cov8" title="1">panic("path segment '" + path +
                                                "' conflicts with existing wildcard '" + n.path +
                                                "' in path '" + fullPath + "'")</span>
                                }

                                <span class="cov8" title="1">c := path[0]

                                // slash after param
                                if n.nodeType == param &amp;&amp; c == '/' &amp;&amp; len(n.children) == 1 </span><span class="cov8" title="1">{
                                        n = n.children[0]
                                        n.priority++
                                        continue walk</span>
                                }

                                // Check if a child with the next path byte exists
                                <span class="cov8" title="1">for i := 0; i &lt; len(n.indices); i++ </span><span class="cov8" title="1">{
                                        if c == n.indices[i] </span><span class="cov8" title="1">{
                                                i = n.incrementChildPriority(i)
                                                n = n.children[i]
                                                continue walk</span>
                                        }
                                }

                                // Otherwise insert it
                                <span class="cov8" title="1">if c != ':' &amp;&amp; c != '*' </span><span class="cov8" title="1">{
                                        // []byte for proper unicode char conversion, see #65
                                        n.indices += string([]byte{c})
                                        child := &amp;node{
                                                maxParams: numParams,
                                        }
                                        n.children = append(n.children, child)
                                        n.incrementChildPriority(len(n.indices) - 1)
                                        n = child
                                }</span>
                                <span class="cov8" title="1">n.insertChild(numParams, method, path, fullPath, handler)
                                return</span>

                        } else<span class="cov8" title="1"> if i == len(path) </span><span class="cov8" title="1">{ // Make node a (in-path) leaf
                                if n.route != nil </span><span class="cov8" title="1">{
                                        panic("a handle is already registered for path '" + fullPath + "'")</span>
                                }
                                <span class="cov8" title="1">n.route = &amp;Route{
                                        Handler: handler,
                                        Path:    fullPath,
                                        Method:  method,
                                }</span>
                        }
                        <span class="cov8" title="1">return</span>
                }
        } else<span class="cov8" title="1"> { // Empty tree
                n.insertChild(numParams, method, path, fullPath, handler)
                n.nodeType = root
        }</span>
}

func (n *node) insertChild(numParams uint8, method, path, fullPath string, handler Handler) <span class="cov8" title="1">{
        var offset int // already handled bytes of the path

        // find prefix until first wildcard (beginning with ':'' or '*'')
        for i, max := 0, len(path); numParams &gt; 0; i++ </span><span class="cov8" title="1">{
                c := path[i]
                if c != ':' &amp;&amp; c != '*' </span><span class="cov8" title="1">{
                        continue</span>
                }

                // find wildcard end (either '/' or path end)
                <span class="cov8" title="1">end := i + 1
                for end &lt; max &amp;&amp; path[end] != '/' </span><span class="cov8" title="1">{
                        switch path[end] </span>{
                        // the wildcard name must not contain ':' and '*'
                        case ':', '*':<span class="cov8" title="1">
                                panic("only one wildcard per path segment is allowed, has: '" +
                                        path[i:] + "' in path '" + fullPath + "'")</span>
                        default:<span class="cov8" title="1">
                                end++</span>
                        }
                }

                // check if this Node existing children which would be
                // unreachable if we insert the wildcard here
                <span class="cov8" title="1">if len(n.children) &gt; 0 </span><span class="cov8" title="1">{
                        panic("wildcard route '" + path[i:end] +
                                "' conflicts with existing children in path '" + fullPath + "'")</span>
                }

                // check if the wildcard has a name
                <span class="cov8" title="1">if end-i &lt; 2 </span><span class="cov8" title="1">{
                        panic("wildcards must be named with a non-empty name in path '" + fullPath + "'")</span>
                }

                <span class="cov8" title="1">if c == ':' </span><span class="cov8" title="1">{ // param
                        // split path at the beginning of the wildcard
                        if i &gt; 0 </span><span class="cov8" title="1">{
                                n.path = path[offset:i]
                                offset = i
                        }</span>

                        <span class="cov8" title="1">child := &amp;node{
                                nodeType:  param,
                                maxParams: numParams,
                        }
                        n.children = []*node{child}
                        n.isWildcard = true
                        n = child
                        n.priority++
                        numParams--

                        // if the path doesn't end with the wildcard, then there
                        // will be another non-wildcard subpath starting with '/'
                        if end &lt; max </span><span class="cov8" title="1">{
                                n.path = path[offset:end]
                                offset = end

                                child := &amp;node{
                                        maxParams: numParams,
                                        priority:  1,
                                }
                                n.children = []*node{child}
                                n = child
                        }</span>

                } else<span class="cov8" title="1"> { // catchAll
                        if end != max || numParams &gt; 1 </span><span class="cov8" title="1">{
                                panic("catch-all routes are only allowed at the end of the path in path '" + fullPath + "'")</span>
                        }

                        <span class="cov8" title="1">if len(n.path) &gt; 0 &amp;&amp; n.path[len(n.path)-1] == '/' </span><span class="cov8" title="1">{
                                panic("catch-all conflicts with existing handle for the path segment root in path '" + fullPath + "'")</span>
                        }

                        // currently fixed width 1 for '/'
                        <span class="cov8" title="1">i--
                        if path[i] != '/' </span><span class="cov8" title="1">{
                                panic("no / before catch-all in path '" + fullPath + "'")</span>
                        }

                        <span class="cov8" title="1">n.path = path[offset:i]

                        // first node: catchAll node with empty path
                        child := &amp;node{
                                isWildcard: true,
                                nodeType:   catchAll,
                                maxParams:  1,
                        }
                        n.children = []*node{child}
                        n.indices = string(path[i])
                        n = child
                        n.priority++

                        // second node: node holding the variable
                        child = &amp;node{
                                path:      path[i:],
                                nodeType:  catchAll,
                                maxParams: 1,
                                route: &amp;Route{
                                        Handler: handler,
                                        Path:    fullPath,
                                        Method:  method,
                                },
                                priority: 1,
                        }
                        n.children = []*node{child}

                        return</span>
                }
        }

        // insert remaining path part and handle to the leaf
        <span class="cov8" title="1">n.path = path[offset:]
        n.route = &amp;Route{
                Handler: handler,
                Path:    fullPath,
                Method:  method,
        }</span>
}

// Returns the handle registered with the given path (key). The values of
// wildcards are saved to a map.
// If no handle can be found, a TSR (trailing slash redirect) recommendation is
// made if a handle exists with an extra (without the) trailing slash for the
// given path.
func (n *node) getValue(path string) (route *Route, p RouteParameters, tsr bool) <span class="cov8" title="1">{
walk: // outer loop for walking the tree
        for </span><span class="cov8" title="1">{
                if len(path) &gt; len(n.path) </span><span class="cov8" title="1">{
                        if path[:len(n.path)] == n.path </span><span class="cov8" title="1">{
                                path = path[len(n.path):]
                                // If this node does not have a wildcard (param or catchAll)
                                // child,  we can just look up the next child node and continue
                                // to walk down the tree
                                if !n.isWildcard </span><span class="cov8" title="1">{
                                        c := path[0]
                                        for i := 0; i &lt; len(n.indices); i++ </span><span class="cov8" title="1">{
                                                if c == n.indices[i] </span><span class="cov8" title="1">{
                                                        n = n.children[i]
                                                        continue walk</span>
                                                }
                                        }

                                        // Nothing found.
                                        // We can recommend to redirect to the same URL without a
                                        // trailing slash if a leaf exists for that path.
                                        <span class="cov8" title="1">tsr = (path == "/" &amp;&amp; n.route != nil)
                                        return</span>
                                }

                                // handle wildcard child
                                <span class="cov8" title="1">n = n.children[0]
                                switch n.nodeType </span>{
                                case param:<span class="cov8" title="1">
                                        // find param end (either '/' or path end)
                                        end := 0
                                        for end &lt; len(path) &amp;&amp; path[end] != '/' </span><span class="cov8" title="1">{
                                                end++
                                        }</span>

                                        // save param value
                                        <span class="cov8" title="1">if p == nil </span><span class="cov8" title="1">{
                                                // lazy allocation
                                                p = make(RouteParameters)
                                        }</span>
                                        <span class="cov8" title="1">p[n.path[1:]] = path[:end]

                                        // we need to go deeper!
                                        if end &lt; len(path) </span><span class="cov8" title="1">{
                                                if len(n.children) &gt; 0 </span><span class="cov8" title="1">{
                                                        path = path[end:]
                                                        n = n.children[0]
                                                        continue walk</span>
                                                }

                                                // ... but we can't
                                                <span class="cov8" title="1">tsr = (len(path) == end+1)
                                                return</span>
                                        }

                                        <span class="cov8" title="1">if route = n.route; route != nil </span><span class="cov8" title="1">{
                                                return
                                        }</span> else<span class="cov8" title="1"> if len(n.children) == 1 </span><span class="cov8" title="1">{
                                                // No handle found. Check if a handle for this path + a
                                                // trailing slash exists for TSR recommendation
                                                n = n.children[0]
                                                tsr = (n.path == "/" &amp;&amp; n.route != nil)
                                        }</span>

                                        <span class="cov8" title="1">return</span>

                                case catchAll:<span class="cov8" title="1">
                                        // save param value
                                        if p == nil </span><span class="cov8" title="1">{
                                                // lazy allocation
                                                p = make(RouteParameters)
                                        }</span>

                                        <span class="cov8" title="1">p[n.path[2:]] = path[:]

                                        route = n.route
                                        return</span>

                                default:<span class="cov8" title="1">
                                        panic("invalid node type")</span>
                                }
                        }
                } else<span class="cov8" title="1"> if path == n.path </span><span class="cov8" title="1">{
                        // We should have reached the node containing the handle.
                        // Check if this node has a handle registered.
                        if route = n.route; route != nil </span><span class="cov8" title="1">{
                                return
                        }</span>

                        <span class="cov8" title="1">if path == "/" &amp;&amp; n.isWildcard &amp;&amp; n.nodeType != root </span><span class="cov8" title="1">{
                                tsr = true
                                return
                        }</span>

                        // No handle found. Check if a handle for this path + a
                        // trailing slash exists for trailing slash recommendation
                        <span class="cov8" title="1">for i := 0; i &lt; len(n.indices); i++ </span><span class="cov8" title="1">{
                                if n.indices[i] == '/' </span><span class="cov8" title="1">{
                                        n = n.children[i]
                                        tsr = (len(n.path) == 1 &amp;&amp; n.route != nil) ||
                                                (n.nodeType == catchAll &amp;&amp; n.children[0].route != nil)
                                        return
                                }</span>
                        }

                        <span class="cov8" title="1">return</span>
                }

                // Nothing found. We can recommend to redirect to the same URL with an
                // extra trailing slash if a leaf exists for that path
                <span class="cov8" title="1">tsr = (path == "/") ||
                        (len(n.path) == len(path)+1 &amp;&amp; n.path[len(path)] == '/' &amp;&amp;
                                path == n.path[:len(n.path)-1] &amp;&amp; n.route != nil)
                return</span>
        }
}

// Makes a case-insensitive lookup of the given path and tries to find a handler.
// It can optionally also fix trailing slashes.
// It returns the case-corrected path and a bool indicating whether the lookup
// was successful.
func (n *node) findCaseInsensitivePath(path string, fixTrailingSlash bool) (ciPath []byte, found bool) <span class="cov8" title="1">{
        return n.findCaseInsensitivePathRec(
                path,
                strings.ToLower(path),
                make([]byte, 0, len(path)+1), // preallocate enough memory for new path
                [4]byte{},                    // empty rune buffer
                fixTrailingSlash,
        )
}</span>

// shift bytes in array by n bytes left
func shiftNRuneBytes(rb [4]byte, n int) [4]byte <span class="cov8" title="1">{
        switch n </span>{
        case 0:<span class="cov8" title="1">
                return rb</span>
        case 1:<span class="cov8" title="1">
                return [4]byte{rb[1], rb[2], rb[3], 0}</span>
        case 2:<span class="cov8" title="1">
                return [4]byte{rb[2], rb[3]}</span>
        case 3:<span class="cov8" title="1">
                return [4]byte{rb[3]}</span>
        default:<span class="cov8" title="1">
                return [4]byte{}</span>
        }
}

// recursive case-insensitive lookup function used by n.findCaseInsensitivePath
func (n *node) findCaseInsensitivePathRec(path, loPath string, ciPath []byte, rb [4]byte, fixTrailingSlash bool) ([]byte, bool) <span class="cov8" title="1">{
        loNPath := strings.ToLower(n.path)

walk: // outer loop for walking the tree
        for len(loPath) &gt;= len(loNPath) &amp;&amp; (len(loNPath) == 0 || loPath[1:len(loNPath)] == loNPath[1:]) </span><span class="cov8" title="1">{
                // add common path to result
                ciPath = append(ciPath, n.path...)

                if path = path[len(n.path):]; len(path) &gt; 0 </span><span class="cov8" title="1">{
                        loOld := loPath
                        loPath = loPath[len(loNPath):]

                        // If this node does not have a wildcard (param or catchAll) child,
                        // we can just look up the next child node and continue to walk down
                        // the tree
                        if !n.isWildcard </span><span class="cov8" title="1">{
                                // skip rune bytes already processed
                                rb = shiftNRuneBytes(rb, len(loNPath))

                                if rb[0] != 0 </span><span class="cov8" title="1">{
                                        // old rune not finished
                                        for i := 0; i &lt; len(n.indices); i++ </span><span class="cov8" title="1">{
                                                if n.indices[i] == rb[0] </span><span class="cov8" title="1">{
                                                        // continue with child node
                                                        n = n.children[i]
                                                        loNPath = strings.ToLower(n.path)
                                                        continue walk</span>
                                                }
                                        }
                                } else<span class="cov8" title="1"> {
                                        // process a new rune
                                        var rv rune

                                        // find rune start
                                        // runes are up to 4 byte long,
                                        // -4 would definitely be another rune
                                        var off int
                                        for max := min(len(loNPath), 3); off &lt; max; off++ </span><span class="cov8" title="1">{
                                                if i := len(loNPath) - off; utf8.RuneStart(loOld[i]) </span><span class="cov8" title="1">{
                                                        // read rune from cached lowercase path
                                                        rv, _ = utf8.DecodeRuneInString(loOld[i:])
                                                        break</span>
                                                }
                                        }

                                        // calculate lowercase bytes of current rune
                                        <span class="cov8" title="1">utf8.EncodeRune(rb[:], rv)
                                        // skipp already processed bytes
                                        rb = shiftNRuneBytes(rb, off)

                                        for i := 0; i &lt; len(n.indices); i++ </span><span class="cov8" title="1">{
                                                // lowercase matches
                                                if n.indices[i] == rb[0] </span><span class="cov8" title="1">{
                                                        // must use a recursive approach since both the
                                                        // uppercase byte and the lowercase byte might exist
                                                        // as an index
                                                        if out, found := n.children[i].findCaseInsensitivePathRec(
                                                                path, loPath, ciPath, rb, fixTrailingSlash,
                                                        ); found </span><span class="cov8" title="1">{
                                                                return out, true
                                                        }</span>
                                                        <span class="cov8" title="1">break</span>
                                                }
                                        }

                                        // same for uppercase rune, if it differs
                                        <span class="cov8" title="1">if up := unicode.ToUpper(rv); up != rv </span><span class="cov8" title="1">{
                                                utf8.EncodeRune(rb[:], up)
                                                rb = shiftNRuneBytes(rb, off)

                                                for i := 0; i &lt; len(n.indices); i++ </span><span class="cov8" title="1">{
                                                        // uppercase matches
                                                        if n.indices[i] == rb[0] </span><span class="cov8" title="1">{
                                                                // continue with child node
                                                                n = n.children[i]
                                                                loNPath = strings.ToLower(n.path)
                                                                continue walk</span>
                                                        }
                                                }
                                        }
                                }

                                // Nothing found. We can recommend to redirect to the same URL
                                // without a trailing slash if a leaf exists for that path
                                <span class="cov8" title="1">return ciPath, (fixTrailingSlash &amp;&amp; path == "/" &amp;&amp; n.route != nil)</span>
                        }

                        <span class="cov8" title="1">n = n.children[0]
                        switch n.nodeType </span>{
                        case param:<span class="cov8" title="1">
                                // find param end (either '/' or path end)
                                k := 0
                                for k &lt; len(path) &amp;&amp; path[k] != '/' </span><span class="cov8" title="1">{
                                        k++
                                }</span>

                                // add param value to case insensitive path
                                <span class="cov8" title="1">ciPath = append(ciPath, path[:k]...)

                                // we need to go deeper!
                                if k &lt; len(path) </span><span class="cov8" title="1">{
                                        if len(n.children) &gt; 0 </span><span class="cov8" title="1">{
                                                // continue with child node
                                                n = n.children[0]
                                                loNPath = strings.ToLower(n.path)
                                                loPath = loPath[k:]
                                                path = path[k:]
                                                continue</span>
                                        }

                                        // ... but we can't
                                        <span class="cov8" title="1">if fixTrailingSlash &amp;&amp; len(path) == k+1 </span><span class="cov8" title="1">{
                                                return ciPath, true
                                        }</span>
                                        <span class="cov8" title="1">return ciPath, false</span>
                                }

                                <span class="cov8" title="1">if n.route != nil </span><span class="cov8" title="1">{
                                        return ciPath, true
                                }</span> else<span class="cov8" title="1"> if fixTrailingSlash &amp;&amp; len(n.children) == 1 </span><span class="cov8" title="1">{
                                        // No handle found. Check if a handle for this path + a
                                        // trailing slash exists
                                        n = n.children[0]
                                        if n.path == "/" &amp;&amp; n.route != nil </span><span class="cov8" title="1">{
                                                return append(ciPath, '/'), true
                                        }</span>
                                }
                                <span class="cov8" title="1">return ciPath, false</span>

                        case catchAll:<span class="cov8" title="1">
                                return append(ciPath, path...), true</span>

                        default:<span class="cov8" title="1">
                                panic("invalid node type")</span>
                        }
                } else<span class="cov8" title="1"> {
                        // We should have reached the node containing the handle.
                        // Check if this node has a handle registered.
                        if n.route != nil </span><span class="cov8" title="1">{
                                return ciPath, true
                        }</span>

                        // No handle found.
                        // Try to fix the path by adding a trailing slash
                        <span class="cov8" title="1">if fixTrailingSlash </span><span class="cov8" title="1">{
                                for i := 0; i &lt; len(n.indices); i++ </span><span class="cov8" title="1">{
                                        if n.indices[i] == '/' </span><span class="cov8" title="1">{
                                                n = n.children[i]
                                                if (len(n.path) == 1 &amp;&amp; n.route != nil) ||
                                                        (n.nodeType == catchAll &amp;&amp; n.children[0].route != nil) </span><span class="cov8" title="1">{
                                                        return append(ciPath, '/'), true
                                                }</span>
                                                <span class="cov8" title="1">return ciPath, false</span>
                                        }
                                }
                        }
                        <span class="cov8" title="1">return ciPath, false</span>
                }
        }

        // Nothing found.
        // Try to fix the path by adding / removing a trailing slash
        <span class="cov8" title="1">if fixTrailingSlash </span><span class="cov8" title="1">{
                if path == "/" </span><span class="cov8" title="1">{
                        return ciPath, true
                }</span>
                <span class="cov8" title="1">if len(loPath)+1 == len(loNPath) &amp;&amp; loNPath[len(loPath)] == '/' &amp;&amp;
                        loPath[1:] == loNPath[1:len(loPath)] &amp;&amp; n.route != nil </span><span class="cov8" title="1">{
                        return append(ciPath, n.path...), true
                }</span>
        }
        <span class="cov8" title="1">return ciPath, false</span>
}

// CleanPath is the URL version of path.Clean, it returns a canonical URL path
// for p, eliminating . and .. elements.
//
// The following rules are applied iteratively until no further processing can
// be done:
//        1. Replace multiple slashes with a single slash.
//        2. Eliminate each . path name element (the current directory).
//        3. Eliminate each inner .. path name element (the parent directory)
//           along with the non-.. element that precedes it.
//        4. Eliminate .. elements that begin a rooted path:
//           that is, replace "/.." by "/" at the beginning of a path.
//
// If the result of this process is an empty string, "/" is returned
func CleanPath(p string) string <span class="cov0" title="0">{
        // Turn empty string into "/"
        if p == "" </span><span class="cov0" title="0">{
                return "/"
        }</span>

        <span class="cov0" title="0">n := len(p)
        var buf []byte

        // Invariants:
        //      reading from path; r is index of next byte to process.
        //      writing to buf; w is index of next byte to write.

        // path must start with '/'
        r := 1
        w := 1

        if p[0] != '/' </span><span class="cov0" title="0">{
                r = 0
                buf = make([]byte, n+1)
                buf[0] = '/'
        }</span>

        <span class="cov0" title="0">trailing := n &gt; 2 &amp;&amp; p[n-1] == '/'

        // A bit more clunky without a 'lazybuf' like the path package, but the loop
        // gets completely inlined (bufApp). So in contrast to the path package this
        // loop has no expensive function calls (except 1x make)

        for r &lt; n </span><span class="cov0" title="0">{
                switch </span>{
                case p[r] == '/':<span class="cov0" title="0">
                        // empty path element, trailing slash is added after the end
                        r++</span>

                case p[r] == '.' &amp;&amp; r+1 == n:<span class="cov0" title="0">
                        trailing = true
                        r++</span>

                case p[r] == '.' &amp;&amp; p[r+1] == '/':<span class="cov0" title="0">
                        // . element
                        r++</span>

                case p[r] == '.' &amp;&amp; p[r+1] == '.' &amp;&amp; (r+2 == n || p[r+2] == '/'):<span class="cov0" title="0">
                        // .. element: remove to last /
                        r += 2

                        if w &gt; 1 </span><span class="cov0" title="0">{
                                // can backtrack
                                w--

                                if buf == nil </span><span class="cov0" title="0">{
                                        for w &gt; 1 &amp;&amp; p[w] != '/' </span><span class="cov0" title="0">{
                                                w--
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        for w &gt; 1 &amp;&amp; buf[w] != '/' </span><span class="cov0" title="0">{
                                                w--
                                        }</span>
                                }
                        }

                default:<span class="cov0" title="0">
                        // real path element.
                        // add slash if needed
                        if w &gt; 1 </span><span class="cov0" title="0">{
                                bufApp(&amp;buf, p, w, '/')
                                w++
                        }</span>

                        // copy element
                        <span class="cov0" title="0">for r &lt; n &amp;&amp; p[r] != '/' </span><span class="cov0" title="0">{
                                bufApp(&amp;buf, p, w, p[r])
                                w++
                                r++
                        }</span>
                }
        }

        // re-append trailing slash
        <span class="cov0" title="0">if trailing &amp;&amp; w &gt; 1 </span><span class="cov0" title="0">{
                bufApp(&amp;buf, p, w, '/')
                w++
        }</span>

        <span class="cov0" title="0">if buf == nil </span><span class="cov0" title="0">{
                return p[:w]
        }</span>
        <span class="cov0" title="0">return string(buf[:w])</span>
}

// internal helper to lazily create a buffer if necessary
func bufApp(buf *[]byte, s string, w int, c byte) <span class="cov0" title="0">{
        if *buf == nil </span><span class="cov0" title="0">{
                if s[w] == c </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">*buf = make([]byte, len(s))
                copy(*buf, s[:w])</span>
        }
        <span class="cov0" title="0">(*buf)[w] = c</span>
}

func countParams(path string) uint8 <span class="cov8" title="1">{
        var n uint
        for i := 0; i &lt; len(path); i++ </span><span class="cov8" title="1">{
                if path[i] != ':' &amp;&amp; path[i] != '*' </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">n++</span>
        }
        <span class="cov8" title="1">if n &gt;= 255 </span><span class="cov8" title="1">{
                return 255
        }</span>
        <span class="cov8" title="1">return uint8(n)</span>
}

func min(a, b int) int <span class="cov8" title="1">{
        if a &lt;= b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}
</pre>
		
		<pre class="file" id="file165" style="display: none">package web

import (
        "crypto/hmac"
        cryptoRand "crypto/rand"
        "crypto/sha512"
        "encoding/base64"
        "encoding/json"
        "encoding/xml"
        "io"
        "net"
        "net/http"
        "net/url"
        "strconv"
        "strings"
        "time"

        "github.com/blend/go-sdk/exception"
        "github.com/blend/go-sdk/util"
)

// NestMiddleware reads the middleware variadic args and organizes the calls recursively in the order they appear.
func NestMiddleware(action Action, middleware ...Middleware) Action <span class="cov8" title="1">{
        if len(middleware) == 0 </span><span class="cov0" title="0">{
                return action
        }</span>

        <span class="cov8" title="1">var nest = func(a, b Middleware) Middleware </span><span class="cov8" title="1">{
                if b == nil </span><span class="cov8" title="1">{
                        return a
                }</span>
                <span class="cov8" title="1">return func(action Action) Action </span><span class="cov8" title="1">{
                        return a(b(action))
                }</span>
        }

        <span class="cov8" title="1">var metaAction Middleware
        for _, step := range middleware </span><span class="cov8" title="1">{
                metaAction = nest(step, metaAction)
        }</span>
        <span class="cov8" title="1">return metaAction(action)</span>
}

// WriteNoContent writes http.StatusNoContent for a request.
func WriteNoContent(w http.ResponseWriter) error <span class="cov0" title="0">{
        w.WriteHeader(http.StatusNoContent)
        w.Write([]byte{})
        return nil
}</span>

// WriteRawContent writes raw content for the request.
func WriteRawContent(w http.ResponseWriter, statusCode int, content []byte) error <span class="cov0" title="0">{
        w.WriteHeader(statusCode)
        _, err := w.Write(content)
        return exception.Wrap(err)
}</span>

// WriteJSON marshalls an object to json.
func WriteJSON(w http.ResponseWriter, r *http.Request, statusCode int, response interface{}) error <span class="cov8" title="1">{
        w.Header().Set(HeaderContentType, ContentTypeApplicationJSON)
        w.WriteHeader(statusCode)
        return exception.Wrap(json.NewEncoder(w).Encode(response))
}</span>

// WriteXML marshalls an object to json.
func WriteXML(w http.ResponseWriter, r *http.Request, statusCode int, response interface{}) error <span class="cov0" title="0">{
        w.Header().Set(HeaderContentType, ContentTypeXML)
        w.WriteHeader(statusCode)
        return exception.Wrap(xml.NewEncoder(w).Encode(response))
}</span>

// DeserializeReaderAsJSON deserializes a post body as json to a given object.
func DeserializeReaderAsJSON(object interface{}, body io.ReadCloser) error <span class="cov0" title="0">{
        defer body.Close()
        return exception.Wrap(json.NewDecoder(body).Decode(object))
}</span>

// LocalIP returns the local server ip.
func LocalIP() string <span class="cov0" title="0">{
        addrs, err := net.InterfaceAddrs()
        if err != nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">for _, address := range addrs </span><span class="cov0" title="0">{
                // check the address type and if it is not a loopback the display it
                if ipnet, ok := address.(*net.IPNet); ok &amp;&amp; !ipnet.IP.IsLoopback() </span><span class="cov0" title="0">{
                        if ipnet.IP.To4() != nil </span><span class="cov0" title="0">{
                                return ipnet.IP.String()
                        }</span>
                }
        }
        <span class="cov0" title="0">return ""</span>
}

// NewSessionID returns a new session id.
// It is not a uuid; session ids are generated using a secure random source.
// SessionIDs are generally 64 bytes.
func NewSessionID() string <span class="cov8" title="1">{
        return util.String.MustSecureRandom(32)
}</span>

// SignSessionID returns a new secure session id.
func SignSessionID(sessionID string, key []byte) ([]byte, error) <span class="cov8" title="1">{
        mac := hmac.New(sha512.New, key)
        _, err := mac.Write([]byte(sessionID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, exception.Wrap(err)
        }</span>
        <span class="cov8" title="1">return mac.Sum(nil), nil</span>
}

// MustSignSessionID signs a session id and panics if there is an issue.
func MustSignSessionID(sessionID string, key []byte) []byte <span class="cov8" title="1">{
        signed, err := SignSessionID(sessionID, key)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return signed</span>
}

// EncodeSignSessionID returns a new secure session id base64 encoded..
func EncodeSignSessionID(sessionID string, key []byte) (string, error) <span class="cov8" title="1">{
        signed, err := SignSessionID(sessionID, key)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return Base64Encode(signed), nil</span>
}

// MustEncodeSignSessionID returns a signed sessionID as base64 encoded.
// It panics if there is an error.
func MustEncodeSignSessionID(sessionID string, key []byte) string <span class="cov8" title="1">{
        return Base64Encode(MustSignSessionID(sessionID, key))
}</span>

// Base64Decode decodes a base64 string.
func Base64Decode(raw string) ([]byte, error) <span class="cov8" title="1">{
        return base64.URLEncoding.DecodeString(raw)
}</span>

// Base64Encode base64 encodes data.
func Base64Encode(raw []byte) string <span class="cov8" title="1">{
        return base64.URLEncoding.EncodeToString(raw)
}</span>

// GenerateCryptoKey generates a cryptographic key.
func GenerateCryptoKey(keySize int) []byte <span class="cov8" title="1">{
        key := make([]byte, keySize)
        io.ReadFull(cryptoRand.Reader, key)
        return key
}</span>

// GenerateSHA512Key generates a crypto key for SHA512 hashing.
func GenerateSHA512Key() []byte <span class="cov8" title="1">{
        return GenerateCryptoKey(64)
}</span>

// PortFromBindAddr returns a port number as an integer from a bind addr.
func PortFromBindAddr(bindAddr string) int32 <span class="cov8" title="1">{
        if len(bindAddr) == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">parts := strings.SplitN(bindAddr, ":", 2)
        if len(parts) == 0 </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">if len(parts) &lt; 2 </span><span class="cov8" title="1">{
                return ParseInt32(parts[0])
        }</span>
        <span class="cov8" title="1">return ParseInt32(parts[1])</span>
}

// ParseInt32 parses an int32.
func ParseInt32(v string) int32 <span class="cov8" title="1">{
        parsed, _ := strconv.Atoi(v)
        return int32(parsed)
}</span>

// NewMockRequest creates a mock request.
func NewMockRequest(method, path string) *http.Request <span class="cov8" title="1">{
        return &amp;http.Request{
                Method:     method,
                Proto:      "http",
                ProtoMajor: 1,
                ProtoMinor: 1,
                Host:       "localhost",
                URL: &amp;url.URL{
                        Scheme:  "http",
                        Host:    "localhost",
                        Path:    path,
                        RawPath: path,
                },
        }
}</span>

// NewBasicCookie returns a new name + value pair cookie.
func NewBasicCookie(name, value string) *http.Cookie <span class="cov8" title="1">{
        return &amp;http.Cookie{Name: name, Value: value}
}</span>

// ReadSetCookieByName returns a set cookie by name.
func ReadSetCookieByName(h http.Header, name string) *http.Cookie <span class="cov8" title="1">{
        cookies := ReadSetCookies(h)
        for _, cookie := range cookies </span><span class="cov8" title="1">{
                if cookie != nil &amp;&amp; cookie.Name == name </span><span class="cov8" title="1">{
                        return cookie
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// ReadSetCookies parses all "Set-Cookie" values from
// the header h and returns the successfully parsed Cookies.
func ReadSetCookies(h http.Header) []*http.Cookie <span class="cov8" title="1">{
        cookieCount := len(h["Set-Cookie"])
        if cookieCount == 0 </span><span class="cov0" title="0">{
                return []*http.Cookie{}
        }</span>
        <span class="cov8" title="1">cookies := make([]*http.Cookie, 0, cookieCount)
        for _, line := range h["Set-Cookie"] </span><span class="cov8" title="1">{
                parts := strings.Split(strings.TrimSpace(line), ";")
                if len(parts) == 1 &amp;&amp; parts[0] == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">parts[0] = strings.TrimSpace(parts[0])
                j := strings.Index(parts[0], "=")
                if j &lt; 0 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">name, value := parts[0][:j], parts[0][j+1:]
                if !isCookieNameValid(name) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">value, ok := parseCookieValue(value, true)
                if !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">c := &amp;http.Cookie{
                        Name:  name,
                        Value: value,
                        Raw:   line,
                }
                for i := 1; i &lt; len(parts); i++ </span><span class="cov8" title="1">{
                        parts[i] = strings.TrimSpace(parts[i])
                        if len(parts[i]) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">attr, val := parts[i], ""
                        if j := strings.Index(attr, "="); j &gt;= 0 </span><span class="cov8" title="1">{
                                attr, val = attr[:j], attr[j+1:]
                        }</span>
                        <span class="cov8" title="1">lowerAttr := strings.ToLower(attr)
                        val, ok = parseCookieValue(val, false)
                        if !ok </span><span class="cov0" title="0">{
                                c.Unparsed = append(c.Unparsed, parts[i])
                                continue</span>
                        }
                        <span class="cov8" title="1">switch lowerAttr </span>{
                        case "secure":<span class="cov0" title="0">
                                c.Secure = true
                                continue</span>
                        case "httponly":<span class="cov8" title="1">
                                c.HttpOnly = true
                                continue</span>
                        case "domain":<span class="cov0" title="0">
                                c.Domain = val
                                continue</span>
                        case "max-age":<span class="cov0" title="0">
                                secs, err := strconv.Atoi(val)
                                if err != nil || secs != 0 &amp;&amp; val[0] == '0' </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">if secs &lt;= 0 </span><span class="cov0" title="0">{
                                        secs = -1
                                }</span>
                                <span class="cov0" title="0">c.MaxAge = secs
                                continue</span>
                        case "expires":<span class="cov8" title="1">
                                c.RawExpires = val
                                exptime, err := time.Parse(time.RFC1123, val)
                                if err != nil </span><span class="cov0" title="0">{
                                        exptime, err = time.Parse("Mon, 02-Jan-2006 15:04:05 MST", val)
                                        if err != nil </span><span class="cov0" title="0">{
                                                c.Expires = time.Time{}
                                                break</span>
                                        }
                                }
                                <span class="cov8" title="1">c.Expires = exptime.UTC()
                                continue</span>
                        case "path":<span class="cov8" title="1">
                                c.Path = val
                                continue</span>
                        }
                        <span class="cov0" title="0">c.Unparsed = append(c.Unparsed, parts[i])</span>
                }
                <span class="cov8" title="1">cookies = append(cookies, c)</span>
        }
        <span class="cov8" title="1">return cookies</span>
}

func parseCookieValue(raw string, allowDoubleQuote bool) (string, bool) <span class="cov8" title="1">{
        // Strip the quotes, if present.
        if allowDoubleQuote &amp;&amp; len(raw) &gt; 1 &amp;&amp; raw[0] == '"' &amp;&amp; raw[len(raw)-1] == '"' </span><span class="cov0" title="0">{
                raw = raw[1 : len(raw)-1]
        }</span>
        <span class="cov8" title="1">for i := 0; i &lt; len(raw); i++ </span><span class="cov8" title="1">{
                if !validCookieValueByte(raw[i]) </span><span class="cov0" title="0">{
                        return "", false
                }</span>
        }
        <span class="cov8" title="1">return raw, true</span>
}

func validCookiePathByte(b byte) bool <span class="cov0" title="0">{
        return 0x20 &lt;= b &amp;&amp; b &lt; 0x7f &amp;&amp; b != ';'
}</span>

func validCookieValueByte(b byte) bool <span class="cov8" title="1">{
        return 0x20 &lt;= b &amp;&amp; b &lt; 0x7f &amp;&amp; b != '"' &amp;&amp; b != ';' &amp;&amp; b != '\\'
}</span>

func isCookieNameValid(raw string) bool <span class="cov8" title="1">{
        if raw == "" </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return strings.IndexFunc(raw, isNotToken) &lt; 0</span>
}

var isTokenTable = [127]bool{
        '!':  true,
        '#':  true,
        '$':  true,
        '%':  true,
        '&amp;':  true,
        '\'': true,
        '*':  true,
        '+':  true,
        '-':  true,
        '.':  true,
        '0':  true,
        '1':  true,
        '2':  true,
        '3':  true,
        '4':  true,
        '5':  true,
        '6':  true,
        '7':  true,
        '8':  true,
        '9':  true,
        'A':  true,
        'B':  true,
        'C':  true,
        'D':  true,
        'E':  true,
        'F':  true,
        'G':  true,
        'H':  true,
        'I':  true,
        'J':  true,
        'K':  true,
        'L':  true,
        'M':  true,
        'N':  true,
        'O':  true,
        'P':  true,
        'Q':  true,
        'R':  true,
        'S':  true,
        'T':  true,
        'U':  true,
        'W':  true,
        'V':  true,
        'X':  true,
        'Y':  true,
        'Z':  true,
        '^':  true,
        '_':  true,
        '`':  true,
        'a':  true,
        'b':  true,
        'c':  true,
        'd':  true,
        'e':  true,
        'f':  true,
        'g':  true,
        'h':  true,
        'i':  true,
        'j':  true,
        'k':  true,
        'l':  true,
        'm':  true,
        'n':  true,
        'o':  true,
        'p':  true,
        'q':  true,
        'r':  true,
        's':  true,
        't':  true,
        'u':  true,
        'v':  true,
        'w':  true,
        'x':  true,
        'y':  true,
        'z':  true,
        '|':  true,
        '~':  true,
}

func isToken(r rune) bool <span class="cov8" title="1">{
        i := int(r)
        return i &lt; len(isTokenTable) &amp;&amp; isTokenTable[i]
}</span>

func isNotToken(r rune) bool <span class="cov8" title="1">{
        return !isToken(r)
}</span>
</pre>
		
		<pre class="file" id="file166" style="display: none">package web

import (
        "bytes"
        "encoding/json"
        "fmt"
        "html/template"
        "strings"
        "time"

        "github.com/blend/go-sdk/exception"
)

// NewViewCache returns a new view cache.
func NewViewCache() *ViewCache <span class="cov8" title="1">{
        return &amp;ViewCache{
                viewFuncMap: viewUtils(),
                viewCache:   template.New(""),
                cached:      true,
        }
}</span>

// NewViewCacheFromConfig returns a new view cache from a config.
func NewViewCacheFromConfig(cfg *ViewCacheConfig) *ViewCache <span class="cov8" title="1">{
        return &amp;ViewCache{
                viewFuncMap: viewUtils(),
                viewCache:   template.New(""),
                viewPaths:   cfg.GetPaths(),
                cached:      cfg.GetCached(),
        }
}</span>

// NewViewCacheWithTemplates creates a new view cache wrapping the templates.
func NewViewCacheWithTemplates(templates *template.Template) *ViewCache <span class="cov0" title="0">{
        return &amp;ViewCache{
                viewFuncMap: viewUtils(),
                viewCache:   templates,
                cached:      true,
        }
}</span>

// ViewCache is the cached views used in view results.
type ViewCache struct {
        viewFuncMap  template.FuncMap
        viewPaths    []string
        viewLiterals []string
        viewCache    *template.Template
        cached       bool
}

// SetCached sets if we should cache views once they're compiled, or always read them from disk.
// Cached == True, use in memory storage for views
// Cached == False, read the file from disk every time we want to render the view.
func (vc *ViewCache) SetCached(cached bool) <span class="cov0" title="0">{
        if vc == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">vc.cached = cached</span>
}

// Cached indicates if the cache is enabled, or if we skip parsing views each load.
// Cached == True, use in memory storage for views
// Cached == False, read the file from disk every time we want to render the view.
func (vc *ViewCache) Cached() bool <span class="cov8" title="1">{
        if vc == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return vc.cached</span>
}

// Initialize caches templates by path.
func (vc *ViewCache) Initialize() error <span class="cov8" title="1">{
        if len(vc.viewPaths) == 0 &amp;&amp; len(vc.viewLiterals) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">views, err := vc.Parse()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">vc.viewCache = views
        return nil</span>
}

// Parse parses the view tree.
func (vc *ViewCache) Parse() (views *template.Template, err error) <span class="cov8" title="1">{
        views = template.New("").Funcs(vc.viewFuncMap)
        if len(vc.viewPaths) &gt; 0 </span><span class="cov8" title="1">{
                views, err = views.ParseFiles(vc.viewPaths...)
                if err != nil </span><span class="cov0" title="0">{
                        err = exception.Wrap(err)
                        return
                }</span>
        }

        <span class="cov8" title="1">if len(vc.viewLiterals) &gt; 0 </span><span class="cov8" title="1">{
                for _, viewLiteral := range vc.viewLiterals </span><span class="cov8" title="1">{
                        views, err = views.Parse(viewLiteral)
                        if err != nil </span><span class="cov0" title="0">{
                                err = exception.Wrap(err)
                                return
                        }</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

// AddPaths adds paths to the view collection.
func (vc *ViewCache) AddPaths(paths ...string) <span class="cov8" title="1">{
        if vc == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">vc.viewPaths = append(vc.viewPaths, paths...)</span>
}

// AddLiterals adds view literal strings to the view collection.
func (vc *ViewCache) AddLiterals(views ...string) <span class="cov8" title="1">{
        if vc == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">vc.viewLiterals = append(vc.viewLiterals, views...)</span>
}

// SetPaths sets the view paths outright.
func (vc *ViewCache) SetPaths(paths ...string) <span class="cov0" title="0">{
        if vc == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">vc.viewPaths = paths</span>
}

// SetLiterals sets the raw views outright.
func (vc *ViewCache) SetLiterals(viewLiterals ...string) <span class="cov0" title="0">{
        if vc == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">vc.viewLiterals = viewLiterals</span>
}

// Paths returns the view paths.
func (vc *ViewCache) Paths() []string <span class="cov0" title="0">{
        if vc == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return vc.viewPaths</span>
}

// FuncMap returns the global view func map.
func (vc *ViewCache) FuncMap() template.FuncMap <span class="cov0" title="0">{
        if vc == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return vc.viewFuncMap</span>
}

// Templates gets the view cache for the app.
func (vc *ViewCache) Templates() *template.Template <span class="cov8" title="1">{
        if vc == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return vc.viewCache</span>
}

// SetTemplates sets the view cache for the app.
func (vc *ViewCache) SetTemplates(viewCache *template.Template) <span class="cov8" title="1">{
        if vc == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">vc.viewCache = viewCache</span>
}

func viewUtils() template.FuncMap <span class="cov8" title="1">{
        return template.FuncMap{
                "short": func(t time.Time) string </span><span class="cov0" title="0">{
                        return t.Format("1/02/2006 3:04:05 PM")
                }</span>,
                "shortDate": func(t time.Time) string <span class="cov0" title="0">{
                        return t.Format("1/02/2006")
                }</span>,
                "medium": func(t time.Time) string <span class="cov0" title="0">{
                        return t.Format("Jan 02, 2006 3:04:05 PM")
                }</span>,
                "kitchen": func(t time.Time) string <span class="cov0" title="0">{
                        return t.Format(time.Kitchen)
                }</span>,
                "monthDate": func(t time.Time) string <span class="cov0" title="0">{
                        return t.Format("1/2")
                }</span>,
                "money": func(d float64) string <span class="cov0" title="0">{
                        return fmt.Sprintf("$%0.2f", d)
                }</span>,
                "duration": func(d time.Duration) string <span class="cov0" title="0">{
                        if d &gt; time.Hour </span><span class="cov0" title="0">{
                                return fmt.Sprintf("%0.2fh", float64(d)/float64(time.Hour))
                        }</span>
                        <span class="cov0" title="0">if d &gt; time.Minute </span><span class="cov0" title="0">{
                                return fmt.Sprintf("%0.2fm", float64(d)/float64(time.Minute))
                        }</span>
                        <span class="cov0" title="0">if d &gt; time.Second </span><span class="cov0" title="0">{
                                return fmt.Sprintf("%0.2fs", float64(d)/float64(time.Second))
                        }</span>
                        <span class="cov0" title="0">if d &gt; time.Millisecond </span><span class="cov0" title="0">{
                                return fmt.Sprintf("%0.2fms", float64(d)/float64(time.Millisecond))
                        }</span>
                        <span class="cov0" title="0">if d &gt; time.Microsecond </span><span class="cov0" title="0">{
                                return fmt.Sprintf("%0.2fs", float64(d)/float64(time.Microsecond))
                        }</span>
                        <span class="cov0" title="0">return fmt.Sprintf("%dns", d)</span>
                },
                "pct": func(v float64) string <span class="cov0" title="0">{
                        return fmt.Sprintf("%0.2f%%", v*100)
                }</span>,
                "csv": func(items []string) string <span class="cov0" title="0">{
                        return strings.Join(items, ", ")
                }</span>,
                "json": func(v interface{}) (string, error) <span class="cov0" title="0">{
                        contents, err := json.Marshal(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov0" title="0">return string(contents), nil</span>
                },
                "jsonPretty": func(v interface{}) (string, error) <span class="cov0" title="0">{
                        buf := bytes.NewBuffer(nil)
                        encoder := json.NewEncoder(buf)
                        encoder.SetIndent("", "\t")
                        err := encoder.Encode(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                        <span class="cov0" title="0">return buf.String(), nil</span>
                },
        }
}
</pre>
		
		<pre class="file" id="file167" style="display: none">package web

import "github.com/blend/go-sdk/util"

// ViewCacheConfig is a config for the view cache.
type ViewCacheConfig struct {
        Cached *bool    `json:"cached" yaml:"cached" env:"VIEW_CACHE_ENABLED"`
        Paths  []string `json:"paths" yaml:"paths" env:"VIEW_CACHE_PATHS,csv"`
}

// GetCached returns if the viewcache should store templates in memory or read from disk.
func (vcc ViewCacheConfig) GetCached(defaults ...bool) bool <span class="cov8" title="1">{
        return util.Coalesce.Bool(vcc.Cached, true, defaults...)
}</span>

// GetPaths returns default view paths.
func (vcc ViewCacheConfig) GetPaths(defaults ...[]string) []string <span class="cov8" title="1">{
        return util.Coalesce.Strings(vcc.Paths, nil, defaults...)
}</span>
</pre>
		
		<pre class="file" id="file168" style="display: none">package web

import (
        "github.com/blend/go-sdk/env"
        "github.com/blend/go-sdk/uuid"
)

// ViewModel is a wrapping viewmodel.
type ViewModel struct {
        Ctx       *Ctx
        ViewModel interface{}
}

// HasEnv returns if an env var is set.
func (vm *ViewModel) HasEnv(key string) bool <span class="cov0" title="0">{
        return env.Env().Has(key)
}</span>

// Env returns a value from the environment.
func (vm *ViewModel) Env(key string, defaults ...string) string <span class="cov0" title="0">{
        return env.Env().String(key, defaults...)
}</span>

// UUIDv4 returns a uuidv4 as a string.
func (vm *ViewModel) UUIDv4() string <span class="cov0" title="0">{
        return uuid.V4().String()
}</span>
</pre>
		
		<pre class="file" id="file169" style="display: none">package web

import (
        "bytes"
        "html/template"

        "github.com/blend/go-sdk/exception"
)

// ViewResult is a result that renders a view.
type ViewResult struct {
        StatusCode int
        ViewModel  interface{}
        Template   *template.Template
        Provider   *ViewResultProvider
}

// Render renders the result to the given response writer.
func (vr *ViewResult) Render(ctx *Ctx) (err error) <span class="cov8" title="1">{
        if vr.Template == nil </span><span class="cov0" title="0">{
                err = exception.New(ErrUnsetViewTemplate)
                return
        }</span>
        <span class="cov8" title="1">ctx.Response().Header().Set(HeaderContentType, ContentTypeHTML)
        buffer := bytes.NewBuffer([]byte{})
        err = vr.Template.Execute(buffer, &amp;ViewModel{
                Ctx:       ctx,
                ViewModel: vr.ViewModel,
        })
        if err != nil </span><span class="cov8" title="1">{
                if vr.Provider != nil </span><span class="cov0" title="0">{
                        err = vr.Provider.InternalError(err).Render(ctx)
                        return
                }</span>
                <span class="cov8" title="1">err = exception.Wrap(err)
                return</span>
        }

        <span class="cov8" title="1">ctx.Response().WriteHeader(vr.StatusCode)
        _, err = ctx.Response().Write(buffer.Bytes())
        if err != nil &amp;&amp; ctx != nil &amp;&amp; ctx.Logger() != nil </span><span class="cov0" title="0">{
                ctx.Logger().Error(err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file170" style="display: none">package web

import (
        "html/template"
        "net/http"

        "github.com/blend/go-sdk/exception"
        "github.com/blend/go-sdk/logger"
)

const (
        // DefaultTemplateNameBadRequest is the default template name for bad request view results.
        DefaultTemplateNameBadRequest = "bad_request"

        // DefaultTemplateNameInternalError is the default template name for internal server error view results.
        DefaultTemplateNameInternalError = "error"

        // DefaultTemplateNameNotFound is the default template name for not found error view results.
        DefaultTemplateNameNotFound = "not_found"

        // DefaultTemplateNameNotAuthorized is the default template name for not authorized error view results.
        DefaultTemplateNameNotAuthorized = "not_authorized"

        // DefaultTemplateBadRequest is a basic view.
        DefaultTemplateBadRequest = `&lt;html&gt;&lt;head&gt;&lt;style&gt;body { font-family: sans-serif; text-align: center; }&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h4&gt;Bad Request&lt;/h4&gt;&lt;/body&gt;&lt;pre&gt;{{ .ViewModel }}&lt;/pre&gt;&lt;/html&gt;`

        // DefaultTemplateInternalError is a basic view.
        DefaultTemplateInternalError = `&lt;html&gt;&lt;head&gt;&lt;style&gt;body { font-family: sans-serif; text-align: center; }&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h4&gt;Internal Error&lt;/h4&gt;&lt;pre&gt;{{ .ViewModel }}&lt;/body&gt;&lt;/html&gt;`

        // DefaultTemplateNotAuthorized is a basic view.
        DefaultTemplateNotAuthorized = `&lt;html&gt;&lt;head&gt;&lt;style&gt;body { font-family: sans-serif; text-align: center; }&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h4&gt;Not Authorized&lt;/h4&gt;&lt;/body&gt;&lt;/html&gt;`

        // DefaultTemplateNotFound is a basic view.
        DefaultTemplateNotFound = `&lt;html&gt;&lt;head&gt;&lt;style&gt;body { font-family: sans-serif; text-align: center; }&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h4&gt;Not Found&lt;/h4&gt;&lt;/body&gt;&lt;/html&gt;`
)

// NewViewResultProvider creates a new ViewResults object.
func NewViewResultProvider(log *logger.Logger, vc *ViewCache) *ViewResultProvider <span class="cov8" title="1">{
        return &amp;ViewResultProvider{log: log, views: vc}
}</span>

// ViewResultProvider returns results based on views.
type ViewResultProvider struct {
        log                       *logger.Logger
        badRequestTemplateName    string
        internalErrorTemplateName string
        notFoundTemplateName      string
        notAuthorizedTemplateName string
        views                     *ViewCache
}

// WithBadRequestTemplateName sets the bad request template.
func (vr *ViewResultProvider) WithBadRequestTemplateName(templateName string) *ViewResultProvider <span class="cov0" title="0">{
        vr.badRequestTemplateName = templateName
        return vr
}</span>

// BadRequestTemplateName returns the bad request template.
func (vr *ViewResultProvider) BadRequestTemplateName() string <span class="cov8" title="1">{
        if len(vr.badRequestTemplateName) &gt; 0 </span><span class="cov0" title="0">{
                return vr.badRequestTemplateName
        }</span>
        <span class="cov8" title="1">return DefaultTemplateNameBadRequest</span>
}

// WithInternalErrorTemplateName sets the bad request template.
func (vr *ViewResultProvider) WithInternalErrorTemplateName(templateName string) *ViewResultProvider <span class="cov0" title="0">{
        vr.internalErrorTemplateName = templateName
        return vr
}</span>

// InternalErrorTemplateName returns the bad request template.
func (vr *ViewResultProvider) InternalErrorTemplateName() string <span class="cov8" title="1">{
        if len(vr.internalErrorTemplateName) &gt; 0 </span><span class="cov0" title="0">{
                return vr.internalErrorTemplateName
        }</span>
        <span class="cov8" title="1">return DefaultTemplateNameInternalError</span>
}

// WithNotFoundTemplateName sets the not found request template name.
func (vr *ViewResultProvider) WithNotFoundTemplateName(templateName string) *ViewResultProvider <span class="cov0" title="0">{
        vr.notFoundTemplateName = templateName
        return vr
}</span>

// NotFoundTemplateName returns the not found template name.
func (vr *ViewResultProvider) NotFoundTemplateName() string <span class="cov8" title="1">{
        if len(vr.notFoundTemplateName) &gt; 0 </span><span class="cov0" title="0">{
                return vr.notFoundTemplateName
        }</span>
        <span class="cov8" title="1">return DefaultTemplateNameNotFound</span>
}

// WithNotAuthorizedTemplateName sets the bad request template.
func (vr *ViewResultProvider) WithNotAuthorizedTemplateName(templateName string) *ViewResultProvider <span class="cov0" title="0">{
        vr.notAuthorizedTemplateName = templateName
        return vr
}</span>

// NotAuthorizedTemplateName returns the bad request template name.
func (vr *ViewResultProvider) NotAuthorizedTemplateName() string <span class="cov8" title="1">{
        if len(vr.notAuthorizedTemplateName) &gt; 0 </span><span class="cov0" title="0">{
                return vr.notAuthorizedTemplateName
        }</span>
        <span class="cov8" title="1">return DefaultTemplateNameNotAuthorized</span>
}

// BadRequest returns a view result.
func (vr *ViewResultProvider) BadRequest(err error) Result <span class="cov8" title="1">{
        if vr.log != nil </span><span class="cov0" title="0">{
                vr.log.Warning(err)
        }</span>

        <span class="cov8" title="1">temp := vr.views.Templates().Lookup(vr.BadRequestTemplateName())
        if temp == nil </span><span class="cov8" title="1">{
                temp, _ = template.New("").Parse(DefaultTemplateBadRequest)
        }</span>

        <span class="cov8" title="1">return &amp;ViewResult{
                StatusCode: http.StatusBadRequest,
                ViewModel:  err,
                Template:   temp,
        }</span>
}

// InternalError returns a view result.
func (vr *ViewResultProvider) InternalError(err error) Result <span class="cov8" title="1">{
        if vr.log != nil </span><span class="cov8" title="1">{
                vr.log.Fatal(err)
        }</span>

        <span class="cov8" title="1">temp := vr.views.Templates().Lookup(vr.InternalErrorTemplateName())
        if temp == nil </span><span class="cov8" title="1">{
                temp, _ = template.New("").Parse(DefaultTemplateInternalError)
        }</span>

        <span class="cov8" title="1">return &amp;ViewResult{
                StatusCode: http.StatusInternalServerError,
                ViewModel:  err,
                Template:   temp,
        }</span>
}

// NotFound returns a view result.
func (vr *ViewResultProvider) NotFound() Result <span class="cov8" title="1">{
        temp := vr.views.Templates().Lookup(vr.NotFoundTemplateName())
        if temp == nil </span><span class="cov8" title="1">{
                temp, _ = template.New("").Parse(DefaultTemplateNotFound)
        }</span>

        <span class="cov8" title="1">return &amp;ViewResult{
                StatusCode: http.StatusNotFound,
                Template:   temp,
        }</span>
}

// NotAuthorized returns a view result.
func (vr *ViewResultProvider) NotAuthorized() Result <span class="cov8" title="1">{
        temp := vr.views.Templates().Lookup(vr.NotAuthorizedTemplateName())
        if temp == nil </span><span class="cov8" title="1">{
                temp, _ = template.New("").Parse(DefaultTemplateNotAuthorized)
        }</span>

        <span class="cov8" title="1">return &amp;ViewResult{
                StatusCode: http.StatusForbidden,
                Template:   temp,
        }</span>
}

// View returns a view result.
func (vr *ViewResultProvider) View(viewName string, viewModel interface{}) Result <span class="cov8" title="1">{
        temp := vr.views.Templates().Lookup(viewName)
        if temp == nil </span><span class="cov8" title="1">{
                return vr.InternalError(exception.NewFromErr(ErrUnsetViewTemplate).WithMessagef("template: %s", viewName))
        }</span>
        <span class="cov8" title="1">return &amp;ViewResult{
                StatusCode: http.StatusOK,
                ViewModel:  viewModel,
                Provider:   vr,
                Template:   temp,
        }</span>
}
</pre>
		
		<pre class="file" id="file171" style="display: none">package web

// XMLResult is a json result.
type XMLResult struct {
        StatusCode int
        Response   interface{}
}

// Render renders the result
func (ar *XMLResult) Render(ctx *Ctx) error <span class="cov0" title="0">{
        return WriteXML(ctx.Response(), ctx.Request(), ar.StatusCode, ar.Response)
}</span>
</pre>
		
		<pre class="file" id="file172" style="display: none">package web

import (
        "net/http"

        "github.com/blend/go-sdk/logger"
)

// NewXMLResultProvider Creates a new JSONResults object.
func NewXMLResultProvider(log *logger.Logger) *XMLResultProvider <span class="cov0" title="0">{
        return &amp;XMLResultProvider{log: log}
}</span>

// XMLResultProvider are context results for api methods.
type XMLResultProvider struct {
        log *logger.Logger
}

// NotFound returns a service response.
func (xrp *XMLResultProvider) NotFound() Result <span class="cov0" title="0">{
        return &amp;XMLResult{
                StatusCode: http.StatusNotFound,
                Response:   "Not Found",
        }
}</span>

// NotAuthorized returns a service response.
func (xrp *XMLResultProvider) NotAuthorized() Result <span class="cov0" title="0">{
        return &amp;XMLResult{
                StatusCode: http.StatusForbidden,
                Response:   "Not Authorized",
        }
}</span>

// InternalError returns a service response.
func (xrp *XMLResultProvider) InternalError(err error) Result <span class="cov0" title="0">{
        if xrp.log != nil </span><span class="cov0" title="0">{
                xrp.log.Fatal(err)
        }</span>

        <span class="cov0" title="0">return &amp;XMLResult{
                StatusCode: http.StatusInternalServerError,
                Response:   err.Error(),
        }</span>
}

// BadRequest returns a service response.
func (xrp *XMLResultProvider) BadRequest(err error) Result <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                return &amp;XMLResult{
                        StatusCode: http.StatusBadRequest,
                        Response:   err,
                }
        }</span>
        <span class="cov0" title="0">return &amp;XMLResult{
                StatusCode: http.StatusBadRequest,
                Response:   "Bad Request",
        }</span>
}

// OK returns a service response.
func (xrp *XMLResultProvider) OK() Result <span class="cov0" title="0">{
        return &amp;XMLResult{
                StatusCode: http.StatusOK,
                Response:   "OK!",
        }
}</span>

// Result returns an xml response.
func (xrp *XMLResultProvider) Result(response interface{}) Result <span class="cov0" title="0">{
        return &amp;XMLResult{
                StatusCode: http.StatusOK,
                Response:   response,
        }
}</span>
</pre>
		
		<pre class="file" id="file173" style="display: none">package worker

import "time"

// NewInterval returns a new worker that runs an action on an interval.
func NewInterval(action func() error, interval time.Duration) *Interval <span class="cov8" title="1">{
        return &amp;Interval{
                interval: interval,
                action:   action,
                latch:    &amp;Latch{},
        }
}</span>

// Interval is a managed goroutine that does things.
type Interval struct {
        interval time.Duration
        action   func() error
        latch    *Latch
        errors   chan error
}

// Interval returns the interval for the ticker.
func (i Interval) Interval() time.Duration <span class="cov0" title="0">{
        return i.interval
}</span>

// Latch returns the inteval worker latch.
func (i *Interval) Latch() *Latch <span class="cov8" title="1">{
        return i.latch
}</span>

// WithAction sets the interval action.
func (i *Interval) WithAction(action func() error) *Interval <span class="cov0" title="0">{
        i.action = action
        return i
}</span>

// Action returns the interval action.
func (i *Interval) Action() func() error <span class="cov0" title="0">{
        return i.action
}</span>

// WithErrors returns the error channel.
func (i *Interval) WithErrors(errors chan error) *Interval <span class="cov0" title="0">{
        i.errors = errors
        return i
}</span>

// Errors returns a channel to read action errors from.
func (i *Interval) Errors() chan error <span class="cov0" title="0">{
        return i.errors
}</span>

// Start starts the worker.
func (i *Interval) Start() <span class="cov8" title="1">{
        i.latch.SignalStarting()
        go func() </span><span class="cov8" title="1">{
                i.latch.SignalStarted()
                tick := time.Tick(i.interval)
                var err error
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-tick:<span class="cov8" title="1">
                                err = i.action()
                                if err != nil &amp;&amp; i.errors != nil </span><span class="cov0" title="0">{
                                        i.errors &lt;- err
                                }</span>
                        case &lt;-i.latch.ShouldStop():<span class="cov8" title="1">
                                i.latch.SignalStopped()
                                return</span>
                        }
                }
        }()
        <span class="cov8" title="1">&lt;-i.latch.Started()</span>
}

// Stop stops the worker.
func (i *Interval) Stop() <span class="cov8" title="1">{
        i.latch.Stop()
        &lt;-i.latch.Stopped()
}</span>
</pre>
		
		<pre class="file" id="file174" style="display: none">package worker

import (
        "sync"
        "sync/atomic"
)

// Latch is a helper to coordinate killing goroutines.
// The lifecycle is generally as follows.
// 0 - stopped
// 1 - signal started
// 2 - running / started
// N-2 - signal stop
// N-1 - stopping
// goto 0
type Latch struct {
        starting int32
        running  int32
        stopping int32

        signalLock sync.Mutex
        started    chan struct{}
        shouldStop chan struct{}
        stopped    chan struct{}
}

// IsStopped returns if the latch is stopped.
func (l *Latch) IsStopped() bool <span class="cov8" title="1">{
        return atomic.LoadInt32(&amp;l.starting) == 0 &amp;&amp;
                atomic.LoadInt32(&amp;l.running) == 0 &amp;&amp;
                atomic.LoadInt32(&amp;l.stopping) == 0
}</span>

// IsStarting indicates the latch is waiting to be scheduled.
func (l *Latch) IsStarting() bool <span class="cov8" title="1">{
        return atomic.LoadInt32(&amp;l.starting) == 1
}</span>

// IsRunning indicates we can signal to stop.
func (l *Latch) IsRunning() bool <span class="cov8" title="1">{
        return atomic.LoadInt32(&amp;l.running) == 1
}</span>

// IsStopping returns if the latch is waiting to finish stopping.
func (l *Latch) IsStopping() bool <span class="cov8" title="1">{
        return atomic.LoadInt32(&amp;l.stopping) == 1
}</span>

// Started returns the started signal.
// It is used to coordinate the transition from starting -&gt; started.
func (l *Latch) Started() &lt;-chan struct{} <span class="cov8" title="1">{
        return l.started
}</span>

// ShouldStop returns the should stop signal.
// It is used to trigger the transition from running -&gt; stopping -&gt; stopped.
func (l *Latch) ShouldStop() &lt;-chan struct{} <span class="cov8" title="1">{
        return l.shouldStop
}</span>

// Stopped returns the stopped signal.
// It is used to coordinate the transition from stopping -&gt; stopped.
func (l *Latch) Stopped() &lt;-chan struct{} <span class="cov8" title="1">{
        return l.stopped
}</span>

// SignalStarting signals the latch is starting.
// This is typically done before you kick off a goroutine.
func (l *Latch) SignalStarting() <span class="cov8" title="1">{
        l.signalLock.Lock()
        defer l.signalLock.Unlock()
        if !l.IsStopped() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">atomic.StoreInt32(&amp;l.starting, 1)
        atomic.StoreInt32(&amp;l.running, 0)
        atomic.StoreInt32(&amp;l.stopping, 0)
        l.started = make(chan struct{})</span>
}

// SignalStarted signals that the latch is started and has entered
// the `IsRunning` state.
func (l *Latch) SignalStarted() <span class="cov8" title="1">{
        l.signalLock.Lock()
        defer l.signalLock.Unlock()

        if !l.IsStarting() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">atomic.StoreInt32(&amp;l.starting, 0)
        atomic.StoreInt32(&amp;l.running, 1)
        atomic.StoreInt32(&amp;l.stopping, 0)
        l.shouldStop = make(chan struct{})
        close(l.started)</span>
}

// Stop signals the latch to stop.
// It could also be thought of as `SignalStopping`.
func (l *Latch) Stop() <span class="cov8" title="1">{
        l.signalLock.Lock()
        defer l.signalLock.Unlock()

        if !l.IsRunning() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">atomic.StoreInt32(&amp;l.starting, 0)
        atomic.StoreInt32(&amp;l.running, 0)
        atomic.StoreInt32(&amp;l.stopping, 1)

        l.stopped = make(chan struct{})
        close(l.shouldStop)</span>
}

// SignalStopped signals the latch has stopped.
func (l *Latch) SignalStopped() <span class="cov8" title="1">{
        l.signalLock.Lock()
        defer l.signalLock.Unlock()

        if !l.IsStopping() </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">atomic.StoreInt32(&amp;l.starting, 0)
        atomic.StoreInt32(&amp;l.running, 0)
        atomic.StoreInt32(&amp;l.stopping, 0)
        close(l.stopped)</span>
}
</pre>
		
		<pre class="file" id="file175" style="display: none">package worker

const (
        // DefaultQueueWorkerMaxWork is the maximum number of work items before queueing blocks.
        DefaultQueueWorkerMaxWork = 1 &lt;&lt; 10
)

// NewQueue returns a new queue worker.
func NewQueue(action func(interface{}) error) *QueueWorker <span class="cov8" title="1">{
        return &amp;QueueWorker{
                action:  action,
                latch:   &amp;Latch{},
                maxWork: DefaultQueueWorkerMaxWork,
        }
}</span>

// QueueWorker is a worker that is pushed work over a channel.
type QueueWorker struct {
        action  func(interface{}) error
        latch   *Latch
        errors  chan error
        work    chan interface{}
        maxWork int
}

// WithMaxWork sets the worker max work.
func (qw *QueueWorker) WithMaxWork(maxWork int) *QueueWorker <span class="cov0" title="0">{
        qw.maxWork = maxWork
        return qw
}</span>

// MaxWork returns the maximum work.
func (qw *QueueWorker) MaxWork() int <span class="cov0" title="0">{
        return qw.maxWork
}</span>

// Latch returns the worker latch.
func (qw *QueueWorker) Latch() *Latch <span class="cov8" title="1">{
        return qw.latch
}</span>

// WithErrorCollector returns the error channel.
func (qw *QueueWorker) WithErrorCollector(errors chan error) *QueueWorker <span class="cov0" title="0">{
        qw.errors = errors
        return qw
}</span>

// ErrorCollector returns a channel to read action errors from.
func (qw *QueueWorker) ErrorCollector() chan error <span class="cov0" title="0">{
        return qw.errors
}</span>

// Enqueue adds an item to the work queue.
func (qw *QueueWorker) Enqueue(obj interface{}) <span class="cov8" title="1">{
        if qw.work == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">qw.work &lt;- obj</span>
}

// Start starts the worker.
func (qw *QueueWorker) Start() <span class="cov8" title="1">{
        qw.latch.SignalStarting()
        if qw.maxWork &gt; 0 </span><span class="cov8" title="1">{
                qw.work = make(chan interface{}, qw.maxWork)
        }</span> else<span class="cov0" title="0"> {
                qw.work = make(chan interface{})
        }</span>

        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                qw.latch.SignalStarted()
                var err error
                var workItem interface{}
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case workItem = &lt;-qw.work:<span class="cov8" title="1">
                                err = qw.action(workItem)
                                if err != nil &amp;&amp; qw.errors != nil </span><span class="cov0" title="0">{
                                        qw.errors &lt;- err
                                }</span>
                        case &lt;-qw.latch.ShouldStop():<span class="cov8" title="1">
                                qw.latch.SignalStopped()
                                return</span>
                        }
                }
        }()
        <span class="cov8" title="1">&lt;-qw.latch.Started()</span>
}

// Stop stops the worker.
func (qw *QueueWorker) Stop() <span class="cov8" title="1">{
        qw.latch.Stop()
        &lt;-qw.latch.Stopped()
}</span>
</pre>
		
		<pre class="file" id="file176" style="display: none">package workqueue

import (
        "fmt"

        "github.com/blend/go-sdk/exception"
)

// Entry is an individual item of work.
type Entry struct {
        Action  Action
        Args    []interface{}
        Tries   int32
        Recover bool
}

func (e Entry) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("{ %#v args: %v tries: %d }", e.Action, e.Args, e.Tries)
}</span>

// Execute runs the work item.
func (e Entry) Execute() (err error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if e.Recover </span><span class="cov8" title="1">{
                        if r := recover(); r != nil </span><span class="cov8" title="1">{
                                err = exception.Nest(err, fmt.Errorf("%v", r))
                        }</span>
                }
        }()

        <span class="cov8" title="1">err = e.Action(e.Args...)
        return</span>
}
</pre>
		
		<pre class="file" id="file177" style="display: none">package workqueue

import (
        "bytes"
        "fmt"
        "runtime"
        "sync"
)

const (
        // DefaultMaxRetries is the maximum times a process queue item will be retried before being dropped.
        DefaultMaxRetries = 10

        // DefaultMaxWorkItems is the default entry buffer length.
        // Currently the default is 2^18 or 256k.
        // WorkItems maps to the initialized capacity of a buffered channel.
        // As a result it does not reflect actual memory consumed.
        DefaultMaxWorkItems = 1 &lt;&lt; 18
)

var (
        _default     *Queue
        _defaultLock sync.Mutex
)

// Default returns a singleton queue.
func Default() *Queue <span class="cov0" title="0">{
        if _default == nil </span><span class="cov0" title="0">{
                _defaultLock.Lock()
                defer _defaultLock.Unlock()
                if _default == nil </span><span class="cov0" title="0">{
                        _default = New()
                }</span>
        }
        <span class="cov0" title="0">return _default</span>
}

// Action is an action that can be dispatched by the process queue.
type Action func(args ...interface{}) error

// New returns a new work queue.
func New() *Queue <span class="cov8" title="1">{
        return &amp;Queue{
                recover:      true,
                numWorkers:   runtime.NumCPU(),
                maxRetries:   DefaultMaxRetries,
                maxWorkItems: DefaultMaxWorkItems,
        }
}</span>

// NewWithWorkers returns a new work queue with a given number of workers.
func NewWithWorkers(numWorkers int) *Queue <span class="cov8" title="1">{
        return &amp;Queue{
                recover:      true,
                numWorkers:   numWorkers,
                maxRetries:   DefaultMaxRetries,
                maxWorkItems: DefaultMaxWorkItems,
        }
}</span>

// NewWithOptions returns a new queue with customizable options.
func NewWithOptions(numWorkers, retryCount, maxWorkItems int) *Queue <span class="cov0" title="0">{
        return &amp;Queue{
                recover:      true,
                numWorkers:   numWorkers,
                maxRetries:   retryCount,
                maxWorkItems: maxWorkItems,
        }
}</span>

// Queue is the container for work items, it dispatches work to the workers.
type Queue struct {
        numWorkers   int
        maxRetries   int
        maxWorkItems int

        running bool
        recover bool

        work chan *Entry

        entryPool sync.Pool
        workers   []*Worker
        abort     chan bool
        aborted   chan bool
}

// Start starts the dispatcher workers for the process quere.
func (q *Queue) Start() <span class="cov8" title="1">{
        if q.running </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">q.workers = make([]*Worker, q.numWorkers)
        q.work = make(chan *Entry, q.maxWorkItems)
        q.abort = make(chan bool)
        q.aborted = make(chan bool)
        q.entryPool = sync.Pool{
                New: func() interface{} </span><span class="cov8" title="1">{
                        return &amp;Entry{}
                }</span>,
        }
        <span class="cov8" title="1">q.running = true

        for id := 0; id &lt; q.numWorkers; id++ </span><span class="cov8" title="1">{
                q.createAndStartWorker(id)
        }</span>

        <span class="cov8" title="1">go q.dispatch()</span>
}

// Recover returns if the queue is handling / recovering from panics.
func (q *Queue) Recover() bool <span class="cov0" title="0">{
        return q.recover
}</span>

// SetRecover sets if the queue workers should handle panics.
func (q *Queue) SetRecover(shouldRecover bool) <span class="cov0" title="0">{
        q.recover = shouldRecover
}</span>

// WithRecover sets if the queue should recover panics.
func (q *Queue) WithRecover(shouldRecover bool) *Queue <span class="cov0" title="0">{
        q.recover = shouldRecover
        return q
}</span>

// Len returns the number of items in the work queue.
func (q *Queue) Len() int <span class="cov8" title="1">{
        return len(q.work)
}</span>

// NumWorkers returns the number of worker routines.
func (q *Queue) NumWorkers() int <span class="cov0" title="0">{
        return q.numWorkers
}</span>

// SetNumWorkers lets you set the num workers.
func (q *Queue) SetNumWorkers(workers int) <span class="cov0" title="0">{
        q.numWorkers = workers
        if q.running </span><span class="cov0" title="0">{
                q.Close()
                q.Start()
        }</span>
}

// WithNumWorkers calls `SetNumWorkers` and returns a reference to the queue.
func (q *Queue) WithNumWorkers(workers int) *Queue <span class="cov0" title="0">{
        q.SetNumWorkers(workers)
        return q
}</span>

// MaxWorkItems returns the maximum length of the work item queue.
func (q *Queue) MaxWorkItems() int <span class="cov0" title="0">{
        return q.maxWorkItems
}</span>

// SetMaxWorkItems sets the max work items.
func (q *Queue) SetMaxWorkItems(workItems int) <span class="cov0" title="0">{
        q.maxWorkItems = workItems
        if q.running </span><span class="cov0" title="0">{
                q.Close()
                q.Start()
        }</span>
}

// WithMaxWorkItems calls `SetMaxWorkItems` and returns a reference to the queue.
func (q *Queue) WithMaxWorkItems(workItems int) *Queue <span class="cov0" title="0">{
        q.SetMaxWorkItems(workItems)
        return q
}</span>

// MaxRetries returns the maximum number of retries.
func (q *Queue) MaxRetries() int <span class="cov0" title="0">{
        return q.maxRetries
}</span>

// SetMaxRetries sets the maximum nummer of retries for a work item on error.
func (q *Queue) SetMaxRetries(maxRetries int) <span class="cov0" title="0">{
        q.maxRetries = maxRetries
}</span>

// WithMaxRetries calls `SetMaxRetries` and returns a reference to the queue.
func (q *Queue) WithMaxRetries(maxRetries int) *Queue <span class="cov0" title="0">{
        q.SetMaxRetries(maxRetries)
        return q
}</span>

// Running returns if the queue has started or not.
func (q *Queue) Running() bool <span class="cov8" title="1">{
        return q.running
}</span>

// Enqueue adds a work item to the process queue.
func (q *Queue) Enqueue(action Action, args ...interface{}) <span class="cov8" title="1">{
        if !q.running </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">entry := q.entryPool.Get().(*Entry)
        entry.Recover = q.recover
        entry.Action = action
        entry.Args = args
        entry.Tries = 0
        q.work &lt;- entry</span>
}

// Close drains the queue and stops the workers.
func (q *Queue) Close() error <span class="cov8" title="1">{
        if !q.running </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">q.abort &lt;- true
        &lt;-q.aborted

        close(q.abort)
        close(q.aborted)
        close(q.work)

        var err error
        for x := 0; x &lt; len(q.workers); x++ </span><span class="cov8" title="1">{
                err = q.workers[x].Close()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">q.workers = nil
        q.work = nil
        q.abort = nil
        q.aborted = nil
        q.running = false
        return nil</span>
}

// String returns a string representation of the queue.
func (q *Queue) String() string <span class="cov0" title="0">{
        b := bytes.NewBuffer([]byte{})
        b.WriteString(fmt.Sprintf("WorkQueue [%d]", q.Len()))
        if q.Len() &gt; 0 </span><span class="cov0" title="0">{
                q.Each(func(e *Entry) </span><span class="cov0" title="0">{
                        b.WriteString(" ")
                        b.WriteString(e.String())
                }</span>)
        }
        <span class="cov0" title="0">return b.String()</span>
}

// Each runs the consumer for each item in the queue.
func (q *Queue) Each(visitor func(entry *Entry)) <span class="cov0" title="0">{
        queueLength := len(q.work)
        var entry *Entry
        for x := 0; x &lt; queueLength; x++ </span><span class="cov0" title="0">{
                entry = &lt;-q.work
                visitor(entry)
                q.work &lt;- entry
        }</span>
}

func (q *Queue) createAndStartWorker(id int) <span class="cov8" title="1">{
        q.workers[id] = NewWorker(id, q, q.maxWorkItems/q.numWorkers)
        q.workers[id].Start()
}</span>

func (q *Queue) dispatch() <span class="cov8" title="1">{
        var workItem *Entry
        var workerIndex int
        numWorkers := len(q.workers)
        for </span><span class="cov8" title="1">{
                select </span>{
                case workItem = &lt;-q.work:<span class="cov8" title="1">
                        if workItem == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">q.workers[workerIndex].Work &lt;- workItem
                        if numWorkers &gt; 1 </span><span class="cov8" title="1">{
                                workerIndex++
                                if workerIndex &gt;= numWorkers </span><span class="cov8" title="1">{
                                        workerIndex = 0
                                }</span>
                        }
                case &lt;-q.abort:<span class="cov8" title="1">
                        q.aborted &lt;- true
                        return</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file178" style="display: none">package workqueue

import "sync/atomic"

// NewWorker creates a new worker.
func NewWorker(id int, parent *Queue, maxItems int) *Worker <span class="cov8" title="1">{
        return &amp;Worker{
                ID:     id,
                Parent: parent,

                Work:    make(chan *Entry, maxItems),
                Abort:   make(chan bool),
                Aborted: make(chan bool),
        }
}</span>

// Worker is a consumer of the work queue.
type Worker struct {
        ID      int
        Work    chan *Entry
        Parent  *Queue
        Abort   chan bool
        Aborted chan bool
}

// Start starts the worker.
func (w *Worker) Start() <span class="cov8" title="1">{
        go w.processWork()
}</span>

func (w *Worker) processWork() <span class="cov8" title="1">{
        var err error
        var workItem *Entry
        for </span><span class="cov8" title="1">{
                select </span>{
                case workItem = &lt;-w.Work:<span class="cov8" title="1">
                        if workItem == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">err = workItem.Execute()
                        if err != nil </span><span class="cov8" title="1">{
                                atomic.AddInt32(&amp;workItem.Tries, 1)
                                if workItem.Tries &lt; int32(w.Parent.maxRetries) </span><span class="cov8" title="1">{
                                        w.Parent.work &lt;- workItem
                                        continue</span>
                                }
                        }
                        <span class="cov8" title="1">w.Parent.entryPool.Put(workItem)</span>
                case &lt;-w.Abort:<span class="cov8" title="1">
                        w.Aborted &lt;- true
                        return</span>
                }
        }
}

// Close sends the stop signal to the worker.
func (w *Worker) Close() error <span class="cov8" title="1">{
        w.Abort &lt;- true
        &lt;-w.Aborted
        close(w.Abort)
        close(w.Aborted)
        close(w.Work)

        w.Abort = nil
        w.Aborted = nil
        w.Work = nil
        w.Parent = nil
        return nil
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
